<dtml-comment><!--

  File:   state-model.dtml
  Author: Alex Samuel
  Date:   2001-07-11

  Contents:
    Page for editing a state model.

  Copyright (C) 2001 CodeSourcery LLC.  

  For license terms see the file COPYING.

--></dtml-comment>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xhtmlns="http://www.w3.org/1999/xhtml">
 <dtml-var expr="GenerateHtmlHeader('Edit State Model')">
 <dtml-var expr="GenerateStartBody()">

  <table border="0" cellpadding="0" cellspacing="0" width="100%">
   <tr>
    <td>
     <h3>State Model</h3>
    </td>
    <td align="right">
     <dtml-var expr="web.make_help_link('state model help')">
    </td>
   </tr>
  </table>

  <form name="form">

  <table border="0" 
         cellpadding="4"
         cellspacing="4"
         width="100%">

  <tr class="field" valign="top">
   <td>
    <b>States</b>
   </td>
   <td>
    <table border="0" cellpadding="0" cellspacing="0">
     <tr valign="top">
      <td colspan="2">
       <select name="states"
	           onchange="on_states_selchange();"
               size="8"
               width="280">
        <option value="placeholder">(placeholder)</option>
       </select>
      </td>
      <td>
       <input type="button"
              size="12"
              value=" Remove "
              onclick="on_states_remove();" />
      </td>
     </tr>
     <tr>
      <td>
       Name:
      </td>
      <td>
       <input type="text"
              name="state_name"
              onkeydown="document.form.states_add_button.value = ' Add ';
                         document.form.states.selectedIndex = -1;"
              size="32" />
      </td>
      <td>
       <input type="button"
	          name="states_add_button"
              size="12"
              value=" Add "
              onclick="on_states_add()" />
      </td>
     </tr>
     <tr valign="top">
      <td>
       <br>Description:
      </td>
      <td>
       <textarea name="description"
	             cols="40"
	             rows="6">
       </textarea>
      </td>
      <td>&nbsp;</td>
     </tr>
     <tr>
      <td>
       Open:
      </td>
      <td>
       <input type="checkbox"
              name="is_open"
		      checked />
       This is an open state.
      </td>
      <td>&nbsp;</td>
     </tr>
    </table>
   </td>
  </tr>

  <tr class="field" valign="top">
   <td>
    <b>Initial State</b>
   </td>
   <td>
    <select name="initial_state"
            width="12">
        <option value="placeholder">(placeholder)</option>
    </select>
   </td>
  </tr>

  <tr class="field" valign="top">
   <td>
    <b>Transitions</b>
   </td>
   <td>
    <table border="0" cellpadding="0" cellspacing="0">
     <tr valign="top">
      <td colspan="2">
       <select name="transitions"
               size="8"
               width="280">
        <option value="placeholder">(placeholder)</option>
       </select>
      </td>
      <td>
       <input type="button"
              size="12"
              value=" Remove "
              onclick="on_transitions_remove();" />
      </td>
     </tr>
     <tr>
      <td>
       Starting State:
      </td>
      <td>
       <select name="start_state">
        <option value="placeholder">(placeholder)</option>
       </select>
      </td>
      <td>
       <input type="button"
              size="12"
              value=" Add "
              onclick="on_transitions_add();" />
      </td>
     </tr>
     <tr>
      <td>
       Ending State:
      </td>
      <td>
       <select name="end_state">
        <option value="placeholder">(placeholder)</option>
       </select>
      </td>
      <td>&nbsp;</td>
     </tr>
     <tr>
      <td>
       Condition:
      </td>
      <td>
       <input type="text"
              name="condition"
              size="32" />
      </td>
      <td>&nbsp;</td>
     </tr>
    </table>
   </td>
  </tr>

  <tr class="form-submit">
   <td colspan="2">
	<input type="button"
		   class="submit"
		   value=" OK "
		   onclick="window.opener.document.form.
						<dtml-var expr="request['input']">.value
						= encode_state_model();
					window.close();"
	/>
	<input type="button"
		   class="submit"
		   value=" Close "
		   onclick="window.close();"
	/>
   </td>
  </tr>
 </table>  

 </form>

 <dtml-var expr="GenerateEndBody()">

<script language="JavaScript1.2">

// Decode a string-encoded state model and initialize inputs.
//
// 'encoding' -- A string-encoded state model.  
//
// postconditions -- Form input show the state model.
//
// See the Python function 'qm.track.issue_class.encode_state_model' for
// a description of the encoding scheme.

function decode_state_model(encoding)
{
  var i;
  var parts, subparts;
  var select;
  
  // Split into major parts.
  parts = encoding.split("|");

  // The first part is a list of states.
  var states = new Array();
  subparts = parts[0].split(";");
  for(i = 0; i < subparts.length; ++i)
    // Decode and accumulate each state.
    states = states.concat(decode_state(subparts[i]));

  // The second part is the name of the initial state.
  var initial_state = parts[1];

  // The third part is a list of transitions.
  var transitions = new Array();
  subparts = parts[2].split(";");
  for(i = 0; i < subparts.length; ++i) 
    // Decode and accumulate each transition.
    transitions = transitions.concat(decode_transition(subparts[i]));

  // Construct options for states.
  select = document.form.states;
  // Clear out the old contents.
  select.options.length = 0;
  for(i = 0; i < states.length; ++i)
    // The option value is the encoded state.
    select.options[i] = new Option(format_state(states[i]),
                                   states[i].encoding);
  // Propagate the change in the list of states to other inputs.
  on_states_change();

  // Initialize the initial state input.
  select_item(document.form.initial_state, initial_state);

  // Construct the transitions select.
  select = document.form.transitions;  
  // Clear out the old contents.
  select.options.length = 0;
  for(i = 0; i < transitions.length; ++i)
    // The option value is the encoded transition.
    select.options[i] = new Option(format_transition(transitions[i]),
                                   transitions[i].encoding);
}


// Decode a string-encoded state.
//
// 'encoding' -- A string-encoded state.
//
// returns -- A state object.
//
// See the Python function 'qm.track.issue_class.encode_state_model' for
// a description of the encoding scheme.

function decode_state(encoding)
{
  var state = new Object();
  var parts = encoding.split(",");
  state.name = parts[0];
  state.description = unescape(parts[1]);
  state.is_open = parts[2];
  state.encoding = encoding;
  return state;
}


// Decode a string-encoded transition.
//
// 'encoding' -- A string-encoded transition.
//
// returns -- A transition object.
//
// See the Python function 'qm.track.issue_class.encode_state_model' for
// a description of the encoding scheme.

function decode_transition(encoding)
{
  var transition = new Object();
  var parts = encoding.split(",");
  transition.start = parts[0];
  transition.end = parts[1];
  if(parts.length < 3 || parts[2] == "")
    // JavaScript's 'String.split' is dumb.
    transition.condition = "";
  else
    transition.condition = unescape(parts[2]);
  transition.encoding = encoding;
  return transition
}


// Construct a user-visible representation of a state.
//
// 'state' -- A state object.
//
// returns -- A string representing the state.

function format_state(state)
{
  return state.name;
}


// Construct a user-visible representation of a transition.
//
// 'transition' -- A transition object.
//
// returns -- A string representing the transition.

function format_transition(transition)
{
  var result = transition.start + " -> " + transition.end;
  if(transition.condition != "")
    result += " [only if " + transition.condition + "]";
  return result;
}


// Construct a state object.
//
// 'name' -- The state name.
//
// 'description' -- A description of the state.
//
// 'is_open' -- Whether this is an open state; either "1" or "0".
//
// returns -- A state object.

function make_state(name, description, is_open)
{
  var state = new Object();
  state.name = name;
  state.description = description;
  state.is_open = is_open;
  state.encoding = name + "," + escape(description) + "," + is_open;
  return state;
}


// Construct a transition object.
//
// 'start' -- The name of the starting state.
//
// 'end' -- The name of the ending state.
//
// 'condition' -- The transition condition; may be an empty string.
//
// returns -- A transition object.

function make_transition(start, end, condition)
{
  var transition = new Object();
  transition.start = start;
  transition.end = end;
  transition.condition = condition;
  transition.encoding = start + "," + end + "," + escape(condition);
  return transition;
}


// Encode the state model in the form inputs as a string.
//
// returns -- A string encoding the state model in the form inputs.
//
// See the Python function 'qm.track.issue_class.encode_state_model' for
// a description of the encoding scheme.

function encode_state_model()
{
  var result = "";
  var i;
  var select;

  // Construct a semicolon-separated list of encoded states.
  select = document.form.states;
  for(i = 0; i < select.options.length; ++i) {
    if(i > 0)
      result += ";"
    result += select.options[i].value;
  }

  // Next the initial state name, separated by pipe characters.
  result += "|" + get_selected_value(document.form.initial_state) + "|"

  // Finally, a semicolon-separated list of encoded transitions.
  select = document.form.transitions;
  for(i = 0; i < select.options.length; ++i) {
    if(i > 0)
      result += ";";
    result += select.options[i].value;
  }

  return result;
}


// Update inputs when a new state is selected.

function on_states_selchange()
{
  var select = document.form.states;
  var index = select.selectedIndex;
  if(index == -1)
    // Nothing is selected.
    return;
  // Fill the value of the selected states into the other inputs, so the
  // user can modify the state.
  var state = decode_state(select.options[index].value);
  document.form.state_name.value = state.name;
  document.form.description.value = state.description;
  document.form.is_open.checked = state.is_open == "1";
  // Indicate that the state will be changed.
  document.form.states_add_button.value = " Change ";    
}


// Update inputs when the set of states changes.
//
// postconditions -- Combo box select inputs are updated to reflect the
// current list of states from the main state select input.

function on_states_change()
{
  var i;
  var state_names = new Array();

  // Construct an array of states.
  var options = document.form.states.options;
  for(i = 0; i < options.length; ++i) {
    state = decode_state(options[i].value);
    state_names = state_names.concat(state.name);
  }

  // Rebuild the initial state select.
  rebuild_state_select(document.form.initial_state, state_names);
  // Rebuild the transition start and end state selects.
  rebuild_state_select(document.form.start_state, state_names);
  rebuild_state_select(document.form.end_state, state_names);
}


// Rebuild a state combo box select for a new set of states.
//
// 'select' -- The select input to update.
//
// 'state_names' -- An array of names of states.

function rebuild_state_select(select, state_names)
{
  var i;
  var old_value;
  var options = select.options;

  // Remeber the selected value, if any, so we can restore it.
  if(select.selectedIndex == -1)
    old_value = null;
  else
    old_value = select.options[select.selectedIndex].value;

  // Clear out the select.
  options.length = 0;
  // Rebuild the options.
  for(i = 0; i < state_names.length; ++i) {
    options[i] = new Option(state_names[i], state_names[i]);
    // If this option matches the old selected value, select it.
    if(old_value == state_names[i])
      select.selectedIndex = i;
  }
}


// Remove the selected state.

function on_states_remove()
{
  var i;
  var select;
  var index;

  select = document.form.states;
  index = select.selectedIndex;
  if(index == -1)
    // Nothing selected.
    return;
  // Decode the state we're about to remove.
  var state = decode_state(select.options[index].value);
  // Remove it from the select.
  select.options[index] = null;
  // Update controls that list states.
  on_states_change();

  if(index < select.options.length) {
	// Select the previous element in the state select input.
    select.selectedIndex = index;
    on_states_selchange();
  }
  else {
	// Don't select anything, and clear out the other state inputs.
	document.form.state_name.value = "";
	document.form.description.value = "";
	document.form.is_open.checked = true;
	document.form.states_add_button.value = " Add ";    
  }

  // Discard all transitions involving this state.
  select = document.form.transitions;
  for(i = select.options.length - 1; i >= 0; --i) {
    transition = decode_transition(select.options[i].value);
	// Does the transition start or end at this state?
    if(transition.start == state.name || transition.end == state.name)
	  // Yes; drop it.
      select.options[i] = null;
  }
}


// Add a new state, or commit changes to an existing state.
//
// Uses contents of state inputs to construct the new state.
//
// If the state name matches an existing state, that state is modified.
// Otherwse, creates a new state.

function on_states_add()
{
  var i;
  var select = document.form.states;
  var index;

  // Extract attributes of the new state.
  var state_name = document.form.state_name.value;
  var description = document.form.description.value;
  var is_open = document.form.is_open.checked ? "1" : "0";
  var state = make_state(state_name, description, is_open);

  // If the state name isn't valid, complain and bail.
  if(!label_is_valid(state_name)) {
    popup_box("Error",
              "A state name can consist only of lower-case letters, " +
              "digits, and underscores, and cannot be empty.");
    return;
  }

  // Compare the state name to existing states.  If we don't find a
  // match, we'll append a new state.
  index = select.options.length;
  for(i = 0; i < select.options.length; ++i) {
    if(decode_state(select.options[i].value).name == state_name) {
	  // A match.  Modify this state instead of appending.
      index = i;
	  break;
	}
  }

  // Construc the new select option.
  select.options[index] = new Option(format_state(state), state.encoding);
  // Select the added or changed item.
  select.selectedIndex = index;
  on_states_change();
  document.form.states_add_button.value = " Change ";
}


// Remove the selected transition.

function on_transitions_remove()
{
  var select = document.form.transitions;
  var index = select.selectedIndex;
  if(index == -1)
    // Nothing selected.
    return;
  // Remove the transition from the list.
  select.options[index] = null;
  // Select the previous transition, if there is one.
  if(index < select.options.length)
    select.selectedIndex = index;
  else
    select.selectedIndex = - 1;
}


// Add a new transition.
//
// Uses contents of transition inputs to construct the new transition.

function on_transitions_add()
{
  var select = document.form.transitions;
  var index = select.options.length;
  var transition;

  // Construct the transition object.
  transition = make_transition(
      get_selected_value(document.form.start_state),
      get_selected_value(document.form.end_state),
      document.form.condition.value);
  // Append it to the select.
  select.options[index] = new Option(format_transition(transition), 
									 transition.encoding);
  // Select the newly-added item.
  select.selectedIndex = index;
}


// Decode the state model and initialize inputs on load.
decode_state_model(window.opener.document.form.
                   <dtml-var expr="request['input']">.value);

</script>

</html>

<dtml-comment><!-- 
  Local Variables:
  mode: xml
  indent-tabs-mode: nil
  fill-column:72
  End:
--></dtml-comment>
