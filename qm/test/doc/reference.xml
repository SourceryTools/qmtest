<?xml version="1.0"?>
<!--

  File:   test-manual.xml
  Author: Alex Samuel
  Date:   2000-11-01

  Contents:
    Manual for QMTest.

  Copyright (C) 2001, 2002, 2003 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<chapter id="chap-test-manual">
 <title>Using &qmtest;</title>

  <para>This chapter describes &qmtest; in more detail.  It explains
  the fundamental concepts that &qmtest; uses, the test classes that
  come with &qmtest;, and how to extend &qmtest; to support new
  application domains.</para>

  <para>The central principle underlying the design of QMTest is that
  the problem of testing can be divided into a domain-dependent problem
  and a domain-independent problem.  The domain-dependent problem is
  deciding what to test and how to test it.  For example, should a
  database be tested by performing unit tests on the C code that makes
  up the database, or by performing integration tests using SQL queries?
  How should the output of a query asking for a set of records be
  compared to expected output?  Does the order in which the records
  presented in matter?  These are questions that only someone who
  understands the application domain can answer.</para>

  <para>The domain-independent part of the problem is managing the
  creation of tests, executing the tests, and displaying the results for
  users.  For example, how does a user create a new test?  How are tests
  stored?  Should failing tests be reported to the user, even if the
  failure was expected?  These questions are independent of the
  application domain; they are just as relevant for compiler tests as
  they are for database tests.</para>

  <para>QMTest is intended to solve the domain-independent part of the
  problem and to offer a convenient, powerful, and flexible interface
  for solving the domain-dependent problem.  QMTest is both a complete
  application, in that it can be used <quote>out of the box</quote> to
  handle many testing domains, and infrastructure, in that it can be
  extended to handle other domains.</para>

  <section id="sec-qmtest-concepts">
  <title>&qmtest; Concepts</title>

  <para>This section presents the concepts that underlie &qmtest;'s design.  By
  understanding these concepts, you will be able to better understand
  how &qmtest; works.  In addition, you will find it easier to extend
  &qmtest; to new application domains.</para>

  <section id="sec-tests">
   <title>Tests</title>

   <para>A <firstterm>test</firstterm> checks for the correct behavior
   of the target application.  What constitutes correct behavior will
   vary depending on the application domain.  For example, correct
   behavior for a database might mean that it is able to retrieve
   records correctly while correct behavior for a compiler might mean
   that it generates correct object code from input source code.</para>
 
   <para>Every test has a name that uniquely identifies the test,
   within a given <link linkend="sec-test-database">test
   database</link>.  Test names must be composed entirely of lowercase
   letters, numbers, the <quote>_</quote> character, and the
   <quote>.</quote> character.  You can think of test names like file
   names.  The <quote>.</quote> character takes the place of
   <quote>/</quote>; it allows you to place a test in a particular
   <firstterm>directory</firstterm>.  For example, the test name
   <filename>a.b.c</filename> names a test named
   <filename>c</filename> in the directory <filename>a.b</filename>.
   The directory <filename>a.b</filename> is a subdirectory of the
   directory <filename>a</filename>.</para>

   <para>Every test is an instance of some test class.  The test class
   dictates how the test is run, what constitutes success, and what
   constitutes failure.  For example, the
   <classname>command.ExecTest</classname> class that comes with
   &qmtest; executes the target application and looks at its output.
   The test passes if the actual output exactly matches the expected
   output.</para>

   <para>The arguments to the test parameterize the test; they are
   what make two instances of the same test class different from each
   other.  For example, the arguments to
   <classname>command.ExecTest</classname> indicate which application to
   run, what command-line arguments to provide, and what output is
   expected.</para>

   <para>Sometimes, it may be pointless to run one test unless another
   test has passed.  Therefore, each test can have a set of associated
   <firstterm>prerequisite tests</firstterm>.  If the prerequisite
   tests did not pass, &qmtest; will not run the test that depends
   upon them.</para>

  </section> <!-- sec-tests -->

  <section id="sec-resources">
   <title>Resources</title>

   <para>Some tests take a lot of work to set up.  For example, a
   database test that checks the result of SQL queries may require
   that the database first be populated with a substantial number of
   records.  If there are many tests that all use the same set of
   records, it would be wasteful to set up the database for each test.
   It would be more efficient to set up the database once, run all of
   the tests, and then remove the databases upon completion.</para>

   <para>You can use a <firstterm>resource</firstterm> to gain this
   efficiency.  If a test depends on a resource, &qmtest; will ensure
   that the resource is available before the test runs.  Once all
   tests that depend on the resource have been run &qmtest; will
   destroy the resource.</para>

   <para>Just as every test is an instance of a <firstterm>test
   class</firstterm>, every resource is an instance of a
   <firstterm>resource class</firstterm>.  The resource class explains
   how to set up the resource and how to clean up when it is no longer
   needed.  The arguments to the resource class are what make two
   instances of the same resource class different from each other.
   For example, in the case of a resource that sets up a database, the
   records to place in the database might be given as arguments.
   Every resource has a name, using the same format that is used for
   tests.</para>

   <para>Under some circumstances (such as running tests on multiple
   machines at once), &qmtest; may create more than one instance of
   the same resource.  Therefore, you should never depend on there
   being only one instance of a resource.  In addition, if you have
   asked &qmtest; to run tests concurrently, two tests may access the
   same resource at the same time.  You can, however, be assured that
   there will be only one instance of a particular resource on a
   particular target at any one time.</para>
 
   <para>Tests have limited access to the resources on which they
   depend.  A resource may place additional information into the
   context (<xref linnkend="sec-context"/>) that is visible to the
   test.  However, the actual resource object itself is not available
   to tests.  (The reason for this limitiation is that for a target
   consisting of multiple processes, the resource object may not be
   located in the process as the test that depends upon it.)</para>

   <para>Setting up or cleaning up a resource produces a result, just
   like those produced for tests.  &qmtest; will display these results
   in its summary output and record them in the results file.</para>

  </section> <!-- sec-resources -->

  <section id="sec-context">
   <title>Context</title>

   <para>When you create a test, you choose arguments for the test.
   The test class uses this information to run the test.  However, the
   test class may sometimes need information that is not available
   when the test is created.  For example, if you are writing compiler
   tests to verify conformance with the C programming language
   specification, you do not know the location of the C compiler
   itself.  The C compiler may be installed in different locations on
   different machines.</para>

   <para>A <firstterm id="def-context">context</firstterm> gives users
   a way of conveying this kind of information to tests.  The context
   is a set of key/value pairs.  The keys are always strings.  The
   values of all context properties provided by the user are strings.
   In general, all tests in a given use of &qmtest; will have the same
   context.  However, when a resource is set up, it may place
   additional information in the context of those tests that depend
   upon it.  The values inserted by the resource may have any type, so
   long as they can be &quot;pickled&quot; by Python.</para>

   <para>All context properties whose names begin with
   &quot;<literal>qmtest.</literal>&quot; are reserved for use by
   &qmtest;.  The values inserted by &qmtest; may have any type.  Test
   and resource classes should not depend on the presence or absence
   of these properites.</para>

  </section> <!-- sec-context -->

  <section id="sec-test-results">
   <title>Test Results</title>

   <para>A <firstterm id="def-result">result</firstterm> is an
   <firstterm id="def-outcome">outcome</firstterm> together with some
   <firstterm>annotations</firstterm>.  The outcome indicates whether
   the test passed or failed.  The annotations give additional
   information about the result, such as the manner in which the test
   failed, the output the test produced, or the amount of time it took
   to run the test.</para>

   <section id="sec-outcomes">
    <title>Outcomes</title>

    <para>The outcome of a test indicates whether it passed or failed,
    or whether some exceptional event occurred.  There are four test
    outcomes:
     <itemizedlist>
      <listitem>
       <para>&PASS;: The test succeeded.</para>
      </listitem>

      <listitem>
       <para>&FAIL;: The test failed.</para>
      </listitem>

      <listitem>
       <para>&ERROR;: A problem occurred in the test execution
       environment, rather than in the tested system.  For example, this
       outcome is used when the test class attempted to run an
       executable in order to test it, but could not because the system
       call to create a new process failed.</para>

       <para>This outcome may also indicate a defect in &qmtest; or in
       the test class.</para>
      </listitem>

      <listitem>
       <para>&UNTESTED;: &qmtest; did not attempt to execute the test.
       For example, this outcome is used when &qmtest; determines that
       a prerequisite test failed.</para>
      </listitem>
     </itemizedlist>
    </para>

   </section> <!-- sec-outcomes -->

   <section id="sec-annotations">
    <title>Annotations</title>
  
    <para>An annotation is a key/value pair.  Both the keys and values
    must are strings.  When a test (or resource) runs it may add
    annotations to the result.  These annotations are displayed by
    &qmtest; and preserved in the results file.  If you write your own
    test class, you can use annotations to store information that will
    make your test class more informative.</para>

   </section> <!-- sec-annotations -->

  </section> <!-- sec-test-results -->

  <section id="sec-test-suite">
   <title>Test Suite</title>

   <para>A <firstterm>test suite</firstterm> is a collection of tests.
   &qmtest; can run an entire test suite at once, so by grouping tests
   together in a test suite, you make it easier to run a number of
   tests at once.  A single test can be a member of more than one test
   suite.  A test suite can contain other test suites; the total set
   of tests in a test suite includes both those tests included
   directly and those tests included as part of another test suite.
   Every test suite has a name, following the same conventions given
   above for tests and resources.</para>

   <para>One use of test suites is to provide groups of tests that are
   run in different situations.  For example, the
   <literal>nightly</literal> test suite might consist of those tests
   that should be run automatically every night, while the
   <literal>checkin</literal> test suite might consist of those tests
   that have to pass before any changes are made to the target
   application.</para>

   <section id="sec-implicit-test-suites">
    <title>Implicit Test Suites</title>

    <para><xref linkend="sec-tests"/> explains how you may arrange
    tests in a tree hierarchy, using a period
    (<quote><literal>.</literal></quote>) as the path separator in
    test names.  &qmtest; defines an <firstterm>implicit test
    suite</firstterm> for each directory.  The name of these implicit
    test suites is the same as the name of the directory.  The
    implicit test suite corresponding to a directory contains all
    tests in that directory or its subdirectories.</para>

    <para>Consider, for example, a test database which contains tests
    with these names:</para>

    <simplelist type="vert" columns="1">
     <member><filename>back_end.db_1</filename></member>
     <member><filename>back_end.db2</filename></member>
     <member><filename>front_end.cmdline</filename></member>
     <member><filename>front_end.gui.widget_1</filename></member>
     <member><filename>front_end.gui.widget_2</filename></member>
    </simplelist>

    <para>For this test database, &qmtest; defines implicit test suites
    with IDs <filename>back_end</filename>, <filename>front_end</filename>,
    and <filename>front_end.gui</filename>.  The test suite
    <filename>front_end</filename> contains the tests
    <filename>front_end.cmdline</filename>,
    <filename>front_end.gui.widget_1</filename>, and
    <filename>front_end.gui.widget_2</filename>.</para>

    <para>The suite named "<filename>.</filename>" (a single period) is
    the implicit test suite corresponding to the root directory in the
    test database.  This suite therefore contains all tests in the
    database.  For example, the command

    <screen>
&prompt;<userinput>qmtest run .</userinput>
    </screen>

    is equivalent to:

    <screen>
&prompt;<userinput>qmtest run</userinput>
    </screen>

    Both commands run all tests in the database.</para>

   </section> <!-- sec-implicit-test-suites -->

  </section> <!-- sec-test-suite -->

  <section id="sec-test-database">
   <title>Test Database</title>

   <para>A <firstterm id="def-test-database">test database</firstterm>
   stores tests, test suites, and resources.  When you ask &qmtest;
   for a particular test by name, it queries the test database to
   obtain the test itself.  &qmtest; stores a test database in a
   single directory, which may include many files and
   subdirectories.</para>
 
   <para>In general, &qmtest; can only use one test database at a
   time.  However, it is possible to create a test database which
   contains other test databases.  This mechanism allows you to store
   the tests associated with different parts of a large application in
   different test databases, and still combine them into a single
   large test database when required.</para>

   <para>A single test database can store many different kinds of
   tests.  By default, &qmtest; stores tests, resources, and test
   suites in the test database using subdirectories containing XML
   files.  Generally, there should be no need to examine or modify
   these files directly.  However, the use of an XML format makes it
   easy for you to automatically generate tests from another program,
   if required.</para>

  </section> <!-- sec-test-database -->

  <section id="sec-targets">
   <title>Targets</title>

   <para>A <firstterm id="def-target">target</firstterm> is &qmtest;'s
   abstraction of a machine.  By using multiple targets, you can run your
   tests on multiple machines at one.  If you have many tests, and
   many machines, you can greatly reduce the amount of time it takes
   to run all of your tests by distributing the tests across multiple
   targets.</para>

   <para>By default, &qmtest; uses only one target: the machine on
   which you are running &qmtest;.  You may specify other targets by
   creating a target file, which lists the available targets and their
   attributes, and specifying the target file when you invoke
   &qmtest-cmd;.</para>

   <para>Each target is a member of a single <firstterm
   id="def-target-group">target group</firstterm>.  All machines in
   the same target group are considered equivalent.  A target group is
   specified by a string.  If you are testing software on multiple
   platforms at once, the target group might correspond to machines
   running the same operating system.  For example, all Intel 80386
   compatible machines running GNU/Linux might be in the
   <quote><literal>i386-pc-linux-gnu</literal></quote> target
   group.</para>

   <para><xref linkend="sec-ref-targets"/> describes how you specify and
   use targets with &qmtest;.</para>

  </section> <!-- sec-targets -->

 </section> <!-- Concepts -->

 <section id="sec-running-tests">
  <title>Running Tests</title>

  <para>To run one or more tests, use the <command>&qmtest-cmd;
  run</command> command.  Each invocation of the <command>&qmtest-cmd;
  run</command> command is a single test run, and produces a single set
  of test results and statistics.  Specify as arguments the names of tests
  and test suites to run.  Even if you specify a test more than once,
  either directly or by incorporation in a test suite, &qmtest; runs it
  only once.</para>

  <para>If you wish to run all tests in the test database, use the
  implicit test suite <literal>.</literal> (a single period; see <xref
  linkend="sec-implicit-test-suites"/>), or omit all IDs from the
  command line.</para>

  <para>&qmtest; can run tests in multiple concurrent threads of
  execution or on multiple remote hosts.  See the documentation for the
  <link linkend="sec-testcmd-run"><command>run</command> command</link>
  for details.</para>

  <section id="sec-ordering-and-dependencies">
   <title>Ordering and Dependencies</title>

   <para>Given one or more input test names and test suite names, &qmtest;
   employs the following procedure to determine which tests and
   resources to run and the order in which they are run.</para>

   <orderedlist>
    <listitem>
     <para>&qmtest; resolves test names and test suite names.  Test suites
     are expanded into the tests they contain.  Since test suites may
     contain other test suites, this process is repeated until all test
     suites have been expanded.  The result is a set of tests that are
     to be run.</para>
    </listitem>

    <listitem>
     <para>&qmtest; computes a schedule for running the tests to be run
     such that a test's prerequisites are run before the test itself is
     run.  Prerequisites not included in the test run are ignored.
     Outside of this condition, the order in which tests are run is
     undefined.</para>

     <para>If &qmtest; is invoked to run tests in parallel or
     distributed across several <link
     linkend="def-target">targets</link>, the tests are distributed
     among them as well.  &qmtest; does not guarantee that a test's
     prerequisites are run on the same target, though.  On each target,
     tests are assigned to the next available concurrent process or
     thread.</para>
    </listitem>

    <listitem>
     <para>&qmtest; determines the required resources for the tests to be run.
     If several tests require the same resource, &qmtest; attempts to
     run all of the tests on the same target.  In this case, the
     resource is set up and cleaned up only once.  In some cases,
     &qmtest; may schedule the tests on multiple targets; in that case,
     the resource is set up and cleaned up once on each target.</para>
    </listitem>
   </orderedlist>

   <para>In some cases, a test, resource setup function, or resource
   cleanup function is not executed:</para>

   <itemizedlist>
    <listitem>
     <para>A test specifies for each of its prerequisite tests an
     expected outcome.  If the prerequisite is included in the test run
     and the actual outcome of the prerequisite test is different from
     the expected outcome, the test is not run.  Instead, it is given an
     &UNTESTED; outcome.</para>

     <para>If a test's prerequisite is not included in the test run,
     that prerequisite is ignored.</para>
    </listitem>

    <listitem>
     <para>If a setup function for one of the resources required by a
     test fails, the test is given an &UNTESTED; outcome.</para>
    </listitem>

    <listitem>
     <para>The cleanup function of a resource is run after the last test
     that requires that resource, whether or not that test was run.  The
     cleanup function is run even if the setup function failed.</para>
    </listitem>
   </itemizedlist>

  </section> <!-- Ordering and Dependencies -->

  <section id="sec-the-context">
   <title>The Context</title>

   <para>&qmtest; passes a context object to the
   <function>Run</function> method of a test that is run and to the
   <function>SetUp</function> method of a resource.</para>

   <para>Most of the properties of the context are the same for all
   tests and resource functions run during a single test run.  These
   properties are configured as part of the test run.  For example, when
   you run tests using the <command>&qmtest-cmd; run</command> command,
   you may specify individual context properties with the <link
   linkend="opt-test-run-context"><option>&dashdash;context</option>
   (<option>-c</option>)</link> or <link
   linkend="opt-test-run-context-file"><option>&dashdash;load-context</option>
   (<option>-C</option>)</link> options.</para>

   <para>In addition, a resource setup function may add additional
   properties to a context.  These added properties do not become part
   of the common context; they are hidden from other tests and resources
   except that the properties added by a resource are visible to tests 
   that require that resource.</para>

   <para>For instance, a resource <function>SetUp</function> function
   might allocate the resource and place a handle to it (for instance,
   a temporary directory name or a database session key) in the
   context as a context property.  Tests that require that resource
   have access to the temporary resource via the handle stored in the
   context.  The resource's cleanup function also uses the handle to
   deallocate the resource.  That information should be stored in the
   resource object itself since no context is made available to the
   <function>CleanUp</function>.</para>

  </section> <!-- The Context -->

 </section> <!-- Running Tests -->

 <section id="sec-database-contents">
  <title>Test Database Contents</title>

  <para>The default &qmtest; test database implementation stores the
  database as a directory hierarchy containing XML files.  Each QMTest
  subdirectory is represented by a subdirectory in the filesystem.  A
  test, suite, or resource is represented by an XML file.  These files
  have file extensions <filename>.qmt</filename>,
  <filename>.qms</filename>, and <filename>.qma</filename>,
  respectively.</para>

  <para>Expert &qmtest; users may modify the contents of the test
  database directly by editing these files.  However, it is the user's
  responsibility to ensure the integrity and validity of the XML
  contents of each file.  For example, file and directory names should
  contain only characters allowed in identifiers (lower-case letters,
  digits, hyphens, and underscores); a period should only be used
  before a file extension, such as <filename>.qmt</filename>.  Also,
  the files and directories in a test database should not be modified
  directly while &qmtest; is running with that test database.</para>

 </section> <!-- sec-database-contents -->

 <section id="sec-test-command-line">
  <title>Invoking &qmtest;</title>

  <para>All &qmtest; functionality is available using the &qmtest-cmd; 
  command.</para>

  <section>
   <title>&qmtest-cmd;</title>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd;</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
     <arg choice="plain">
      <replaceable>command</replaceable>
     </arg>
     <arg choice="opt" rep="repeat">
      <replaceable>command-option</replaceable>
     </arg>
     <arg choice="opt" rep="repeat">
      <replaceable>argument</replaceable>
     </arg>
    </cmdsynopsis>
   </section>

   <section>
    <title>Options</title>

    <para>These options can be used with any &qmtest; command, and must
    precede the command name on the command line.</para>

    <para>All options are available in a "long form" prefixed with
    "&dashdash;" (two hyphens).  Some options also may be specified in
    a "short form" consisting of a single hyphen and a one-letter
    abbreviation.  Short-form options may
    be combined; for example, <command>-abc</command> is equivalent to
    <command>-a -b -c</command>.</para>

    <variablelist>
     <varlistentry>
      <term><option>-D</option> <replaceable>path</replaceable></term>
      <term>
       <option>&dashdash;tdb</option> <replaceable>path</replaceable> 
      </term>
      <listitem>
       <para>Use the test database located in the directory given by
       <replaceable>path</replaceable>.  This flag overrides the value of
       the environment variable <envar>QMTEST_DB_PATH</envar>.  If
       neither this flag nor the environment variable is specified,
       &qmtest; assumes that the current directory should be used as the
       database.  See <xref linkend="sec-test-database"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-h</option></term>
      <term><option>&dashdash;help</option></term>
      <listitem>
       <para>Display help information, listing commands and general
       options for the &qmtest-cmd; command.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>&dashdash;verbose</option></term>
      <listitem>
       <para>Generate progress and status messages while executing.  This
       option may be specified more than once; the more times it is
       specified, the higher the verbose level, and the more messages are
       printed.</para>
      </listitem>
     </varlistentry>
    
     <varlistentry>
      <term><option>&dashdash;version</option></term>
      <listitem>
       <para>Describe the version of &qmtest; in use.</para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>Additional options are available for specific commands; these
    are presented with each command.  Options specific to a command must
    follow the command on the command line.  Specify the
    <option>&dashdash;help</option> (<option>-h</option>) option after the
    command for a description of the command and a list of of available
    options for that command.</para>
   </section>
  </section>

  <section id="sec-testcmd-create">
   <title><command>&qmtest-cmd; create</command></title>

   <section>
    <title>Summary</title>
    <para>Create a new extension instance.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; create</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
     <arg choice="plain">
      <replaceable>descriptor</replaceable>
     </arg>
    </cmdsynopsis>
   </section>
    
   <section>
    <title>Description</title>
    <para>The <command>&qmtest-cmd; create</command> creates a new
    extension instance.  For example, this command can be used to
    create a new test or resource.  For a list of the types of
    extensions supported by &qmtest;, run <command>&qmtest-cmd;
    extensions</command>.</para>

    <para>The descriptor specifies an extension class and (optionally)
    attributes for that extension class.  The form of the descriptor is
    <command><replaceable>class</replaceable>(<replaceable>attributes</replaceable>)</command>,
    where the attributes are of the form
    <command><replaceable>attr</replaceable> =
    &quot;<replaceable>val</replaceable>&quot;</command>.  If there
    are no attributes, the parentheses may be omitted.</para>

    <para>If the <replaceable>class</replaceable> names a extension
    file (such as an existing test or resource file), that file is
    read.  The extension class used is the one specified in that
    file.  Any attributes specified in the file are also read.</para>

    <para>Any attributes specified in the descriptor (including those
    in the extension file, if <replaceable>class</replaceable>
    indicates an extension file) override those provided on the
    command line using the <option>&dashdash;attribute</option> option.</para>

    <para>The new extension file is written to the file specified with
    the <option>&dashdash;output</option> option, or to the standard
    output if no <option>&dashdash;output</option> is specified.</para>

    <para>The <command>create</command> command accepts these
    options:</para>    

    <variablelist>
     <varlistentry>
      <term><option>-a</option> <replaceable>name=value</replaceable></term>
      <term>
       <option>&dashdash;attribute</option> 
       <replaceable>name=value</replaceable>
      </term>
      <listitem>
       <para>Set the target class argument
       <replaceable>name</replaceable> to
       <replaceable>value</replaceable>.  The set of valid argument names
       and valid values is dependent on the extension class in use.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-o</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;output</option> 
       <replaceable>file</replaceable>
      </term>
      <listitem>
       <para>Write a description of the extension instance to
       <replaceable>file</replaceable>.</para>
      </listitem>
     </varlistentry>
    </variablelist>

   </section>
  </section>

  <section id="sec-testcmd-create-target">
   <title><command>&qmtest-cmd; create-target</command></title>

   <section>
    <title>Summary</title>
    <para>Create a new target.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; create-target</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
     <arg choice="plain">
      <replaceable>name</replaceable>
     </arg>
     <arg choice="plain">
      <replaceable>class</replaceable>
     </arg>
     <arg choice="opt">
      <replaceable>group</replaceable>
     </arg>
    </cmdsynopsis>
   </section>

   <section>
    <title>Description</title>
    <para>The <command>&qmtest-cmd; create-target</command> command
    creates a new target.  A target is an entity that runs tests;
    normally, a target corresponds to a particular machine.</para>

    <para>The target's name and class must be specified.  An optional
    group may also be specified.  When &qmtest; decides which target
    to use to run a particular tests, it will select a target that
    matches the test's requested target group.</para>

    <para>The <command>create-target</command> command accepts these
    options:</para>

    <variablelist>
     <varlistentry>
      <term><option>-a</option> <replaceable>name=value</replaceable></term>
      <term>
       <option>&dashdash;attribute</option> 
       <replaceable>name=value</replaceable>
      </term>
      <listitem>
       <para>Set the target class argument
       <replaceable>name</replaceable> to
       <replaceable>value</replaceable>.  The set of valid argument names
       and valid values is dependent on the target class in use.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;targets</option> <replaceable>file</replaceable>
      </term>
      <listitem>
       <para>Write the target description to the indicated
       <replaceable>file</replaceable>.  If there are already targets
       listed in <replaceable>file</replaceable>, they will be
       preserved, except that any target with the same name as the new
       target will be removed.  If this option is not present, the
       file used will be the <filename>QMTest/targets</filename> file
       in the test database directory.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>
  </section>

  <section id="sec-testcmd-create-tdb">
   <title><command>&qmtest-cmd; create-tdb</command></title>

   <section>
    <title>Summary</title>
    <para>Create a new test database.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; create-tdb</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
    </cmdsynopsis>
   </section>

   <section>
    <title>Description</title>
    <para>The <command>&qmtest-cmd; create-tdb</command> command
    creates a new, empty test database.  A test database is a
    directory in which &qmtest; stores configuration files, tests, and
    other data.  Certain test database classes may also store data
    elsewhere, such as in an external relational database.</para>

    <para>The test database is created in the directory specified by
    <option>&dashdash;tdb</option> (<option>-D</option>) option or by
    setting the <envar>QMTEST_DB_PATH</envar> environment variable.
    If no database path is specified, &qmtest; assumes that the
    current directory is the test database.</para>

    <para>By default, &qmtest; creates a new test database that uses the
    standard XML-based implementation.  (See <xref
    linkend="sec-ref-writing-database-classes"></xref> for information
    about writing a test database class.)</para>

    <para>The <command>create-tdb</command> command accepts these
    options:</para>

    <variablelist>
     <varlistentry>
      <term><option>-a</option> <replaceable>name=value</replaceable></term>
      <term>
       <option>&dashdash;attribute</option> 
       <replaceable>name=value</replaceable>
      </term>
      <listitem>
       <para>Set the database attribute
       <replaceable>name</replaceable> to
       <replaceable>value</replaceable>.  The set of attribute names
       and valid values is dependent on the database class in use.
       The default database class accepts no attributes.</para>
      </listitem>
     </varlistentry>

     <varlistentry> 
      <term><option>-c</option> <replaceable>class</replaceable></term>
      <term>
       <option>&dashdash;class</option> <replaceable>class</replaceable>
      </term>
      <listitem>
       <para>Use the test database class given by
       <replaceable>class</replaceable>.  The
       <replaceable>class</replaceable> may have the general form
       described in <xref linkend="sec-testcmd-create"/>.  Once you create a
       test database, you cannot change the test database
       implementation it uses.  If you do not use this option,
       &qmtest; will use the default test database implementation,
       which uses an XML file format to store tests.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>
  </section> <!-- sec-testcmd-create-tdb -->

  <section id="sec-testcmd-gui">
   <title><command>&qmtest-cmd; gui</command></title>

   <section>
    <title>Summary</title>
    <para>Start the graphical user interface.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; gui</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
    </cmdsynopsis>
   </section>

   <section>
    <title>Description</title>

     <para>The <command>&qmtest-cmd; gui</command> starts the
     graphical user interface.  The graphical user interface is
     accessed through a web browser.  You must have a web browser that
     supports JavaScript to use the graphical interface.  &qmtest; has
     been tested with recent versions of Internet Explorer and
     Netscape Navigator.  Other web browsers may or may nor work with
     &qmtest;.</para>

     <para>The <command>gui</command> command accepts these
     options:</para>

     <variablelist>
      <varlistentry>
       <term><option>-A</option> <replaceable>address</replaceable></term>
       <term>
        <option>&dashdash;address</option> <replaceable>address</replaceable>
       </term>
       <listitem>
        <para>Bind the server to the indicated internet
         <replaceable>address</replaceable>, which should be a dotted
         quad.  By default, the server binds itself to the address
         <literal>127.0.0.1</literal>, which is the address of the local
         machine.  If you specify another address, the server will
         be accessible to users on other machines.  QMTest does not
         perform any authentication of remote users, so you should
         not use this option unless you have a firewall in place that
         blocks all untrusted users.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>-c</option> <replaceable>name=value</replaceable></term>
       <term>
        <option>&dashdash;context</option> 
        <replaceable>name=value</replaceable>
       </term>
       <listitem>
        <para>For details about this option, see the description of the 
        <command>qmtest run</command> command.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>-C</option> <replaceable>file</replaceable></term>
       <term>
        <option>&dashdash;load-context</option> <replaceable>file</replaceable>
       </term>
       <listitem>
        <para>For details about this option, see the description of the 
        <command>qmtest run</command> command.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>&dashdash;daemon</option></term>
       <listitem>
        <para>Run the QMTest GUI as a daemon.  In this mode, QMTest
        will detach from the controlling terminal and run in the 
        background until explicitly shutdown.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>-j</option> <replaceable>count</replaceable></term>
       <term>
        <option>&dashdash;concurrency</option> <replaceable>count</replaceable>
       </term>
       <listitem>
        <para>For details about this option, see the description of the 
        <command>qmtest run</command> command.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <option>&dashdash;no-browser</option>
       </term>
       <listitem>
        <para>Do not attempt to start a web browser when starting the
        GUI.  &qmtest; will still print out the URL at which the server
        can be accessed.  You can then connect to this URL
        manually using the browser of your choice.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>-O</option> <replaceable>file</replaceable></term>
       <term>
        <option>&dashdash;outcomes</option> <replaceable>file</replaceable>
       </term>
       <listitem>
        <para>For details about this option, see the description of the 
        <command>qmtest run</command> command.</para>
       </listitem>
      </varlistentry> 

      <varlistentry>
       <term>
        <option>&dashdash;pid-file <replaceable>path</replaceable></option>
       </term>
       <listitem>
        <para>Specify the <replaceable>path</replaceable> to which
        the QMTest GUI will write its process ID.  This option is
        useful if you want to run QMTest as a daemon.  If this option
        is not provided, no PID file is written.  If you specify this
        option, but <replaceable>path</replaceable> is the empty
        string, QMTest will check the <filename>.qmrc</filename>
        configuration file for a <literal>pid-file</literal> entry.
        If there is no such entry, QMTest will use an appropriate
        platform-specific default value.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <option>&dashdash;port <replaceable>port</replaceable></option>
       </term>
       <listitem>
        <para>Specify the <replaceable>port</replaceable> on which the
        &qmtest; GUI will listen for connections.  If this option is not
        provided, &qmtest; will select an available port
        automatically.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>-T</option> <replaceable>file</replaceable></term>
       <term>
        <option>&dashdash;targets</option> <replaceable>file</replaceable>
       </term>
       <listitem>
        <para>For details about this option, see the description of the 
        <command>qmtest run</command> command.</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </section>
   </section> <!-- sec-testcmd-gui -->

  <section id="sec-testcmd-extensions">
   <title><command>&qmtest-cmd; extensions</command></title>

   <section>
    <title>Summary</title>
    <para>List available extension classes.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; extensions</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
    </cmdsynopsis>
   </section>

   <section>
    <title>Description</title>

    <para>The <command>&qmtest-cmd; extensions</command> lists
    available extension classes and provides a brief description of
    each class.  You can use this command to list all of the available
    extension classes, or to list all of the available extension
    classes of a particular type.  For example, you can use this
    command to list all of the available test classes.</para>

    <para>The <command>extensions</command> command accepts these
    options:</para>

    <variablelist>
     <varlistentry>
      <term>
       <option>-k</option>
       <replaceable>kind</replaceable>
      </term>
      <term>
       <option>&dashdash;kind</option> 
       <replaceable>kind</replaceable>
      </term>
      <listitem>
       <para>List the available extension classes of the indicated
       <replaceable>kind</replaceable>.  The
       <replaceable>kind</replaceable> must be one of
       <literal>test</literal>, <literal>resource</literal>,
       <literal>target</literal>, or <literal>database</literal>.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>

  </section> <!-- sec-testcmd-extensions -->

  <section id="sec-testcmd-register">
   <title><command>&qmtest-cmd; register</command></title>

   <section>
    <title>Summary</title>
    <para>Register an extension class.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; register</command>
     <arg choice="plain"><replaceable>kind</replaceable></arg>
     <arg choice="plain"><replaceable>class-name</replaceable></arg>
    </cmdsynopsis>
   </section>

   <section>
    <title>Description</title>

    <para>The <command>&qmtest-cmd; register</command> registers an
    extension class with QMTest.  As part of this process, QMTest will 
    load your extension class.  If the extension class cannot be
    loaded, QMTest will tell you what went wrong.</para>

    <para>QMTest will search for your extension class in the
    directories it would search when running tests, including those
    given by the environment variable
    <envar>QMTEST_CLASS_PATH</envar>.</para>

    <para>The <replaceable>kind</replaceable> argument tells QMTest
    what kind of extension class you are registering.  The
    <replaceable>kind</replaceable> must be one of
    <literal>test</literal>, <literal>resource</literal>,
    <literal>target</literal>, or <literal>database</literal>.</para>

    <para>The <replaceable>class-name</replaceable> argument gives the
    name of the class in the form
    <classname>module.Class</classname>.  QMTest will look for a file
    whose basename is the module name and whose extension is either
    <filename>py</filename>, <filename>pyc</filename>, or
    <filename>pyo</filename>.</para>

   </section>

  </section> <!-- sec-testcmd-register -->

  <section id="sec-testcmd-run">
   <title><command>&qmtest-cmd; run</command></title>

   <section>
    <title>Summary</title>
    <para>Run tests or test suites.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; run</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
     <group choice="opt" rep="repeat">
      <arg choice="plain"><replaceable>test-name</replaceable></arg>
      <arg choice="plain"><replaceable>suite-name</replaceable></arg>
     </group>
    </cmdsynopsis>
   </section>

   <section>
    <title>Description</title>

    <para>The <command>&qmtest-cmd; run</command> command runs tests
    and displays the results.  If no test or suite names are
    specified, &qmtest; runs all of the tests in the test database.
    If test or suite names are specified, only those tests or suites
    are run.  Tests listed more than once (directly or by inclusion in
    a test suite) are run only once.</para>

    <para>The <command>run</command> command accepts these
    options:</para>

    <variablelist>
     <varlistentry id="opt-test-run-context">
      <term>
       <option>-c</option>
       <replaceable>name</replaceable>=<replaceable>value</replaceable>
      </term>
      <term>
       <option>&dashdash;context</option> 
       <replaceable>name</replaceable>=<replaceable>value</replaceable>
      </term>
      <listitem>
       <para>Add a property to the <link linkend="sec-the-context">test
       execution context</link>.  The name of the property is
       <replaceable>name</replaceable>, and its value is set to the string
       <replaceable>value</replaceable>.</para>

       <para>This option may be specified multiple times.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="opt-test-run-context-file">
      <term><option>-C</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;load-context</option> <replaceable>file</replaceable>
      </term>
      <listitem>
       <para>Read properties for the <link linkend="sec-the-context">test
       execution context</link> from the file
       <replaceable>file</replaceable>.</para>

       <para>The file should be a text file with one context property on
       each line, in the format <replaceable>name=value</replaceable>.
       Leading and trailing whitespace on each line are ignored.  Also,
       blank lines and lines that begin with "#" (a hash mark) are
       ignored as comments.</para>

       <para>This option may be specified more than once, and used in
       conjunction with the <option>&dashdash;context</option>
       option.  All of the context properties specified are added to
       the eventual context.  If a property is set more than once,
       the last value provided is the one used.</para>

       <para>If this option is not specified, but a file named
       <filename>context</filename> exists in the current directory,
       that file is read.  The properties specified in this file are
       processed first; the values in this file can be overridden by
       subsequent uses of the <option>&dashdash;context</option>
       option on the command line.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>format</replaceable></term>
      <term>
       <option>&dashdash;format</option> 
       <replaceable>format</replaceable>
      </term>
      <listitem>
       <para>Control the format used when displaying results.  The
       format specified must be one of <literal>full</literal>,
       <literal>brief</literal>, <literal>stats</literal>, or
       <literal>none</literal>.  The <literal>brief</literal> format
       is the default.  In the <literal>full</literal> format,
       &qmtest; displays any annotations provided in test results.  In
       the <literal>brief</literal> mode only the causes of failures
       are shown; detailed annotations are not shown.  In the
       <literal>stats</literal> format, no details about failing tests
       are displayed; only statistics showing the number of passing
       and failing tests are displayed.  In the
       <literal>none</literal> mode, no results are displayed, but a
       results file is still created, unless the
       <option>&dashdash;no-output</option> option is also provided.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>count</replaceable></term>
      <term>
       <option>&dashdash;concurrency</option> <replaceable>count</replaceable>
      </term>
      <listitem>
       <para>Run tests in multiple <replaceable>count</replaceable>
       concurrent processes on the local computer.  On multiprocessor
       machines, the processes may be scheduled to run in parallel on
       different processors.  &qmtest; automatically collects results
       from the processes and presents combines test results and summary.
       By default, one process is used.</para>

       <para>This option may not be combined with the <link
       linkend="opt-test-run-targets"><option>&dashdash;targets</option>
       (<option>-T</option>) option</link>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <option>&dashdash;no-output</option>
      </term>
      <listitem>
       <para>Do not produce a test results file.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-o</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;output</option> <replaceable>file</replaceable> 
      </term>
      <listitem>
       <para>Write full test results to <replaceable>file</replaceable>.
       Specify "<literal>-</literal>" (a hyphen) to write results to
       standard output.  If neither this option nor
       <option>&dashdash;no-output</option> is specified, the results
       are written to the file named <filename>results.qmr</filename>
       in the current directory.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-O</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;outcomes</option> <replaceable>file</replaceable>
      </term>
      <listitem>
       <para>Treat <replaceable>file</replaceable> as a set of
       expected outcomes.  The <replaceable>file</replaceable> must
       have be a results file created either by <command>&qmtest-cmd;
       run</command>, or by saving results in the graphical user interface.
       &qmtest; will expect the results of the current test run to
       match those specified in the <replaceable>file</replaceable>
       and will highlight differences from those results.</para>
      </listitem>
     </varlistentry> 

     <varlistentry>
      <term><option>&dashdash;random</option></term>
      <listitem>
       <para>Run the tests in a random order.</para>
    
       <para>This option can be used to find hidden dependencies
       between tests in the testsuite.  (You may not notice the
       dependencies if you always run the tests in the same order.)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>&dashdash;rerun</option> 
            <replaceable>file</replaceable></term>
      <listitem>
       <para>Rerun only those tests that had unexpected outcomes.</para>
  
       <para>The tests run are determined as follows.  QMTest starts
       with all of the tests specified on the command line, or, if no
       tests are explicitly specified, all of the tests in the
       database.  If no expectations file is specified (see the
       description of the <option>&dashdash;outcomes</option> option),
       then all tests that passed in the results file indicated by the
       <option>&dashdash;rerun</option> option are removed form the
       set of eligible tests.  If an expectations file is specified,
       then the tests removed are tests whose outcome in the results
       file indicated by the <option>&dashdash;rerun</option> option
       is the same as in the expectations file.</para>

       <para>The <option>&dashdash;rerun</option> provides a simple
       way of rerunning failing tests.  If you run your tests and
       notice failures, you might try to fix those failing tests.
       Then, you can rerun the failing tests to see if you succeeded
       by using the <option>&dashdash;rerun</option> option.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <option>&dashdash;result-stream <replaceable>descriptor</replaceable></option>
      </term>
      <listitem>
       <para>Specify an additional output result stream.  The
       descriptor is in the format described in <xref
       linkend="sec-testcmd-create"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;summary</option> <replaceable>file</replaceable> 
      </term>
      <listitem>
       <para>Write a summary of the test run to
       <replaceable>file</replaceable>.  Specify "<literal>-</literal>"
       (a hyphen) to write results to standard output (the
       default).</para>

       <para>&qmtest; prints a summary of test results, including
       statistics and the names of tests that did not pass.  If
       expected outcomes were specified, the the names of tests that
       had unexpected results are printed, instead of the names of
       tests that did not pass.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>&dashdash;no-summary</option></term>
      <listitem> 
       <para>Do not produce a summary of the test run.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <option>&dashdash;seed</option> <replaceable>integer</replaceable>
      </term>
      <listitem>
       <para>If the <option>&dashdash;random</option> is used, &qmtest;
       randomizes the order in which tests are run, subject to the
       constraints described in <xref
       linkend="sec-ordering-and-dependencies"/>.  By default, the
       random number generator is seeded using the system time.</para>

       <para>For debugging purposes, it is sometimes necessary to obtain
       a reproducible sequence of tests.  Use the
       <option>&dashdash;seed</option> option to specify the seed for the
       random number generator.</para>

       <para>Note that even with the same random number seed, if tests
       are run in parallel, scheduling uncertainty may still produce
       variation in the order in which tests are run.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="opt-test-run-targets">
      <term><option>-T</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;targets</option> <replaceable>file</replaceable>
      </term>
      <listitem>
       <para>Use targets specified in target specification file
       <replaceable>file</replaceable>.  If this option is not
       present, the <filename>QMTest/targets</filename> in the test
       database directory will be used.  If that file is not present,
       the tests will be run in serial on the local machine.</para>
      </listitem>
     </varlistentry>

    </variablelist>
   </section>
  </section> <!-- sec-testcmd-run -->

  <section id="sec-testcmd-summarize">
   <title><command>&qmtest-cmd; summarize</command></title>

   <section>
    <title>Summary</title>
    <para>The <command>&qmtest-cmd; summarize</command> displays
    information stored in a results file.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; summarize</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
     <group choice="opt" rep="repeat">
      <arg choice="plain"><replaceable>test-name</replaceable></arg>
      <arg choice="plain"><replaceable>suite-name</replaceable></arg>
     </group>
    </cmdsynopsis>
   </section>

   <section>
    <title>Description</title>
    <para>The <command>&qmtest-cmd; summarize</command> extracts
    information stored in a results file and displays this information
    on the console.  The information is formatted just as if the tests
    had just been run, but &qmtest; does not actually run the
    tests.</para>

    <para>The <command>summarize</command> command accepts the
    following options:</para>

    <variablelist>
     <varlistentry>
      <term><option>-f</option> <replaceable>format</replaceable></term>
      <term>
       <option>&dashdash;format</option> 
       <replaceable>format</replaceable>
      </term>
      <listitem>
       <para>For details about this option, see the description of the 
       <command>qmtest run</command> command.</para>
      </listitem>
     </varlistentry>
  
     <varlistentry>
      <term><option>-O</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;option</option> <replaceable>file</replaceable>
      </term>
      <listitem>
       <para>For details about this option, see the description of the 
       <command>qmtest run</command> command.</para>
      </listitem>
     </varlistentry> 

     <varlistentry>
      <term>
       <option>&dashdash;result-stream <replaceable>descriptor</replaceable></option>
      </term>
      <listitem>
       <para>Specify an additional output result stream.  The
       descriptor is in the format described in <xref
       linkend="sec-testcmd-create"/>.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>
  </section> <!-- sec-testcmd-summarize -->

  <section id="sec-env-vars">
  <title>Environment Variables</title>

  <para>&qmtest; recognizes the following environment variables:</para>

  <variablelist>
   <varlistentry>
    <term>
     <envar>QM_PYTHON</envar>
    </term>
    <listitem>
     <para>If this environment variable is set, &qmtest; uses it as as
     the path to the Python interpreter.  If this environment variable
     is not set, &qmtest; looks for a file named
     <filename>python</filename> in the <filename>bin</filename>
     directory where QM is installed.  If this file does not exist,
     but <filename>/usr/bin/python2</filename> exists, &qmtest;
     will use that path.  Otherwise, &qmtest; searches for
     <filename>python</filename> in the directories listed in the
     <envar>PATH</envar> environment variable.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <envar>QMTEST_CLASS_PATH</envar>
    </term>
    <listitem>
     <para>If this environment variable is set, it should contain a
     list of directories in the same format as used for the system's
     <envar>PATH</envar> environment variable.  These directories
     are searched (before the directories that &qmtest; searches by
     default) when looking for extension classes such as test classes
     and database classes.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <envar>QMTEST_DB_PATH</envar>
    </term>
    <listitem>
     <para>If this environment variable is set, its value is used as
     the location of the test database, unless the
     <option>&dashdash;tdb</option> (<option>-D</option>) option is
     used.  If this environment variable is not set and the
     <option>&dashdash;tdb</option> option is not used, the current
     directory is used as the test database.</para>
    </listitem>
   </varlistentry>
  </variablelist>
    
  </section> <!-- sec-env-vars -->

  <section id="sec-config-file">
   <title>Configuration Variables</title>

    <para>These configuration variables are used by QMTest.  You
    should define them in the <literal>[qmtest]</literal> section of
    your &qm; configuration file.</para>

    <glosslist>
     <glossentry>
      <glossterm>
       <property>pid-file</property>
      </glossterm>
      <glossdef>
       <para>The default path to use when creating a PID file with the
       <option>&dashdash;pid-file</option>.  If this entry is not
       present, an appropriate platform-specific default value is 
       used.</para>
      </glossdef>
     </glossentry>
    </glosslist>

  </section> <!-- sec-config-file -->
  
 </section>

 <section id="sec-ref-classes">
  <title>Test and Resource Classes</title>

  <para>This section describes test classes and resource classes
  included with &qmtest;.  <xref linkend="sec-writing-test-classes"/>
  provides instructions for writing your own test classes, <xref
  linkend="sec-writing-resource-classes"/> for resource classes.</para>

  <section id="sec-ref-test-classes">
   <title>Test Classes</title>

   <section id="sec-exectest">
    <title><classname>command.ExecTest</classname></title>

    <para>The <classname>command.ExecTest</classname> test class runs a
    program from an ordinary executable file.  Each test specifies the
    program executable to run, its full command line, and the data to
    feed to its standard input stream.  <classname>ExecTest</classname>
    collects the complete text of the program's standard output and
    standard error streams and the program's exit code, and compares
    these to expected values specified in the test.  If the standard
    output and error text and the exit code match the expected values,
    the test passes.</para>

    <para>A <classname>command.ExecTest</classname> test supplies the
    following arguments:</para>

    <glosslist>
     <glossentry>
      <glossterm><property>Program</property> (text field)</glossterm>
      <glossdef>
       <para>The name of the executable file to run.
       <classname>command.ExecTest</classname> attempts to locate the
       program executable in the path specified by the
       <property>path</property> property of the test context.</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Argument List</property> (set of strings)</glossterm>
      <glossdef>
       <para>The argument list for the program.  The elements of this
       set are sequential items from which the program's argument list
       is constructed.  <classname>command.ExecTest</classname>
       automatically prepends an implicit zeroth element, the full path
       of the program.</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Standard Input</property> (text
      field)</glossterm>
      <glossdef>
       <para>Text or data to pass to the program's standard input
       stream.  This data is written to a temporary file, and the
       contents of the file are directed to the program's standard
       input stream.</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Environment</property> (set of strings)</glossterm>
      <glossdef>
       <para>The environment (i.e. the set of environment variables)
       available to the executing program.  Each element of this
       argument is a string of the form
       "<replaceable>VARIABLE</replaceable>=<replaceable>VALUE</replaceable>".</para>

       <para><classname>command.ExecTest</classname> adds additional
       environment variables automatically.</para>

       <para>In addition, every context property whose key does not
       contain a &quot;.&quot; and whose value is a string is
       accessible as an environment variable; the name of the
       environment variable is the name of the context property,
       prefixed with &quot;<envar>QMV_</envar>&quot;.</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Expected Exit Code</property> (integer
      field)</glossterm>
      <glossdef>
       <para>The exit code value expected from the program.  If the
       program produces an exit code value different from this one, the
       test fails.</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Expected Standard Output</property>
      (text field)</glossterm>
      <glossdef>
       <para>The text or data which the program is expected to produce
       on its standard output stream.  The actual text or data written
       to standard output is captured, and
       <classname>command.ExecTest</classname> performs a bytewise
       comparison to the expected text or data.  If they do not match,
       the test fails.</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Expected Standard Error</property>
      (text field)</glossterm>
      <glossdef>
       <para>The text or data which the program is expected to produce
       on its standard error stream.  The actual text or data written to
       standard error is captured, and
       <classname>command.ExecTest</classname> performs a bytewise
       comparison to the expected text or data.  If they do not match,
       the test fails.</para>
      </glossdef>
     </glossentry>

    </glosslist>

   </section> <!-- sec-exectest -->

   <section id="sec-commandtest">
    <title><classname>command.ShellCommandTest</classname></title>

    <para><classname>command.ShellCommandTest</classname> is very
    similar to <classname>command.ExecTest</classname>, except that it
    runs a program via the shell rather than directly.  Instead of
    specifying an executable to run and the elements of its argument
    list, a test provides a single command line.  The shell is
    responsible for finding the executable and constructing its
    argument list.</para>

    <para>Standard input and the environment are specified in the test.
    The test passes if the command produces the expected standard
    output, standard error, and exit code.</para>

    <para>Note that most shells create local shell variables to mirror
    the contents of the environment when the shell starts up.
    Therefore, the environment set up by a
    <classname>command.ShellCommandTest</classname>, including the contents
    of the test context, are directly accessible via shell variables.
    The syntax to use depends on the particular shell.</para>

    <para><classname>command.ShellCommandTest</classname> has the same fields
    as <classname>command.ExecTest</classname>, except that the
    <property>Program</property> and <property>Argument List</property>
    properties are replaced with these:</para>

    <glosslist>
     <glossentry>
      <glossterm><property>Command</property> (text field)</glossterm>
      <glossdef>
       <para>The command to run.  The command is delivered verbatim to
       the shell.  The shell interprets the command according to its own
       quoting rules and syntax.</para>
      </glossdef>
     </glossentry>
    </glosslist>

   </section> <!-- sec-commandtest -->

   <section id="sec-scripttest">
    <title><classname>command.ShellScriptTest</classname></title>

    <para><classname>command.ShellScriptTest</classname> is an extension of
    <classname>command.CommandTest</classname> that lets a test specify
    an entire shell script instead of a single command.  The script
    specified in the test is written to a temporary file, and this file
    is interpreted by the specified shell or command interpreter
    program.</para>

    <para>Standard input, the environment, and the argument list to pass
    to the script are specified in the test.  The test passes if the
    script produces the expected standard output, standard error, and
    exit code.</para>

    <para>Note that most shells create local shell variables to mirror
    the contents of the environment when the shell starts up.
    Therefore, the environment set up by a
    <classname>command.ShellScriptTest</classname>, including the contents of
    the test context, are directly accessible via shell variables.  The
    syntax to use depends on the particular shell.</para>

    <para><classname>command.ShellScriptTest</classname> has the same fields
    as <classname>command.ExecTest</classname>, except that the
    <property>Program</property> property is replaced with:</para>

    <glosslist>
     <glossentry>
      <glossterm><property>Script</property> (text field)</glossterm>
      <glossdef>
       <para>The text of the script to run.</para>
      </glossdef>
     </glossentry>
    </glosslist>

   </section> <!-- sec-scripttest -->

  </section> <!-- sec-ref-test-classes -->

 </section> <!-- sec-ref-classes -->

 <section id="sec-ref-targets">
  <title>Test Targets</title>

  <para>Test targets represent entities that &qmtest; uses to run
  tests.  See <xref linkend="sec-targets"/> for an overview of how
  &qmtest; uses targets.</para>

  <section id="sec-target-specification">
   <title>Target Specification</title>

   <para>Each target specification includes the following:</para>

   <orderedlist>
    <listitem>
     <para>The name of the target.  This is a name identifying the
     target, such as the host name of the computer which will run the
     tests.  Target names should be unique in a single target
     file.</para>
    </listitem>

    <listitem>
     <para>The <firstterm id="def-target-class">target
     class</firstterm>.  Similar to a test class, a target class is a
     Python class which implements a type of target.  As with test
     classes, a target class is identified by its name, which includes
     the module name and the class name.</para>

     <para>For example,
     <classname>thread_target.ThreadTarget</classname> is the name of
     a target class, provided by &qmtest;, which runs tests in
     multiple threads on the local computer.</para>

     <para>&qmtest; includes several target class implementations.  See
     <xref linkend="sec-target-classes"/> for details.</para>
    </listitem>

    <listitem>
     <para>A <link linkend="def-target-group">target group</link> name.
     The test implementor may choose the syntax of target group names in
     a test implementation.  Target groups may be used to encode
     information about target attributes, such as architecture and
     operating system, and capabilities.</para>
    </listitem>

    <listitem>
     <para>Optionally, a target specification may include additional
     properties.  Properties are named and have string values.  Some
     target classes may use property information to control their
     configuration.  For instance, a target class which executes tests
     on a remote computer would extract the network address of the
     remote computer from a target property.</para>
    </listitem>
   </orderedlist>

  </section> <!-- sec-target-specifation -->

  <section id="sec-target-classes">
   <title>Target Classes</title>

   <para>&qmtest; includes these target class implementations.</para>

   <section id="sec-serial-target">
    <title><classname>SerialTarget</classname></title>

    <para>The <classname>serial_target.SerialTarget</classname> target
    class runs tests one after the other on the machine running
    QMTest.  If you use a <classname>SerialTarget</classname>, you
    should not also use any other targets, including another
    <classname>SerialTarget</classname> at the same time.</para>
   </section> <!-- sec-serial-target -->

   <section id="sec-thread-target">
    <title><classname>ThreadTarget</classname></title>

    <para>The <classname>thread_target.ThreadTarget</classname> target
    class runs tests in one or more threads on the machine running
    QMTest.  The <classname>ThreadTarget</classname> can be used to
    run multiple tests at once.</para>

    <para><classname>ThreadTarget</classname> uses the following
    properties:</para>

    <itemizedlist>
     <listitem>
      <para>The <property>concurrency</property> specifies the number
      of threads to use.  Larger numbers of threads will allow QMTest
      to run more tests in parallel.  You can experiment with this
      value to find the setting that allows QMTest to run tests most
      quickly.</para>
     </listitem>
    </itemizedlist>

   </section> <!-- sec-thread-target -->

   <section id="process-target">
    <title><classname>ProcessTarget</classname></title>

    <para>The <classname>process_target.ProcessTarget</classname>
    target class run tests in one more processes on the machine running
    QMTest.  This target class is not available on Windows.  Like
    <classname>ThreadTarget</classname>,
    <classname>ProcessTarget</classname> can be used to run multiple
    tests simultaneously.</para>

    <para>In general, you should use
    <classname>ThreadTarget</classname> instead of
    <classname>ProcessTarget</classname> to maximize QMTest
    performance.  However, on machines that do not have threads,
    <classname>ProcessTarget</classname> provides an alternative way
    of running tests in parallel.</para>

    <para><classname>ProcessTarget</classname> uses the following
    properties:</para>

    <itemizedlist>
     <listitem>
      <para>The <property>concurrency</property> specifies the number
      of processes to use.  Larger numbers of processes will allow
      QMTest to run more tests in parallel.  You can experiment with
      this value to find the setting that allows QMTest to run tests
      most quickly.</para>
     </listitem>

     <listitem>
      <para>&qmtest; uses the path given by the
      <command>qmtest</command> property to create additional QMTest
      instances.  By default, the path
      <filename>/usr/local/bin/qmtest</filename> is used.</para>
     </listitem>
    </itemizedlist>

   </section> <!-- sec-process-target -->

   <section id="sec-remote-shell-target">
    <title><classname>RemoteShellTarget</classname></title>

    <para>The <classname>rsh_target.RSHTarget</classname>
    target class runs tests on a remote computer via a remote shell
    invocation (<command>rsh</command>, <command>ssh</command>, or
    similar).  This target uses a remote shell to invoke a program
    similar to the &qmtest-cmd; command on the remote computer.  This
    remote program accepts test commands and responds with results from
    running these tests.</para>

    <para>To use <classname>RSHTarget</classname>, the remote
    computer must have &qmtest; installed and must contain an identical
    copy of the test database.  &qmtest; does not transfer entire tests
    over the remote shell connection; instead, it relies on the remote
    test database for loading tests.</para>

    <para>In addition, the remote shell program must be configured to
    allow a remote login without additional intervention (such as typing
    a password).  If you use <command>rsh</command>, you can use an
    <filename>.rhosts</filename> file to set this up.  If you use
    <command>ssh</command>, you can use an SSH public key and the
    <command>ssh-agent</command> program for this.  See the
    corresponding manual pages for details.</para>

    <para><classname>RSHTarget</classname> uses all of the properties
    given above for <classname>ProcessTarget</classname>.  In
    addition, <classname>RSHTarget</classname> uses the following
    properties:</para>

    <itemizedlist>
     <listitem>
      <para>The <property>remote_shell</property> property specifies the
      path to the remote shell program.  The default value is
      <command>ssh</command>.  The remote shell program must
      accept the same command-line syntax as
      <command>rsh</command>.</para>
     </listitem>

     <listitem>
      <para>The <property>host</property> property specifies the remote
      host name.  If omitted, the target name is used.</para>
     </listitem>

     <listitem>
      <para>The <property>database_path</property> property specifies
      the path to the test database on the remote computer.  The test
      database must be identical to the local test database.  If
      omitted, the local test database path is used.</para>
     </listitem>

     <listitem>
      <para>The <property>arguments</property> property specifies
      additional command-line arguments for the remote shell program.
      The value of this property is split at space characters, and the
      arguments are added to the command line before the name of the
      remote host.</para>

      <para>For example, if you are using the <command>ssh</command>
      remote shell program and wish to log in to the remote computer
      using a different user account, specify the <literal>-l
      username</literal> option using the <property>arguments</property>
      property.</para>
     </listitem>
    </itemizedlist>

   </section> <!-- sec-remote-shell-target -->

  </section> <!-- sec-target-classes -->

 </section> <!-- sec-ref-targets -->

</chapter> <!-- chap-test-manual -->

<chapter id="chap-test-extension">
 <title>Extending QMTest</title>

 <para>If the built-in functionality provided with QMTest does not
 serve all of your needs, you can extend QMTest.  All extensions to
 QMTest take the form of Python classes.  You can write new test
 classes, resource classes, or database classes in this way.</para>

 <para>The contents of the class differ depending on the kind of
 extension you are creating.  For example, the methods that a new test
 class must implement are different from those that must be provided
 by a new database class.  In each case, however, you must create the
 class and place it in a location where QMTest can find it.  The
 following sections explain how to create extension classes.  The last
 section in this chapter explains how to register your new extension
 classes.</para>

 <section id="sec-writing-test-and-resource-classes">
  <title>Writing Test and Resource Classes</title>

  <para>You can implement many tests using the test classes supplied
  with &qmtest;.  However, expert test implementors may wish to create
  new test classes to customize existing tests or implement new
  testing behavior.  In addition, implementors will wish to create
  resource classes to add customized setup and cleanup behavior to
  tests and groups of tests.</para>
  
  <section id="sec-writing-test-classes">
   <title>Writing Test Classes</title>

   <para>In &qmtest;, a test class is represented by a Python class.
   The class must inherit from
   <classname>qm.test.test.Test</classname>.  The class must include
   two things: an <varname>arguments</varname>
   attribute, whose value is a sequence of field objects, and a 
   <function>Run</function> function.</para>

   <section>
    <title>The <varname>arguments</varname> Attribute</title>

    <para>The test class must include an <varname>arguments</varname>
    attribute, indicating the types of the test class's parameters.  The
    <varname>arguments</varname> attributes value should be a sequence
    consisting of field objects.  A field object is an instance of a
    subclass of <classname>qm.fields.Field</classname>.  The names of
    the arguments (specified by the "name" attribute of the field object)
    are the names of the parameters of the test class.</para>

    <para>For instance, this definition of the <varname>arguments</varname>
    attribute declares two parameters for the test class.  One
    parameter, called &quot;input_text&quot;, takes a text value.  The
    other parameter, called &quot;value_list&quot;, takes a
    set of integers.</para>

    <programlisting>
<![CDATA[    arguments = [
        qm.fields.IssueFieldText(
            name="input_text"),
        qm.fields.IssueFieldSet(qm.fields.IssueFieldInteger(
            name="value_list")),
        ] 
]]>
    </programlisting>

    <para>Test classes should also initialize the
    <varname>title</varname> and <varname>description</varname>
    attributes of each field.  The values of these attributes help users
    of the test class identify the purpose and semantics of each of the
    test class's parameters.</para>

    <para>None of the arguments may have the same name as a class
    variable in the test class, including class variables in base
    classes.</para>

   </section> <!-- The arguments Attribute -->

   <section id="sec-run-function">
    <title>The <function>Run</function> Function</title>

    <para>The heart of the test class is the <function>Run</function>
    function.  This function runs the test and produces a test
    result.</para>

    <para>The <function>Run</function> function takes two arguments:
    the context and the result.  The context object satisfies the
    interface of the <classname>qm.test.context.Context</classname>
    Python class (though it may in actuality be an instance of a
    different Python class).</para>

    <para>The result object is an instance of
    <classname>qm.test.result.Result</classname>.  By default, the
    result will indicate that the test passes.  If the test fails, the
    test class should call the <function>Fail</function> method on the
    result to indicate failure.</para>

    <para>If the <function>Run</function> raises an unhandled exception,
    &qmtest; creates a result for the test with the outcome &ERROR;.
    Test classes should be designed so that they do not raise unhandled
    exceptions in the course of normal use (including test failures).
    An unhandled exception should reflect an internal error in the
    implementation of the test class.</para>

   </section> <!-- The Run Function -->

   <section>
    <title>Using the Context</title>

    <para>A context object is simply a dictionary of properties.  Use
    Python's map syntax to access a context's properties.  A property
    key is always a string composed of letters, digits, hyphens,
    underscores, and periods.  Property values are strings.</para>

    <para>A test's <function>Run</function> function only sees context
    properties added by &qmtest; itself and properties added by the
    setup functions of required resources.</para>

   </section> <!-- Using the Context -->

   <section id="sec-creating-results">
    <title>Creating Results</title>

    <para>In case of a &FAIL; result, it is conventional to assign the
    <literal>Result.CAUSE</literal> property a string value providing
    a description of why the test failed.  These two equivalent examples demonstrate how to indicates
    test failure (both assume that the
    <classname>qm.test.result.Result</classname> class has been
    imported into the module's global namespace).</para>

    <programlisting>
<![CDATA[        result.Fail()
        result[Result.CAUSE] = "Unexpected end of input."]]>
    </programlisting>

    <para>or</para>

    <programlisting>
<![CDATA[        result.Fail("Unexpected end of input.")]]>
    </programlisting>

    <para>Sometimes, a <function>Run</function> function implementation
    detects a failure by catching an exception.  The method
    <function>Result.NoteException</function> provides
    a convenient mechanism for creating a result that includes
    information about the exception.  For
    example: 

    <programlisting>
<![CDATA[        try:
            # ... run test code here ...
        except EndOfFileError:
            result.NoteException()
]]>
    </programlisting>

    The <function>NoteException</function> method will automatically
   add annotations describing the cause of the exception.</para>
   </section> <!-- Creating Results -->

  </section> <!-- Writing Test Classes -->

  <section id="sec-writing-resource-classes">
   <title>Writing Resource Classes</title>

   <para>Writing resource classes is similar to writing test classes.
   The requirements are the same except that, instead of a <link
   linkend="sec-run-function"><function>Run</function></link>
   function, you must provide two functions named
   <function>SetUp</function> and <function>CleanUp</function> to
   perform resource setup and cleanup.  The <function>SetUp</function>
   function must have the same signature as a test classs
   <function>Run</function>.  The <function>CleanUp</function>
   function is similar, but does not take a
   <parameter>context</parameter> parameter.</para>

   <para>The setup function may add additional properties to the
   context.  These properties will be visible only to tests that
   require this resource.  To insert a context property, use Python's
   map assignment syntax.</para>

   <para>Below is an example of setup and cleanup functions for a
   resource which calls <function>create_my_resource</function> and
   <function>destroy_my_resource</function> to do the work of creating
   and destroying the resource.  The resource is identified by a
   string handle, which is inserted into the context under the name
   <literal>Resource.handle</literal>, where it may be accessed by
   tests.  Context property names should always have the form
   <literal>Class.name</literal> so that there is no risk of collision
   between properties created by different resource classes.</para>

   <programlisting>
    def SetUp(self, context, result):
        try:
            handle = create_my_resource()
            self.__handle = handle
        except:
            result.NoteException()
        else:
            context["resource_handle"] = str(handle)

    def CleanUp(self, result):
        try:
            destroy_my_resource(self.__handle)
        except:
            result.NoteException()
   </programlisting>

  </section> <!-- sec-writing-resource-classes -->

 </section> <!-- sec-writing-test-and-resource-classes -->

 <section id="sec-ref-writing-database-classes">
  <title>Writing a Database Class</title>

  <para>The database class controls the format in which tests are
  stored.  &qmtest's default database class stores each test as an XML
  file, but you might want to use a format that is particularly well
  suited to your application domain or to your organization's
  arrangement of computing resources.</para>

  <para>For example, if you were testing a compiler, you might want to
  represent tests as source files with special embedded comments
  indicating what errors are expected when compiling the test.  You
  could write a test database class that can read and write tests
  in that format.</para>

  <para>Or, if you wanted to share a single test database with many
  people in such a way that everyone automatically saw updates to the
  database, you might want to put all of the tests on a central HTTP
  server.  You could write a test database class that retrieves tests
  from the server and creates new tests by uploading them to the
  server.</para>

  <para>A test database class is a Python class that is derived from
  <classname>qm.test.database.Database</classname>.  You must define
  methods that handle retrieving a test from the database, writing a
  test to the database, and other related tasks.  Read the code for
  <classname>qm.test.database.Database</classname> to see what methods
  need to be overridden.
  </para>
  
  <para>To use your new database class, create a new test database using
  the <link
  linkend="sec-testcmd-create-tdb"><option>&dashdash;class</option>
  (<option>-c</option>) option</link>.</para>

 </section> <!-- sec-ref-writing-database-classes -->

  <section id="sec-registering-extension-class">
   <title>Registering an Extension Class</title>

   <para>To use your test or resource class, you must place the Python
   module file containing it in a directory where &qmtest; can find
   it.  &qmtest; looks in three places when loading
   extension classes:</para>

   <itemizedlist>
    <listitem>
     <para>If the environment variable <envar>QMTEST_CLASS_PATH</envar>
     is defined, &qmtest first checks any directories listed in it.
     This value of this environment variable should be a list of
     directories to check for the module file, in the same format as
     the standard <envar>PATH</envar> environment variable.</para>
    </listitem>

    <listitem>
     <para>A test database may specify additional locations to check.</para>
    </listitem>

    <listitem>
     <para>QMTest checks the configuration directory (the subdirectory
     named <filename>QMTest</filename> of a test database).</para>
    </listitem>

    <listitem>
     <para>Finally, &qmtest; checks a standard directory.  This
     directory, installed with &qmtest;, contains modules with the
     standard test classes described in <xref
     linkend="sec-ref-classes"/>.</para>
    </listitem>
   </itemizedlist>

   <para>You should generally place module files containing your test
   classes in the test database's <filename>QMTest</filename>
   directory, unless you plan to use the test classes in more than one
   test database.</para>

   <para>You must use the <command>&qmtest-cmd; register</command>
   command to register your new extension class.  You must perform
   this step no matter where you place the module containing your
   extension class.</para>

   <para>You can refer to the new extension class using the syntax
   <classname>module.Class</classname>, where
   <classname>module</classname> is the name of the module and
   <classname>Class</classname> is the name of the class.</para>

  </section> <!-- sec-registering-extension-class -->

</chapter> <!-- chap-test-extension -->

<!--
  Local Variables:
  mode: sgml
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("manual.xml" "book" "chapter")
  End:
-->
