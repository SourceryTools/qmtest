########################################################################
#
# File:   show.py
# Author: Alex Samuel
# Date:   2001-04-09
#
# Contents:
#   Web forms to display and edit a test.
#
# Copyright (c) 2001 by CodeSourcery, LLC.  All rights reserved. 
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
########################################################################

"""Web forms for creating, displaying, and editing tests and actions.

Many functions in this file work for both tests and actions, referred to
generally as "items".  Where we need to distinguish between them, we use
a type string that is either "test" or "action".

Creating a new test or action is a two-step process.  For a test, the
user is first presented with a form for selecting the test class and
entering the new test's ID; this is generated by 'handle_new_test' in
response to the 'new-test' request.  Once these have been specified, the
user is presented with the usual test editing form, generated by
'handle_show' in response to the 'create-test' request.  The test is not
created until the user submits the second form.  The procedure for new
actions is analogous."""

########################################################################
# imports
########################################################################

import qm.label
import qm.structured_text
import qm.test.base
import qm.web
import string
import sys
import web

########################################################################
# classes
########################################################################

class ShowPageInfo(web.PageInfo):
    """DTML context for generating DTML template show.dtml.

    See 'handle_show' for more information."""

    def __init__(self, request, item, edit, new, type, field_errors={}):
        """Construct a new DTML context.
        
        These parameters are also available in DTML under the same name:

        'item' -- The 'Test' or 'Action' instance.

        'edit' -- True for editing the item; false for displaying it
        only.

        'new' -- True for editing a newly-created item ('edit' is then
        also true).

        'type' -- Either "test" or "action".

        'field_errors' -- A map from field names to corresponding error
        messages.  The values "_prerequisites", "_actions", and
        "_categories" may also be used as keys."""

        # Initialize the base class.
        web.PageInfo.__init__(self, request)
        # Set up attributes.
        self.item = item
        self.fields = item.GetClass().fields
        self.edit = edit
        self.new = new
        assert type in ["test", "action"]
        self.type = type
        self.field_errors = field_errors

        # Some extra attributes that don't apply to actions.
        if self.type is "test":
            self.prerequisites = item.GetPrerequisites()
            self.actions = item.GetActions()
            self.categories = item.GetCategories()


    def GetTitle(self):
        """Return the page title for this page."""

        # Map the scriptname to a nicely-formatted title.
        url = self.request.GetScriptName()
        title = {
            "show-test":       "Show Test",
            "edit-test":       "Edit Test",
            "create-test":     "New Test",
            "show-action":     "Show Action",
            "edit-action":     "Edit Action",
            "create-action":   "New Action",
            }[url]
        # Show the item's ID too.
        title = title + " " + self.item.GetId()
        return title


    def IsShowField(self, field):
        """Return true if 'field' should be shown."""

        return 1


    def FormatFieldValue(self, field):
        """Return an HTML rendering of the value for 'field'."""

        # Extract the field value.
        arguments = self.item.GetArguments()
        field_name = field.GetName()
        try:
            value = arguments[field_name]
        except KeyError:
            # Use the default value if none is provided.
            value = field.GetDefaultValue()
        # Format it appropriately.
        if self.edit:
            style = "edit"
        else:
            style = "full"
        return field.FormatValueAsHtml(value, style)


    def GetClassDescription(self):
        """Return a full description of the test or action class.

        returns -- The description, formatted as HTML."""

        # Extract the class's doc string.
        doc_string = self.item.GetClass().__doc__
        if doc_string is not None:
            return self.FormatStructuredText(doc_string)
        else:
            return "&nbsp;"


    def MakeShowUrl(self):
        """Return the URL for showing this item."""

        request = qm.web.WebRequest("show-" + self.type,
                                    base=self.request,
                                    id=self.item.GetId())
        return qm.web.make_url_for_request(request)


    def MakeSubmitUrl(self):
        """Return the URL for submitting edits."""

        request = self.request.copy("submit-" + self.type)
        return qm.web.make_url_for_request(request)


    def MakePrerequisitesControl(self):
        """Make controls for editing test prerequisites."""

        # The "add-prerequisite" script shows the page for specifying a
        # new test prerequisite.  See 'handle_add_prerequisite'.
        test_path = qm.label.dirname(self.item.GetId())
        add_request = qm.web.WebRequest("add-prerequisite",
                                        base=self.request,
                                        path=test_path)
        # Encode the current prerequisites.  The first element of each
        # option is user-visible; the second is the option value which
        # we can parse back later.
        options = []
        for test_id, outcome in self.prerequisites.items():
            options.append(("%s (%s)" % (test_id, outcome),
                            "%s;%s" % (test_id, outcome)))
        # Generate the controls.
        return qm.web.make_set_control(form_name="form",
                                       field_name="prerequisites",
                                       add_request=add_request,
                                       initial_elements=options,
                                       rows=4,
                                       window_height=480)


    def MakeActionsControl(self):
        """Make controls for editing the actions associated with a test."""

        # The 'add-action' script shows the page for specifying a new
        # action.  See 'handle_add_action'.
        test_path = qm.label.dirname(self.item.GetId())
        add_request = qm.web.WebRequest("add-action",
                                        base=self.request,
                                        path=test_path)
        # Encode the current action values.
        options = map(lambda ac: (ac, ac), self.actions)
        # Generate the controls.
        return qm.web.make_set_control(form_name="form",
                                       field_name="actions",
                                       add_request=add_request,
                                       initial_elements=options,
                                       rows=4,
                                       window_height=360)


    def MakeCategoriesControl(self):
        """Make controls for editing a test's categories."""

        # The 'add-category' script shows the page for specifying a new
        # category.  See 'handle_add_category'.
        test_path = qm.label.dirname(self.item.GetId())
        add_request = qm.web.WebRequest("add-category",
                                        base=self.request)
        # Encode the current categories.
        options = map(lambda cat: (cat, cat), self.categories)
        # Generate the controls.
        return qm.web.make_set_control(form_name="form",
                                       field_name="categories",
                                       add_request=add_request,
                                       initial_elements=options,
                                       rows=4,
                                       window_height=240)



class AddPrerequisitePageInfo(qm.web.PageInfo):
    """DTML context for generating DTML template add-prerequisite.dtml."""

    outcomes = qm.test.base.Result.outcomes
    """The list of possible test outcomes."""

    def __init__(self, request):
        # Initialize the base class.
        qm.web.PageInfo.__init__(self, request)
        # Extract a list of all test IDs in the specified path. 
        db = qm.test.base.get_database()
        test_path = request["path"]
        test_ids = db.GetTestIds(test_path)
        test_ids.sort()
        # Store it for the DTML code.
        self.test_ids = test_ids



class AddActionPageInfo(qm.web.PageInfo):
    """DTML context for generating DTML template add-action.dtml."""

    def __init__(self, request):
        # Initialize the base class.
        qm.web.PageInfo.__init__(self, request)
        # Extract a list of all action IDs in the specified path.
        db = qm.test.base.get_database()
        action_path = request["path"]
        action_ids = db.GetActionIds(action_path)
        action_ids.sort()
        # Store it for the DTML code.
        self.action_ids = action_ids
        


class NewItemPageInfo(web.PageInfo):
    """DTML context for generating DTML template new.dtml."""

    def __init__(self,
                 request,
                 type,
                 item_id="",
                 class_name="",
                 field_errors={}):
        """Create a new DTML context.

        'type' -- Either "test" or "action".

        'item_id' -- The item ID to show.

        'class_name' -- The class name to show.

        'field_errors' -- A mapping of error messages for fields.  Keys
        may be "_id" or "_class"."""

        # Initialize the base class.
        web.PageInfo.__init__(self, request)
        # Set up attributes.
        assert type in ["test", "action"]
        self.type = type
        self.item_id = item_id
        self.class_name = class_name
        if type == "test":
            self.class_names = qm.test.base.standard_test_class_names
        elif type == "action":
            self.class_names = qm.test.base.standard_action_class_names
        self.field_errors = field_errors


    def GetTitle(self):
        """Return the title this page."""

        return "Create a New %s" % string.capwords(self.type)


    def MakeSubmitUrl(self):
        """Return the URL for submitting the form.

        The URL is for the script 'create-test' or 'create-action' as
        appropriate."""

        request = qm.web.WebRequest("create-" + self.type,
                                    base=self.request)
        return qm.web.make_url_for_request(request)



########################################################################
# functions
########################################################################

def handle_show(request):
    """Generate the show test page.

    'request' -- A 'WebRequest' object.

    This function generates pages to handle these requests:

      'create-test' -- Generate a form for initial editing of a test
      about to be created, given its test ID and test class.

      'create-action' -- Likewise for an action.

      'show-test' -- Display a test.

      'show-action' -- Likewise for an action.

      'edit-test' -- Generate a form for editing an existing test.

      'edit-action' -- Likewise for an action.

    This functiondistinguishes among these cases by checking the script
    name of the request object.

    The request must have the following fields:

      'id' -- A test or action ID.  For show or edit pages, the ID of an
      existing item.  For create pages, the ID of the item being
      created.

      'class' -- For create pages, the name of the test or action
      class.

    """

    # Paramaterize this function based on the request's script name.
    url = request.GetScriptName()
    edit, create, type = {
        "show-test":       (0, 0, "test"),
        "edit-test":       (1, 0, "test"),
        "create-test":     (1, 1, "test"),
        "show-action":     (0, 0, "action"),
        "edit-action":     (1, 0, "action"),
        "create-action":   (1, 1, "action"),
        }[url]

    database = qm.test.base.get_database()

    try:
        # Determine the ID of the item.
        item_id = request["id"]
    except KeyError:
        # The user probably submitted the form without entering an ID.
        message = qm.error("no id for show")
        return qm.web.generate_error_page(request, message)

    if create:
        # We're in the middle of creating a new item.  
        class_name = request["class"]

        # First perform some validation.
        field_errors = {}
        # Check that the ID is valid.
        try:
            qm.test.base.validate_id(item_id)
        except RuntimeError, diagnostic:
            field_errors["_id"] = diagnostic
        else:
            # Check that the ID doesn't already exist.
            if type is "action":
                if database.HasAction(item_id):
                    field_errors["_id"] = qm.error("action already exists",
                                                   action_id=item_id)
            elif type is "test":
                if database.HasTest(item_id):
                    field_errors["_id"] = qm.error("test already exists",
                                                   test_id=item_id)
        # Check that the class exists.
        try:
            qm.test.base.get_class(class_name)
        except ValueError:
            # The class name was incorrectly specified.
            field_errors["_class"] = qm.error("invalid class name",
                                              class_name=class_name)
        except ImportError:
            # Can't find the class.
            field_errors["_class"] = qm.error("class not found",
                                              class_name=class_name)
        # Were there any errors?
        if len(field_errors) > 0:
            # Yes.  Instead of showing the edit page, re-show the new
            # item page.
            page_info = NewItemPageInfo(request,
                                        type=type,
                                        item_id=item_id,
                                        class_name=class_name,
                                        field_errors=field_errors)
            return web.generate_html_from_dtml("new.dtml", page_info)
            
        # Construct an test with default argument values, as the
        # starting point for editing.
        if type is "action":
            item = qm.test.base.make_new_action(class_name, item_id)
        elif type is "test":
            item = qm.test.base.make_new_test(class_name, item_id)
    else:
        # We're showing or editing an existing item.
        # Look it up in the database.
        if type is "action":
            try:
                item = database.GetAction(item_id)
            except qm.test.base.NoSuchTestError:
                # An test with the specified test ID was not fount.
                # Show a page indicating the error.
                message = qm.error("no such test", test_id=item_id)
                return qm.web.generate_error_page(request, message)
        elif type is "test":
            try:
                item = database.GetTest(item_id)
            except qm.test.base.NoSuchActionError:
                # An test with the specified action ID was not fount.
                # Show a page indicating the error.
                message = qm.error("no such action", action_id=item_id)
                return qm.web.generate_error_page(request, message)

    # Generate HTML.
    page_info = ShowPageInfo(request, item, edit, create, type)
    return web.generate_html_from_dtml("show.dtml", page_info)


def retrieve_attachment_data(database, item_id, attachment):
    """Retrieve temporary attachment data and store it in the right place.

    'database' -- The test database.

    'item_id' -- The ID of the test or action associated with this
    attachment.

    'attachment' -- An 'Attachment' instance.

    Loads attachment data for 'attachment' stored in the temporary
    attachment store and stores it in its permanent location in the test
    database."""

    if attachment is None:
        return
    data = qm.attachment.retrieve_temporary_attachment(attachment.location)
    database.SetAttachmentData(attachment, data, item_id)


def handle_submit(request):
    """Handle a test or action submission.

    This function handles submission of the test or action editing form
    generated by 'handle_show'.  The script name in 'request' should be
    'submit-test' or 'submit-action'.  It constructs the appropriate
    'Test' or 'Action' object and writes it to the database, either as a
    new item or overwriting an existing item.

    The request must have the following form fields:

    'id' -- The test or action ID of the item being edited or created.

    'class' -- The name of the test or action class of this item.

    arguments -- Argument values are encoded in fields whose names start
    with 'qm.fields.Field.form_field_prefix'.

    'prerequisites' -- For tests, a set-encoded collection of
    prerequisites.  Each prerequisite is of the format
    'test_id;outcome'.

    'actions' -- For tests, a set-encoded collection of action IDs.

    'categories' -- For tests, a set-encoded collection of categories."""

    if request.GetScriptName() == "submit-test":
        type = "test"
    elif request.GetScriptName() == "submit-action":
        type = "action"

    # Make sure there's an ID in the request, and extract it.
    try:
        item_id = request["id"]
    except KeyError:
        message = qm.error("no id for submit")
        return qm.web.generate_error_page(request, message)
    
    database = qm.test.base.get_database()
    # Extract the class and field specification.
    item_class_name = request["class"]
    item_class = qm.test.base.get_class(item_class_name)
    fields = item_class.fields

    # We'll perform various kinds of validation as we extract form
    # fields.  Errors are placed into this map; later, if it's empty, we
    # know there were no validation errors.
    field_errors = {}

    # Loop over fields of the class, looking for arguments in the
    # submitted request.
    arguments = {}
    field_prefix = qm.fields.Field.form_field_prefix
    for field in fields:
        # Construct the name we expect for the corresponding argument.
        field_name = field.GetName()
        form_field_name = field_prefix + field_name
        try:
            # Try to get the argument value.
            value = request[form_field_name]
        except KeyError:
            # The value for this field is missing.
            message = qm.error("missing argument",
                               title=field.GetTitle())
            return qm.web.generate_error_page(request, message)
        # Parse the value for this field.
        try:
            value = field.ParseFormValue(value)
        except:
            # Something went wrong parsing the value.  Associate an
            # error message with this field.
            message = str(sys.exc_info()[1])
            field_errors[field_name] = message
        else:
            # All is well with this field.

            # If the field is an attachment field, or a set of
            # attachments field, we have to process the values.  The
            # data for each attachment is stored in the temporary
            # attachment store; we need to copy it from there into the
            # test database.  This function does the work.
            fn = lambda attachment, database=database, item_id=item_id: \
                 retrieve_attachment_data(database, item_id, attachment)
            if isinstance(field, qm.fields.AttachmentField):
                # An attachment field -- process the value.
                fn(value)
            elif isinstance(field, qm.fields.SetField) \
                 and isinstance(field.GetContainedField(),
                                qm.fields.AttachmentField):
                # An attachment set field -- process each element of the
                # value.
                map(fn, value)

            # Store the field value.
            arguments[field_name] = value

    if type is "test":
        # Extract prerequisite tests.  
        preqs = request["prerequisites"]
        preqs = qm.web.decode_set_control_contents(preqs)
        # Prerequisite tests are encoded as 'test_id:outcome'.  Unencode
        # them and build a map from test ID to expected outcome.
        prerequisites = {}
        for preq in preqs:
            # Unencode.
            test_id, outcome = string.split(preq, ";", 1)
            # Make sure this outcome is one we know about.
            if not outcome in qm.test.base.Result.outcomes:
                raise RuntimeError, "invalid outcome"
            # Store it.
            prerequisites[test_id] = outcome

        # Extract actions.
        actions = request["actions"]
        actions = qm.web.decode_set_control_contents(actions)

        # Extract categories.
        categories = request["categories"]
        categories = qm.web.decode_set_control_contents(categories)

        # Create a new test.
        item = qm.test.base.Test(test_id=item_id,
                                 test_class_name=item_class_name,
                                 arguments=arguments,
                                 prerequisites=prerequisites,
                                 categories=categories,
                                 actions=actions)

    elif type is "action":
        # Create a new action.
        item = qm.test.base.Action(action_id=item_id,
                                   action_class_name=item_class_name,
                                   arguments=arguments)

    # Were there any validation errors?
    if len(field_errors) > 0:
        # Yes.  Instead of processing the submission, redisplay the form
        # with error messages.
        request = request.copy(url="edit-" + type)
        page_info = ShowPageInfo(request, item, 1, 0, type, field_errors)
        return web.generate_html_from_dtml("show.dtml", page_info)

    # Store it in the database.
    if type is "test":
        database.WriteTest(item)
    elif type is "action":
        database.WriteAction(item)

    # Redirect to a page that displays the newly-edited item.
    request = qm.web.WebRequest("show-" + type, base=request, id=item_id)
    raise qm.web.HttpRedirect, qm.web.make_url_for_request(request)


def handle_add_prerequisite(request):
    """Handle the 'add-prerequisite' script.

    This page is generated in a pop-up window to allow the user to
    specify a new prerequisite to add to a test.

    'request' has the following fields:

      'path' -- The containing path of the test for which the
      prerequisite is being specified.  The ID of the prerequisite test
      is specified relative to this path.
    """

    page_info = AddPrerequisitePageInfo(request)
    return web.generate_html_from_dtml("add-prerequisite.dtml",
                                       page_info)


def handle_add_action(request):
    """Handle the 'add-action' script.

    This page is generated in a pop-up window to allow the user to
    specify a new action to add to a test.

    'request' has the following fields:

      'path' -- The containing path of the test for which the
      prerequisite is being specified.  The ID of the prerequisite test
      is specified relative to this path.
    """

    page_info = AddActionPageInfo(request)
    return web.generate_html_from_dtml("add-action.dtml", page_info)


def handle_add_category(request):
    """Handle the 'add-category' script.

    This page is generated in a pop-up window to allow the user to
    specify a new category to add to a test."""

    page_info = qm.web.PageInfo(request)
    return web.generate_html_from_dtml("add-category.dtml", page_info)


def handle_new_test(request):
    """Handle the 'new-test' script.

    This page is for choosing the test class and entering the test ID
    for a new test."""

    page_info = NewItemPageInfo(request, type="test")
    return web.generate_html_from_dtml("new.dtml", page_info)


def handle_new_action(request):
    """Handle the 'new-action' script.

    This page is for choosing the action class and entering the action
    ID for a new action."""

    page_info = NewItemPageInfo(request, type="action")
    return web.generate_html_from_dtml("new.dtml", page_info)


########################################################################
# Local Variables:
# mode: python
# indent-tabs-mode: nil
# fill-column: 72
# End:
