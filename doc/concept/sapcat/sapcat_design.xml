<?xml version="1.0" standalone="yes"?>

<Doc style="sapcat" abbrevs="sapcat_abbrevs">
<title>SapCat: Design</title>
<h1>SapCat: Design</h1>

<contents/>

<subdoc name="sub">

<h2 key="scDesign">Design</h2>
<p>
    In this chapter, we present a design for the {:sapcat:} system.
    We start with a high-level overview of the different packages that
    constitute {:sapcat:}.  Then we will go into more detail about the
    interfaces between packages, how the packages operate, etc.
</p>

<h3>Components</h3>
<figure img="pkg_sapcat.png"
	caption="SapCat Package Diagram"
	key="fig_pkg_sapcat"/>
<p>
    The {:sapcat:} system is composed of several components, as shown
    in Figure&nbsp;<ref key="fig_pkg_sapcat"/>.  The functions of the
    main components are:
</p>
<dl>

<dt>{:scGUI:}</dt>
<dd>
<p>
    The {:scGUI:} module provides the {:gui:} for the {:sapcat:}
    system.  As Figure&nbsp;<ref key="fig_pkg_sapcat"/> shows, it
    functions by interacting with the {:scMGR:} module.
</p>
</dd>

<dt>{:scPDD:}</dt>
<dd>
<p>
    The {:scPDD:} module provides the interface from various component
    to the actual package database.  We show this as a single module,
    but expect that alternative implementations will arise.  For
    instance, the actual database can be stored in XML, a
    {:python:}-like language, or LDAP.
</p>
</dd>

<dt>{:scMGR:}</dt>
<dd>
<p>
    The {:scMGR:} component is the main component.  It interacts with
    the various databases, probes the operating system, modifies
    files, etc.
</p>
</dd>

<dt>{:scTD:}</dt>
<dd>
<p>
    The {:scMGR:} accesses the {:scTD:} to find cached results, site
    conventions, etc.  Results of operating system probes and options
    specified by the {:tailor:} are stored in the {:scTD:}.  This
    module provides an interface to the actual database, which is
    distributed over several locations.
</p>
</dd>

<dt>{:scBUILD:}</dt>
<dd>
<p>
    The {:scBUILD:} module is an interface to the actual build
    systems.  It may be invoked by the {:scMGR:}, but it may also run
    independently.  We show it depending on the {:scPDD:} and the
    {:scTD:}; from these two databases, the build dependencies can be
    determined.  Figure&nbsp;<ref key="fig_pkg_build"/> shows how
    actual build systems are related to the generic {:scBUILD:}
    module.
</p>
<figure img="pkg_build.png"
	caption="Package Diagram for Build System"
	key="fig_pkg_build"/>
</dd>

<dt>{:scPD:}</dt>
<dd>
<p>
    The {:scPD:} contains information about the various feature probes
    that may be needed.
</p>
</dd>


<dt>{:scDISTRIB:}</dt>
<dd>
<p>
    The {:scDISTRIB:} is used to create {:srcdists:}, {:tsrcdists:},
    and {:bindists:}.  It uses the {:scBUILD:} to make sure that
    everything to go into the distribution is first built.  It uses
    data from the {:scPDD:} and the {:scTD:} to create the actual
    distributions.  It may be invoked by the {:scMGR:}.
    Figure&nbsp;<ref key="fig_pkg_bdist"/> shows how actual
    distribution builders are related the the generic {:scDISTRIB:}
    module.
</p>
<figure img="pkg_bdist.png"
	caption="Package Diagram for Distribution Builder"
	key="fig_pkg_bdist"/>
</dd>

<dt>{:scBOOT:}</dt>
<dd>
<p>
    The {:scBOOT:} creates bootstrap scripts.  This is a generic
    module; Figure&nbsp;<ref key="fig_pkg_boot"/> shows actual
    bootstrap script builders relate.
</p>
<figure img="pkg_boot.png"
	caption="Package Diagram for Bootstrap Script Builder"
	key="fig_pkg_boot"/>
</dd>

<dt>{:scSCAN:}</dt>
<dd>
<p>
    The {:scSCAN:} scans source files for symbols defined by probes.
    For C and other such languages, template header files are created.
    In other cases, {:scSCAN:} reads existing template files.
</p>
</dd>

<dt>{:scADAPT:}</dt>
<dd>
<p>
    The {:scADAPT:} module transforms template files that need to be
    adapted for the platform.  How this is done may depend on language
    dependencies.
</p>
<p>
    When a bootstrap script is used, the {:scADAPT:} may not be
    available.  A simple adapter, written in C, will be available that
    works with a few languages.  Bootstrap scripts cannot be created
    for packages that cannot use this simple adapter.
</p>
</dd>

<dt>{:scLANG:}</dt>
<dd>
<figure img="pkg_lang.png"
	caption="The Language Module"
	key="fig_pkg_lang"/>
<p>
    The {:scLANG:} provides language-independent routines for the
    {:scSCAN:} and {:scADAPT:}.  This abstract module uses the actual
    language-dependent modules.  Figure&nbsp;<ref key="fig_pkg_lang"/>
    shows how these modules relate.
</p>
</dd>
</dl>

<p>
    How do these modules actually interoperate?  The following
    sections describes a number of operations.
</p>

<h4>Tailoring</h4>
<p>
    The {:scPDD:} and the {:scPD:} form the heart of {:sapcat:}.  From
    the {:scPDD:}, {:sapcat:} determines the source files.  The
    {:scSCAN:} is used to find what symbols or macros are defined are
    defined in these files.  From this list of symbols, the {:scMGR:}
    module can assemble a list of probes and the order in which they
    must execute.
</p>
<p>
    The {:scMGR:} examines command line switches and options files,
    then begins evaluating probes.  When possible, probe results come
    from the probe results cache, through the {:scTD:}; otherwise the
    probe is executed, and the result stored in the {:scTD:}.
</p>
<p>
    When probing is completed, the {:scPDD:} is scanned for files that
    need to be adapted, and the {:scADAPT:} module actually creates
    the modified files.  Then the {:scBUILD:} module is used to create
    configurations files for the actual build system.  At this point,
    tailoring is complete.
</p>


<h4>Building Software</h4>
<p>
    {:sapcat:} is not directly responsible for building the software
    in a {:kit:}.  However, it provides a uniform interface to build
    systems.  This may involve creating <code>Makefile</code>s at
    tailoring time.  The {:scMGR:} will use the {:scBUILD:} module to
    configure and run the build system.
</p>


<h4>Bootstrap Scripts</h4>
<p>
    As with tailoring, the {:scMGR:} determines what probes are
    needed.  But this time, the {:scBOOT:} module is given the list of
    probes.  Inquiries to the {:scPDD:} are made, and a script is
    constructed to carry out these probes.  Inquiries are also made to
    the {:scPDD:} module to add commands to the script to build and
    use a simple adapter, written in C, to adapt files when the script
    is run.
</p>
<p>
    When a bootstrap script is run, it checks for command line
    switches or an option file for tailoring information.  Then it
    executes the probes.  Finally, it runs the adapter.
</p>
<p>
    We have not yet decided how the build system will interoperate
    with bootstrap scripts.  We will probably have options to
    configure either <code>Makefile</code>s or scripts.
</p>


<h4>Creating {:SrcDists:} and {:BinDists:}</h4>
<p>
    From the {:scPDD:}, {:scMGR:} can determine what needs to go into
    a {:srcdist:}.  {:sapcat:} is configured with information about
    what local distribution builders (tar, zip, etc.) are available.
    The {:scMGR:} calls upon the {:scDISTRIB:} module to actually
    create the distribution.
</p>
<p>
    For a {:bindist:}, the {:scMGR:} first calls upon the {:scBUILD:}
    module to make sure everything needed is up-to-date.  Then it uses
    the {:scPDD:} to determine what goes into the {:bindist:}.
    Finally, the {:scMGR:} calls upon the {:scDISTRIB:} module to
    create the {:bindist:}.
</p>
<p>
    Some {:kits:} may contain the components of multiple
    distributions.  The {:scPDD:} contains everything needed to
    determine what files go into which distributions.  It also
    contains information about any prerequisites packages.
</p>
<p>
    The {:scDISTRIB:} module can be extended using {:python:} modules
    to support additional distribution builders.
</p>



<h3>Interfaces</h3>

This section describes the interfaces to the various modules
comprising {:sapcat:}.  Sadly, it is not complete.

<h4>{:scPDD:}</h4>

<figure img="cl_pdd.png"
	caption="Package Description Database"
	key="fig_cl_pdd"/>
<p>
    Figure&nbsp;<ref key="fig_cl_pdd"/> shows our current thoughts for
    the {:scPDD:}.  It consists of representations of file system
    objects, both source and constructed.  It also contains some
    information regarding package options and distribution tags.  Not
    yet modelled is information for additional probes and
    platform-specific information.
</p>
<p>
    We have not settled on a final syntax for the {:scPDD:}.  In some
    ways, this is less important than the object interfaces to this
    module.  Indeed, there is merit to having several possible
    syntaxes.  A colleague who promotes LDAP observes that LDAP would
    allow the database to be distributed over multiple sites (and
    probably provide fast access).
</p>

<h4>{:scPD:}</h4>

<figure img="cl_probe.png"
	caption="Probe Database"
	key="fig_cl_probe"/>
<p>
    Figure&nbsp;<ref key="fig_cl_probe"/> shows the {:scPDD:}.  Probes
    can be selected on the basis of symbol names, operating system
    class, and programming language.  (Operating system class is a
    very general category, such as {:unix:}, {:windows:}, etc.)  The
    probe contains a test program to test for some feature.
</p>
<p>
    The difficulty of designing the probe database is that we cannot
    assume any particular scripting language is available to help us
    to interpret probe results.  This difficulty arises from the need
    to support bootstrap scripts.  We might be able to divide probes
    into two categories: those that can be used by bootstrap scripts,
    and those that cannot (but may use {:python:} scripting).
</p>
<p>
    We have not chosen an actual syntax for probes.  We expect each
    probe to be a file residing in a directory on a search path;
    perhaps each probe file will be described in XML.  We should point
    out that our LDAP advocate believes that LDAP would form a better
    basis for the probe database, and this could lead to a distributed
    system wherein the latest available versions of probes are always
    used.
</p>

<h4>{:scTD:}</h4>
<figure img="cl_tailor.png"
	caption="Tailoring Database"
	key="fig_cl_tailor"/>
<p>
    Figure&nbsp;<ref key="fig_cl_tailor"/> shows the {:scTD:}.  Before
    a probe is conducted, the {:scTD:} is consulted.  Likewise, the
    {:scADAPT:} uses the {:scTD:} to extract symbol values.
</p>
<p>
    In reality, the {:scTD:} is implemented over several databases.
    There is a system-wide cache, which should be protected so that
    only trusted users can regenerate it.  When a {:kit:} is tailored,
    probe information is cached in the {:kit:} directory.  Finally, a
    {:tailor:} may manually enter information into a configuration
    file in a {:kit:} to provide values to {:sapcat:}.
</p>

<h4>Remaining Modules</h4>
<p>
    We have not completed our design of the remaining modules.  Most
    of them are fairly simple.  The most complex module is the
    {:scMGR:}.  However, the only module that depends on it is the
    {:scGUI:}, and that dependency will be through the command line
    interface.
</p>

</subdoc>
<!-- Local Variables: -->
<!-- mode: xml -->
<!-- End: -->
</Doc>
