<?xml version="1.0" standalone="yes"?>

<Doc style="sapcat" abbrevs="sapcat_abbrevs">
<title>SapCat: Appendix: Ideas to Appropriate</title>
<h1>SapCat: Appendix: Ideas to Appropriate</h1>

<contents/>

<subdoc name="sub">
<appendix key="scIdeas">Ideas to Appropriate</appendix>
<p>
    The {:scconfig:} competition had a number of excellent entries.
    Though {:sapcat:} was chosen as the winning entry, there are a
    number of ideas from other the entries (even from the first round)
    that should be included in the final {:scconfig:} tool.  Indeed,
    reviewing these other entries has been a humbling experience.
</p>

<h3>Portability Knowledge Base</h3>
<p>
    The {:confbase:} proposal is geared around a knowledge base for
    portability.  <dfn>Causes</dfn> of portability problems are stored
    in this knowledge base, as well as <dfn>probes</dfn> to test for
    these causes and <dfn>solutions</dfn> to these causes.  {:confbase:}
    allows the program to query the knowledge base for information
    that may be helpful when developing a program.  Furthermore,
    {:confbase:} may be used to convert a program into a portable program
    by detecting problem code and converting it into portable code
    with the necessary probes.
</p>
<p>
    The {:sapcat:} design took the view that the programmer will write
    portable code, using macros, specific header files, or other
    language-appropriate symbols to ensure portability.  {:sapcat:}
    looks for these symbols to determine the necessary probes.
    Documentation discussing the portability issues, of course, is
    essential.
</p>
<p>
    There is a synergy between the {:confbase:} and {:sapcat:} approaches.
    A tool could use a knowledge base to translate <q>raw</q> source
    code into code that is portable by {:sapcat:}'s standards.  This
    knowledge base could also support the sorts of queries that
    {:confbase:} supports.  It may even be possible to automatically
    generate a <q>Portability Reference Guide</q> from information
    largely found in this knowledge base.  Meanwhile, programmers that
    prefer to write the portable code themselves, or are using
    features beyond the capabilities of the {:confbase:} tool,
    could still roll their own code.
</p>


<h3>Installed Package Registry</h3>
<p>
    Several of the proposals, notably {:tan:}, discussed saving
    information about installed packages in a central registry.  When
    tailoring a package, this registry could be queried to locate any
    prerequisite packages, as well as associated compilation and
    linking flags.  Additionally, programs could use an API to this
    registry to relate to other packages; the author of {:tan:}
    suggests that this could be used to easily switch between multiple
    installed versions of a package.<footnote>At {:RPI:}, we use a
    system called <Sys>setup</Sys> to handle multiple versions of
    applications.  As the author of <Sys>setup</Sys>, I would really
    have appreciated any standardized mechanism to assist in switching
    between versions.</footnote> The <Sys>rebar</Sys> proposal
    suggested similar ideas for determining configuration information
    for installed packages.
</p>
<p>
    Since systems often have multiple compilers for the same language,
    or different run-time environments, it is useful to have a way to
    indicate what compilers, switches, and other environmental
    attributes are needed to relate to other packages, such as
    libraries.  Although not clearly expressed in the {:sapcat:}
    proposal, it has always been our intent that installed packages
    that use {:sapcat:} would leave some sort of standardized file
    containing tailoring information useful to other packages.  
</p>
<p>
    A hierarchical registry could also be used to specify site
    conventions and other system- or project-specific configuration
    information.  For instance, a project may require that all
    libraries, etc. use a <Sys>gcc</Sys> with specific options, maybe
    to avoid a hardware bug.  We need to spend a bit more time
    specifying this registry.  The {:tan:} proposal is a good start.
</p>

<h3>Portability Library</h3>
<p>
    The {:compatlib:} proposal suggested that portability issues could
    be resolved mainly by writing them to {:posix:} standards and
    providing a library to guarantee a {:posix:}-compliant run-time
    environment.  Some common additional functions could also be
    added.
</p>
<p>
    While we are not convinced that a portability library providing a
    uniform interface across platforms is a general solution &mdash;
    in particular, it sacrifices performance and useful
    platform-specific features &mdash; there are a number of
    portability problems that may be best addressed using interface
    functions.
</p>
<p>
    One area where some sort of API would be useful is for functions
    that would simplify querying a configuration registry, getting
    pathnames set by {:sapcat:}, etc.
</p>

</subdoc>
<!-- Local Variables: -->
<!-- mode: xml -->
<!-- End: -->
</Doc>
