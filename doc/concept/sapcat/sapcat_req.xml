<?xml version="1.0" standalone="yes"?>

<Doc style="sapcat" abbrevs="sapcat_abbrevs">
<title>SapCat: Requirements</title>
<h1>SapCat: Requirements</h1>

<contents/>

<subdoc name="sub">

<h2 key="scReq">Requirements</h2>

<p>
    In this chapter, we will present the requirements we identified
    for {:sapcat:}.
</p>


<h3>Terminology</h3>

<p>
    The process of preparing software to run on a particular platform
    has been variously called configuring, tailoring, or customizing.
    Wordsmiths may debate how to best use these terms.  Our preference
    (after studying dictionary definitions) is to call this process of
    specifying site conventions, specifying local preferences for
    options, and adapting to the platform, <dfn
    key="tailoring">tailoring</dfn> or
    <dfn>customization</dfn>.<footnote>We recognize that
    <q>configuration</q> would be a fine term for this process.  But
    our choice of terminology now will affect our natural choices of
    file names, etc. later.  We thought it desirable to ultimately use
    different names than {:autoconf:} and {:metaconfig:} had
    used.</footnote> We will call the process of setting up site-wide
    files, e.g., the <code>sendmail.cf</code> file needed by <Sys><a
    href="http://www.sendmail.com/">sendmail</a></Sys>, <dfn
    key="configure">configuration</dfn>.  Finally, we will call the
    process of setting a user's personal preferences, <dfn
    key="personalize">personalizing</dfn>.
</p>
<p>
    We call a deliverable unit of software source code a <dfn
    key="kit">source kit</dfn> (or frequently, just a <dfn>kit</dfn>).
    A kit is generally distributed in some bundled manner, such as in
    a {:zip:}, {:rpm:}, or compressed {:tar:} archive.  Such a bundled
    kits is called a <dfn key="srcdist">source distribution</dfn>.  A
    source distribution can be unpacked into a kit, which in turn can
    be tailored, compiled, and installed on a platform.
    Alternatively, the installation step can be omitted, and the files
    that would have been installed instead archived with a tool like
    {:rpm:}, yielding a <dfn key="bindist">binary distribution</dfn>.
    We could also partially or fully tailor a kit, bundle it up, and
    produce a <dfn key="tsrcdist">tailored source distribution</dfn>.
    It may be possible to generate more than one binary or tailored
    source distribution from a single kit, e.g., to separate the
    run-time components from development components created from a
    compiler kit.
</p>
<p>
    The person who is tailoring some software is a <dfn
    key="tailor">tailor</dfn> (with respect to that software).  Since
    this person will typically also compile and install the software,
    we may also call him or her the <dfn>installer</dfn>.  A person
    who uses software after it has been installed is an <dfn
    key="enduser">end user</dfn>.  Finally, a <dfn
    key="softdev">software developer</dfn> is a person who creates the
    software that goes into a {:kit:}.
</p>
<p>
    From a {:softdev:}'s perspective, a {:kit:} or {:srcdist:} is
    created from a <dfn key="project">project</dfn>.  The project
    consists of all the files in the kit that are not generated by
    {:sapcat:}, as well any other files needed to support development,
    such as for version control, etc.  Some projects may generate more
    than one kit.  Projects may be composed from other projects.
</p>
<p>
    The term <dfn key="package">package</dfn> is often used when
    talking about software entitites.  We use this term to refer to a
    deliverable unit of software in any of its forms, whether that be
    a {:kit:}, a {:srcdist:}, or a {:bindist:}.  Often the context
    will clarify which form of the software is meant.
</p>


<h3 key="actors">The Actors and their Use Cases</h3>
<p>
     We have already introduced a couple actors, the tailor and the
     software developer.  In this section, we will study these actors
     in more depth.  This will help us identify a set of use cases we
     must satisfy.
</p>

<h4 key="actors_tailors">Tailors</h4>

<p>
    As we said earlier, a {:tailor:} is an actor that customizes a
    {:kit:}.  While both {:tailors:} and {:softdevs:} are {:endusers:}
    of the {:sapcat:} system, we give preference to meeting the needs
    of {:tailors:}, since while we can assume a {:softdev:} has some
    computer expertise, the same cannot be said of the {:tailor:}.
</p>
<p>
    {:Tailors:} range from the <dfn key="casinst">casual
    installer</dfn>, who is only interested in acquiring a handful of
    packages and probably does not want to extensively customize them,
    to the <dfn key="proinst">professional systems
    administrator</dfn>, who may need to tailor and install hundreds
    of packages, perhaps with extensive customization, perhaps for
    several different operating system platforms, perhaps repeating
    this process regularly.  A third kind of {:tailor:} is the <dfn
    key="sysint">systems integrator</dfn>, responsible for producing
    {:bindists:} and {:tsrcdists:} for operating system bundles or
    other purposes.
</p>

<h5>{:CasInsts:}</h5>
<p>
    The {:casinst:} probably wishes to know as little as possible
    about the details of tailoring.  The self-installing executable
    wizards prevalent with Windows packages, such as produced by
    <Sys>InstallShield</Sys>, are almost ideal for the {:casinst:}.  A
    {:gui:} is a great help, as are intelligent defaults, completely
    automated probing of the system, and (when possible) simple
    suggestions for resolving problems.  {:Bindists:} or {:tsrcdists:}
    may be preferred by {:casinsts:} over pure {:srcdists:}.
</p>
<p>
    Perhaps surprisingly to those who are not professional systems
    administrators, the system administered by {:casinsts:} are likely
    to be the most poorly maintained.  Any tool that relied on an
    accurate database of what other packages have been installed is
    likely to be inadequate for the {:casinst:}.
</p>
<p>
    The {:casinst:} is also going to be least equipped to create
    adequate bug reports, whether the failure be in tailoring,
    compilation, installation, or execution.  We need to be able to
    automatically report as much tailoring information as possible.
</p>
<p>
    The sort of things a {:casinst:} is likely to need to do are:
</p>
<ul>
    <li>Install with Wizard [<UseCase-Ref key="ucInstWiz"/>]</li>
    <li>GUI-controlled Tailoring [<UseCase-Ref key="ucGUI"/>]</li>
    <li>Report Tailoring problem [<UseCase-Ref key="ucRepTP"/>]</li>
</ul>

<h5>{:ProInsts:}</h5>
<p>
   The {:proinst:} is likely to be someone who needs to tailor, build,
   and install hundreds of packages for many different platforms,
   sometimes without fully understanding what the package is supposed
   to do.  Often this person is using very specialized site
   conventions.  This person needs to be able to tailor software
   repeatedly with as little interaction as possible.  Being able to
   script the entire tailoring step is a major convenience.
   Conversely, a {:gui:} is a major hindrance, unless it can help with
   scripting.  Great flexibility is needed; the {:proinst:} may need
   to override defaults and probe results.  Useful documentation for
   {:sapcat:} is essential.
</p>
<p>
   The {:proinst:} will appreciate a flexible scheme for specifying
   common site conventions.  Since site conventions may be
   complicated, extension modules (needed at tailoring time) might be
   needed.  Since many packages are being customized and built, it
   would be useful if there were a way to build and maintain a
   system-wide cache of {:sapcat:} probe results.
</p>
<p>
   If parallel computing facilities<footnote>We are using the term
   loosely here to describe both true multiprocessing parallel systems
   and loosely-coupled clusters of very similar systems.</footnote>
   are available, then we will want to be able to exploit this
   parallelism for both conducting system probes and building the
   system.  We may need to be able to specify what hosts are
   available, and how remote commands can be started.  These
   conventions may be complicated, and extension modules might be
   needed to fully exploit parallelism.
</p>
<p>
   The {:autoconf:} tool supports a mechanism using the
   <EnvVar>VPATH</EnvVar> variable, common to <Sys>make</Sys>, to
   allow one to tailor and build a package in a directory tree other
   than where the source code is located.  This makes it easy to build
   a package for several different platforms at the same time, a
   feature very useful to the {:proinst:}.  We want to support this
   feature in {:sapcat:}.
</p>
<p>
   A {:proinst:} is likely to be someone who will need to debug any
   problems encountered during tailoring.  A common sort of failure is
   likely to be a feature probe that gave an erroneous result.  (Well,
   hopefully not too common!)  The {:proinst:} will want to simply
   "repair" the result of that test and re-tailor.
</p>
<p>
    So we can identify a few needs of the {:proinst:}, in addition to
    those of the {:casinst:}:
</p>
<ul>
    <li>Install a {:sapcat:} Prerequisite [<UseCase-Ref key="ucInstSCPre"/>]</li>
    <li>Install {:sapcat:} [<UseCase-Ref key="ucInstSC"/>]</li>
    <li>Update {:sapcat:} [<UseCase-Ref key="ucUpdtSC"/>]</li>
    <li>Update {:sapcat:} Components [<UseCase-Ref key="ucUpdtSCComp"/>]</li>
    <li>Update {:sapcat:} Probe Cache [<UseCase-Ref key="ucUpdtPC"/>]</li>
    <li>Script-controlled Tailoring [<UseCase-Ref key="ucScript"/>]</li>
    <li>Configure for Site Conventions [<UseCase-Ref key="ucCfgSite"/>]</li>
    <li>Configure for Parallelism [<UseCase-Ref key="ucCfgPara"/>]</li>
    <li>Configure Overrides [<UseCase-Ref key="ucCfgOver"/>]</li>
    <li>Install a Package for in Testing [<UseCase-Ref key="ucInstTest"/>]</li>
</ul>


<h5>{:SysInts:}</h5>
<p>
   A {:sysint:} is a {:tailor:} who builds {:bindists:} that can be
   easily installed by a {:casinst:}.  These may go into a binary
   collection of software, such as one of the many {:linux:}
   distributions.  A {:sysint:} may also prepare {:tsrcdists:} for an
   organization.
</p>
<p>
    In addition to the needs of {:proinsts:}, a {:sysint:} has these
    additional requirements:
</p>
<ul>
    <li>Partial Tailoring [<UseCase-Ref key="ucPartial"/>]</li>
    <li>Create a Binary Distribution [<UseCase-Ref key="ucCreBinDist"/>]</li>
    <li>Configure Cross-platform Tailoring [<UseCase-Ref key="ucCfgXPlat"/>]</li>
</ul>

<h4>{:SoftDevs:}</h4>

<p>
    As we said earlier, a {:softdev:} is an actor who creates a
    {:srcdist:}.  We assume they are wise enough to use {:sapcat:}.
    There are a number of different kinds of {:softdevs:}, each with
    slightly different needs.
</p>
<p>
    One sort of developer is the generic <dfn key="packdev">package
    developer</dfn>, an actor creating an arbitrary package tailored
    with {:sapcat:}.  A special sort of {:packdev:} is the <dfn
    key="sapdev">SapCat developer</dfn>.
</p>

<h5>{:PackDevs:}</h5>
<p>
    A {:packdev:} is generally interested in creating a particular
    application.  This actor may not be expert in the details of
    software portability or large-scale systems administration; the
    actor's focus may be on a particular problem domain.  But we
    necessarily require the {:packdev:} to accommodate the
    requirements of {:sapcat:}, which must not be too burdensome.  We
    can facilitate compliance by providing mechanisms that will both
    simplify the software development task and guarantee compliance.
</p>
<p>
   The {:packdev:} may discover that platform-specific compiler bugs
   require special options with certain source files.  We need a way
   to express this sort of information.  (The {:tailor:} will also
   need to be able to specify exceptions, and override internal
   exceptions.  Locating these execeptions easily will be important.)
</p>
<p>
   The {:packdev:} needs to be able to produce {:srcdists:} of all or
   part of the project.  It is important that timestamps on archived
   files be sane.  There may be some changes to source files that
   should be done when the source distribution is built, like
   inserting copyrights, licenses, etc.
</p>
<p>
   We need to be able to interface with version control systems.  This
   may require extension modules.
</p>
<ul>
    <li>Make Tailorable Source Files [<UseCase-Ref key="ucMakeFiles"/>]</li>
    <li>Create/Modify Package Description [<UseCase-Ref key="ucCreProj"/>]</li>
    <li>Add a Probe [<UseCase-Ref key="ucAddProbe"/>]</li>
    <li>Test a Probe [<UseCase-Ref key="ucTestProbe"/>]</li>
    <li>Create Kit [<UseCase-Ref key="ucCreKit"/>]</li>
    <li>Create Source Distribution [<UseCase-Ref key="ucCreSrc"/>]</li>
</ul>

<h5>{:SapDevs:}</h5>
<p>
    A {:sapdev:} is involved in creating or maintaining {:sapcat:}.
    All the use cases of other {:softdevs:} apply, as well as these
    additional cases:
</p>
<ul>
    <li>Update {:sapcat:} Probe Documentation</li>
    <li>Test Probe Collection</li>
</ul>


<h4>Use Cases</h4>

<p>
    We will now discuss the use cases we have developed for
    {:sapcat:}.  Our design will try to satisfy these use cases.  This
    list tries to be broad, but is undoubtedly incomplete.
</p>

<h5>Maintaining {:sapcat:} Software</h5>


<figure img="uc_maint.png"
	caption="SapCat Maintenance Use Cases"
	key="fig_uc_maint" />
<p>
    Several use cases are concerned with installing and maintaining
    the {:sapcat:} software and its configuration on a system.  Since
    {:sapcat:} has prerequisites, these also must be considered.
    Figure&nbsp;<ref key="fig_uc_maint"/> shows the relationships
    between these use cases.
</p>

<UseCase name="Install SapCat Prerequisite" key="ucInstSCPre">
<UseCase-Description>
<p>
    It must be possible to tailor and install prerequisites to
    {:sapcat:}, such as {:python:}, on systems.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Essential</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    This is probably the most difficult use case of all.  Assuming the
    developers of Python, and its prerequisites like Tcl/Tk, all adopt
    {:sapcat:} as their customization system, how do we then initially
    tailor these packages on a system on which {:sapcat:} has not yet
    been installed?  We cannot simply install {:sapcat:}, since it
    needs these prerequisites!  We call this difficulty the
    <dfn>bootstrap problem</dfn>.
</p>
<p>
    One possible solution is to insist that all {:sapcat:}
    prerequisites will already be installed, or easily available as
    {:bindists:}.  For common platforms, this may be true.  But it
    will not be true for older or less common systems, such as legacy
    {:unix:}.
</p>
<p>
    Another possible solution is to require these prerequisite
    packages be cross-tailored, using a different system.  But this is
    inconvenient, and requires the extensive knowledge of the target
    platform that {:sapcat:} is supposed to replace.
</p>
<p>
    The {:autoconf:} tool is successful because the Bourne shell
    scripts it generates are portable to most {:unix:} systems.  These
    scripts can even be run on {:windows:} systems, using a
    {:unix:}-compatibility tool like {:cygwin:}.  The drawback to
    using a {:unix:}-compatibility tool is that, if we are not
    careful, it can lead to run-time dependencies on this tool in our
    tailored software.  Sadly, the native batch language on
    {:windows:} is simply not rich enough to support the customization
    process, so obvious solution of producing both a Bourne shell and
    a batch script is not an option.<footnote>If there is a good way
    to run scripts on native {:windows:}, I would love to hear about
    it.  Neither I nor my associates are familiar with any such
    features.</footnote>
</p>
<p>
    Our solution is to provide an extendible mechanism for building
    boot-strap scripts.  Initially, we will provide the mechanism
    necessary build Bourne shell boot-strap scripts.
</p>
<p>
    We emphasize that using boot-strap scripts is a very specialized
    use case.  For the near future, we expect most {:sapcat:} users
    will be running on either {:windows:} or {:linux:}, for which all
    of {:sapcat:}'s prerequisites will already be available in binary
    form.  Users of legacy Unix systems generally will either be
    professional installers, or will have the services of a
    professional installer available.
</p>
<p>
    How important is this use case?  Guido van Rossum, Technical Director
of the Python Consortium, wrote:
</p>
<blockquote cite="http://www.software-carpentry.com/sc_config/">
<p>
    Nine years ago, when I first released Python to the world, I
    distributed it with a Makefile for BSD Unix. The most frequent
    questions and suggestions I received in response to these early
    distributions were about building it on different Unix
    platforms. Someone pointed me to autoconf, which allowed me to
    create a configure script that figured out platform idiosyncracies
    Unfortunately, autoconf is painful to use &mdash; its grouping,
    quoting and commenting conventions don't match those of the target
    language, which makes scripts hard to write and even harder to
    debug. I hope that this competition comes up with a better
    solution &mdash; it would make porting Python to new platforms a
    lot easier!
</p>
</blockquote>
<p>
    Meeting this use case has a number of consequences.  First, we
    must be able to interoperate with a variety of build systems;
    {:scbuild:} may also be unavailable when {:python:} and its
    prerequisites are first tailored and compiled.  Second, we will
    not be able to specify probes using any scripting language, since
    we cannot count on any particular scripting language being
    available.  This is disappointing, since it would be nice to use
    {:python:} for this purpose.
</p>
</UseCase-Discussion>
<UseCase-Sequence>
<ol>
    <li>Unpack {:srcdist:} into a {:kit:}.</li>

    <li>Execute a bootstrap script with the <q>help</q> option.</li>

    <li>Determine options that need to be customized.  If there are
    many, it may be desirable to create an <q>options file</q>.</li>

    <li>Execute the bootstrap script, either with options or
    specifying the options file.</li>

    <li>Use the build system to build and install the package.</li>
</ol>
</UseCase-Sequence>
</UseCase>


<UseCase name="Install SapCat" key="ucInstSC">
<UseCase-Description>
<p>
    There must be a way to tailor and install {:sapcat:} on a system.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Essential</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    This is a specialized case of installing a {:sapcat:}
    prerequisite.  Some help may be needed to locate {:python:} and
    other {:sapcat:} prerequisites, but since a {:sapcat:} {:kit:}
    contains the {:sapcat:} system code, it should be possible to use
    this code to control tailoring and installation.
</p>
</UseCase-Discussion>
<UseCase-Sequence>
<ol>
    <li>Unpack {:sapcat:} {:srcdist:} into a {:kit:}.</li>

    <li>Execute the installer script using {:python:}, passing any
    options needed to tailor the local installation.</li>

    <li>Create any extension modules needed for site conventions.</li>

    <li>Enjoy!</li>
</ol>
</UseCase-Sequence>
</UseCase>


<UseCase name="Update SapCat" key="ucUpdtSC">
<UseCase-Description>
<p>
    There must be a way to update a {:sapcat:} installation on a system.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Desirable</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    We would like a way to update a {:sapcat:} installation in a
    convenient manner, perhaps from a central web site.
</p>
<p>
    Since one should be able to use {:rpm:} or other mechanisms to
    reinstall {:sapcat:}, we will defer consideration of this use
    case.
</p>
</UseCase-Discussion>
</UseCase>


<UseCase name="Update SapCat Components" key="ucUpdtSCComp">
<UseCase-Description>
<p>
    It is desirable to be able to update components of {:sapcat:},
    such as probes.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Important</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    {:sapcat:} has many components.  We expect the collection of
    operating system feature probes to be expanding and improving
    rapidly, especially at first.  It should be possible to update the
    collection of probes from a central repository, without completely
    updating or reinstalling {:sapcat:}.
</p>
<p>
    We expect early versions of {:sapcat:} to directions on how to
    update probes.  Later versions will look towards better methods of
    updating probes, perhaps using an LDAP database of available
    probes.
</p>
</UseCase-Discussion>
</UseCase>


<UseCase name="Update SapCat Probe Cache" ident="UC5" key="ucUpdtPC">
<UseCase-Description>
<p>
    {:sapcat:} can maintain a cache of probe results on a system.
    This cache should be updated whenever operating system components
    are changed.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Important</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    Inspired by {:autoconf:}, {:sapcat:} supports a cache of probe
    results.  But changes to the operating system, application
    software, etc. can invalidate this cache without detection.  It
    must be possible to regenerate this cache.
</p>
</UseCase-Discussion>
<UseCase-Sequence>
<ol>
    <li>Start {:sapcat:} tool, invoking the <q>regenerate probe
    database</q> command.</li>

    <li>Wait until it finishes.  Report any problems.</li>
</ol>
</UseCase-Sequence>
</UseCase>


<h5>Tailoring {:SrcDists:}</h5>

<figure img="uc_tailor.png"
	caption="SapCat Tailoring Use Cases"
	key="fig_uc_tailor"/>
<p>
    The main goal of {:sapcat:} is to facilitate software tailoring,
    so we have use cases relating to the tailoring process.
    Figure&nbsp;<ref key="fig_uc_tailor"/> shows the relationships
    between several of these use cases.  A few additional use cases
    are listed below.
</p>

<UseCase name="Install with Wizard" key="ucInstWiz">
<UseCase-Description>
<p>
    For {:casinsts:}, it is ideal to be able to install a package in
    one fell swoop, without any interaction beyond what is truly
    necessary (such as to enter a user or organization name).
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Important</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    We expect to satisfy this use case as we continue developing
    {:sapcat:}.  Ideally, it would be wonderful if any missing
    packages could also be obtained.  Section&nbsp;<ref
    key="instwiz"/> gives a detailed scenario of how the wizard should
    work.
</p>
</UseCase-Discussion>
</UseCase>


<UseCase name="GUI-controlled Tailoring" key="ucGUI">
<UseCase-Description>
<p>
    Control tailoring through a {:gui:}.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Important</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    This use case generalizes <UseCase-Ref key="ucInstWiz"/>.  Complete
    control of customization options is available from the {:gui:},
    including overriding probe results.  However, while we do not want
    to hinder the {:proinst:}, we do not wish to confuse or overwhelm
    the {:casinst:} either.  So we arrange for the options that will
    be most useful to casual users to be the most easily accessible.
    Help text will be available.
</p>
</UseCase-Discussion>
</UseCase>


<UseCase name="Script-controlled Tailoring" key="ucScript">
<UseCase-Description>
<p>
    Support tailoring through a command line interface.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Essential</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    A {:proinst:} needs to be able to completely control the tailoring
    process.  {:sapcat:} can be run from the command line.  Tailoring
    can be controlled either through command line options or a
    configuration file.
</p>
</UseCase-Discussion>
</UseCase>


<UseCase name="Partial Tailoring" key="ucPartial">
<UseCase-Description>
<p>
    Allow some, but not all, aspects of tailoring to be completed.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Desirable</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    To create a {:tsrcdist:}, it is necessary to partially (but not
    fully) tailor a {:kit:}.  This use case is not yet fully
    developed.
</p>
</UseCase-Discussion>
</UseCase>


<UseCase name="Configure SapCat for Site Conventions" key="ucCfgSite">
<UseCase-Description>
<p>
    We need to be able to configure site conventions into {:sapcat:},
    so they do not need to be specified each time a package is
    tailored.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Important</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    Site conventions can be either simple or complex.  Implementation
    of complex conventions may require programming.  So we should have
    an interface to extension modules.  This interface would not be
    usable to bootstrap scripts.
</p>
</UseCase-Discussion>
</UseCase>


<UseCase name="Configure SapCat for Parallelism" key="ucCfgPara">
<UseCase-Description>
<p>
    Set up {:sapcat:} to support parallel probing.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Desirable</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    Probing can take a very long time.  While some probes have
    dependencies on the results of earlier probes, others do not.  We
    would like to be able to exploit parallelism to run several probes
    simultaneously.  It might also be possible to exploit this
    parallelism while building a {:kit:}.
</p>
<p>
    Depending on the system, it might be reasonable to run several
    probes at once.  This is most likely to be the case on SMP system.
    In many environments, another option is to remotely execute probes
    on a different but identical machine.
</p>
</UseCase-Discussion>
</UseCase>


<UseCase name="Configure Overrides" key="ucCfgOver">
<UseCase-Description>
<p>
    Configure overrides to the results of probes.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Essential</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    Sometimes probes will give unexpected results on uncommon or new
    platforms.  If tailoring is to be successful, it will be necessary
    to override some probe results.
</p>
<p>
    {:sapcat:} must provide a mechanism to determine what probes will
    be executed to tailor a package.
</p>
</UseCase-Discussion>
</UseCase>

<!-- Another figure here? -->

<UseCase name="Install Package for Testing" key="ucInstTest">
<UseCase-Description>
<p>
    A {:proinst:} frequently needs to be able to install a package in
    a temporary <q>test</q> configuration, without disrupting a
    <q>production</q> version of the package.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Essential</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    New releases of software often have bugs or incompatibilities with
    other interrelated software that are not known until the software
    is installed and used.  When that software is mission-critical, it
    is essential that it can be installed in some sort of <q>test</q>
    configuration.
</p>
<p>
    This can be accomplished with {:sapcat:} by installing the package
    into a separate directory tree.  It may be necessary to install
    other packages into this tree, too.
</p>
</UseCase-Discussion>
</UseCase>


<UseCase name="Create a Binary Distribution" key="ucCreBinDist">
<UseCase-Description>
<p>
    A {:sysint:} may wish to create one or more {:bindists:} from a
    {:kit:}.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Desirable</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    We think that the developer of a package is best able to determine
    how it can be divided into separate binary packages.  This avoids
    the problem of forgetting necessary programs or data files.
    However, it is the {:sysint:} who actually creates the
    {:bindists:}, and we need to pass on information from the
    {:softdev:}.  Furthermore, what actually goes into a {:bindist:}
    may depend on how the {:kit:} was tailored.
</p>
<p>
    While creating {:bindists:} goes beyond the scope of the
    {:scconfig:} competition, we think {:sapcat:} must at least
    cooperate in this activity.
</p>
</UseCase-Discussion>
</UseCase>


<UseCase name="Configure Cross-platform Tailoring" key="ucCfgXPlat">
<UseCase-Description>
<p>
    Use {:sapcat:} to tailor software on one platform to operate on
    another.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Desirable</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    Sometimes cross-development tools are available to allow software
    to be built on one platform that will run on another (perhaps
    lacking a development environment).  Normal tailoring, however,
    will tailor for the platform on which cross-development is taking
    place, not the target.  There is a need to be able to tailor for
    different platforms.
</p>
<p>
    Since {:sapcat:} allows the results of every probe to be
    overwritten, one way to accomplish this is to create a separate
    cache of probe results, to be used only for cross-tailoring.  This
    will not help if a {:kit:} includes its own probes, so additional
    support will be needed to detect this case.
</p>
</UseCase-Discussion>
</UseCase>


<h5>Software Development</h5>

<figure img="uc_softdev.png"
	caption="Software Developer Use Cases"
	key="fig_uc_softdev"/>
<p>
    Figure&nbsp;<ref key="fig_uc_softdev"/> shows some of the use
    cases involved with developing software to work with {:sapcat:}.
    These are discussed below.
</p>


<UseCase name="Make Tailorable Source Files" key="ucMakeFiles">
<UseCase-Description>
<p>
    Source files must be constructed to support tailoring.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Essential</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    Source code that is going to be adapted by the tailoring process
    needs to be written to react to tailoring.  This is done by
    parameterizing the code on symbols or macros.  In some cases,
    templates are written, with symbols indicated; at customization
    time, these templates will be transformed into the real files.  In
    other cases, such as with C, a header file will be created with
    macro definitions in it corresponding to the results of feature
    probes.
</p>
</UseCase-Discussion>
<UseCase-Sequence>
<ol>
    <li>Determine what operating system features need to be probed.
    The {:sapcat:} probe documentation will provide a wealth of
    information on operating system features.</li>

    <li>Determine which macros or symbols indicate results of testing
    for this feature.  The {:sapcat:} probe documentation can provide
    this information.</li>

    <li>Determine optional package features, and the associated macro
    or symbol names.</li>

    <li>Modify the source code to be parameterize on these symbols or
    macros.  Make sure there are no occurrences of symbols or macros
    that may misleadingly indicate a feature probe result.</li>

    <li>Modify the package description database to contain information
    about the optional package feature.  Note that there is no need to
    directly include information about operating system probes.</li>

    <li>Make sure every source file appears in the package description
    database.</li>

</ol>
</UseCase-Sequence>
</UseCase>

<UseCase name="Create/Modify Package Description" key="ucCreProj">
<UseCase-Description>
<p>
    Create or modify the {:scPDD:} file.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Essential</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    {:sapcat:} depends on a database to describe the project.  This
    database is distributed in one or more files.  For large projects,
    it may become important to have tools to navigate this database.
    However, in the early stages of {:sapcat:}, we will expect these
    files to be created by the {:softdev:}, perhaps using a text
    editor.
</p>
<p>
    It has been suggested that for very large projects, a database
    service like LDAP would be preferable to a file-based database
    like XML.  Using LDAP would allow projects to be distributed over
    multiple sites.  We expect to look more into the possibilities of
    distributed projects in the future.
</p>
</UseCase-Discussion>
</UseCase>

<UseCase name="Add a Probe" key="ucAddProbe">
<UseCase-Description>
<p>
    Some packages require special probes.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Important</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    When a package requires an operating system feature test not
    contained in the {:sapcat:} probe collection, it needs to be added
    to the project.  One or more directories containing special probes
    can be added to the {:scPDD:}.
</p>
</UseCase-Discussion>
</UseCase>

<UseCase name="Test a Probe" key="ucTestProbe">
<UseCase-Description>
<p>
    Test how a probe works.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Important</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    If a probe is added to a {:kit:}, there must be a way to test it.
    (This is one of the shortcomings of {:autoconf:}.)  We need to be
    able to quickly test any {:sapcat:} probe.
</p>
</UseCase-Discussion>
</UseCase>

<UseCase name="Integrate Legacy Packages" key="ucIntegrate">
<UseCase-Description>
<p>
    Integrate a package that does not use {:sapcat:} into a package
    that does.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Desirable</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    {:sapcat:} probes can search for installed packages, but sometimes
    there is a need to incorporate an old package directly into a new
    package.  For instance, sometime encumbered code cannot legally be
    modified, even though it is freely obtainable, and is only useful
    in conjunction with another package.  We need a way to be able to
    adapt that other package's build system into {:sapcat:}'s.
</p>
<p>
    This is a difficult problem, and we do not have a solution yet.
</p>
</UseCase-Discussion>
</UseCase>



<h5>Creating {:Kits:} and {:SrcDists:}</h5>

<figure img="uc_kit.png"
	caption="SapCat Source Distribution Creation"
	key="fig_uc_kit"/>
<p>
    A {:softdev:} needs to create the {:srcdists:} needed by
    {:tailors:}.  Figure&nbsp;<ref key="fig_uc_kit"/> shows the
    relationships between these use cases.
</p>

<UseCase name="Create Kit" key="ucCreKit">
<UseCase-Description>
<p>
    Create a {:kit:} for a project.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Essential</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    Prior to creating a {:srcdist:}, all the components of a {:kit:}
    must be ready.  This use case allows {:sapcat:} to use the build
    system to create any files that must be distributed with a
    {:srcdist:}.  (For instance, some files may be generated by
    special tools that are not necessarily available to recipients of
    a {:srcdist:}.)
</p>
</UseCase-Discussion>
</UseCase>

<UseCase name="Create Source Distribution" key="ucCreSrc">
<UseCase-Description>
<p>
    Create a {:srcdist:} for a project.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Important</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    The {:scPDD:} contains information about what should go into the
    {:kit:} and the {:srcdists:}.  {:sapcat:} can be used to create
    the actual distribution.
</p>
</UseCase-Discussion>
</UseCase>




<h5>Problem Reporting</h5>
<p>
    Problems may be encountered as {:sapcat:} is developed and new
    platforms (with new features and bugs) are introduced.  {:sapcat:}
    needs a problem reporting mechanism.
</p>


<UseCase name="Report Tailoring Problem" key="ucRepTP">
<UseCase-Description>
<p>
    Report problems with the tailoring process.
</p>
</UseCase-Description>
<UseCase-Priority>
<p>Important</p>
</UseCase-Priority>
<UseCase-Discussion>
<p>
    If tailoring fails, e.g., a probe gives a completely unexpected
    result, then a problem report needs to be sent.  It probably
    should go to the maintainer of the package, who can then forward
    it to the {:sapcat:} development team.
</p>
</UseCase-Discussion>
</UseCase>


</subdoc>
<!-- Local Variables: -->
<!-- mode: xml -->
<!-- End: -->
</Doc>
