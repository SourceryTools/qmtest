<?xml version="1.0"?>
<!--

  File:   design-probe.xml
  Author: R. Lindsay Todd
  Date:   2000-11-15

  Contents:
    Design of the probe database.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<section id="sec-design-interfaces-probe">
 <title>&M-PD;</title>

 <para>From a study of &Qautoconf;, we believe that several basic
 categories of probes are needed:</para>

 <variablelist>
  <varlistentry>
   <term>Checking for a command</term>
   <listitem>
    <para>Frequently we need to determine whether or not a command
    exists.  For example, if we are building a library on &Qunix;,
    some systems require us to use <command>ranlib</command>.
    However, some &Qunix; systems do not need or even have
    <command>ranlib</command>.</para>

    <para>Other times, we may need to test if one of several command
    exists, perhaps choosing the <quote>best</quote>, based on some
    metric.  For example, many systems have several C compilers.  It
    may matter which one is used, so we need to be able to supply
    tests.  The &D-tailor; may have an opinion to offer, too, in which
    case we may still want to test the chosen compiler for
    sanity.</para>

    <para>An annoying reality is that our ability to test a program
    may depend on the privileges of the &D-tailor;.</para></listitem>
  </varlistentry>

  <varlistentry>
   <term>Checking for a file or database</term>
   <listitem>
    <para>We may need to see if certain files or databases are present.</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>Check for libraries and functions</term>
   <listitem>
    <para>The &Qautoconf; system does this by building test programs
    and compiling them.  &Qmetaconfig; does this by using
    <command>nm</command> to build a list of the entry points in an
    archive, and parsing the output.  While this is faster, it is
    sensitive to changes in the output of <command>nm</command>.
    Given that even inexpensive computers are fast these days, it is
    probably best to use the compilation approach.</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>Check for header files</term>
   <listitem>
    <para>The &Qautoconf; system does this by attempting to compile a
    small program using the header file.  Since some systems use
    precompiled header files, this is superior to simply searching
    under, say, <filename class="directory">/usr/include</filename> on
    &Qunix;.  Furthermore, different compilers or compiler switches
    may alter where header files are found.  Compiling verifies that a
    header file is actually available.</para>

    <para>It would be good to test the usability of header files,
    including compatibility with other header files.</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>Check for functions, types, structure members</term>
   <listitem>
    <para>In rare cases, permissions of the caller may affect probe
    results.  For instance, can arbitrary users change ownership of
    files with <function>chown</function> (as in AIX, for files in
    &Qafs;), or is this restricted to the superuser?  These cases can
    probably be handled by "guessing" based on platform, using a
    default that won't cause major problems if wrong, and using site
    conventions (which could perhaps be determined using a script,
    verifiable by the system administrator or system integrator, that
    actually performs probes under superuser privileges).</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>Determine compiler characteristics</term>
   <listitem>
    <para>Some of the characteristics that need checking have to do
    with language dialects.  For instance, does the C compiler provide
    some sort of useful <type>inline</type> keyword?  Most platforms
    now provide ANSI C, but we want to test characteristics of
    prototypes anyway.  C++ provides even more room for
    variation.</para>

    <para>Some compiler characteristics may seem, at first glance, to
    be system characteristics.  For instance, in C or C++, how big are
    <type>int</type>, <type>long</type>, and <type>float</type>?  How
    many bits of precision does a <type>float</type> or a
    <type>double</type> have?  Is there a usable Fortran
    <type>REAL*16</type> type?  We might consider some of these to be
    <quote>system</quote> characteristics, but in reality, different
    compilers (perhaps the same compiler with different options) may
    implement these features in different ways.</para>
   </listitem>
  </varlistentry>

 </variablelist>

 <figure id="fig-cl-probe" float="1">
  <title>Probe Database</title>
  <mediaobject>

   <imageobject>
    <imagedata align="center" width="6in" scale="50" scalefit="1"
               fileref="cl_probe.png"></imagedata>
   </imageobject>

   <textobject>
    <phrase>Probe database</phrase>
   </textobject>

  </mediaobject>
 </figure>

 <para><xref linkend="fig-cl-probe"></xref> shows the &M-PDD;.  Probes
 can be selected on the basis of symbol names, operating system class,
 and programming language.  (Operating system class is a very general
 category, such as &Qunix;, &Qwindows;, etc.)  The probe contains a
 test program to test for some feature.</para>

 <para>The difficulty of designing the probe database is that we
 cannot assume any particular scripting language is available to help
 us to interpret probe results.  This difficulty arises from the need
 to support bootstrap scripts.  We might be able to divide probes into
 two categories: those that can be used by bootstrap scripts, and
 those that cannot (but may use &Qpython; scripting).</para>

 <para>We have not chosen an actual syntax for probes.  We expect each
 probe to be a file residing in a directory on a search path; perhaps
 each probe file will be described in &Q-XML;.  We should point out
 that our &Q-LDAP; advocate believes that &Q-LDAP; would form a better
 basis for the probe database, and this could lead to a distributed
 system wherein the latest available versions of probes are always
 used.</para>

 <para><programlisting>
<![CDATA[
class QualifiedProbe:

    """Class representing a qualified probe.  Probes may depend on
    symbols, like other scripts and programs.  They also accept
    parameters, which tailor the probe for particular uses (for
    instance, specify a function for which the have_function probe
    should test.  A probe that has been passed parameters is a
    "qualified probe"."""


    def GetProbeSource(self):

        """Get a "ProbeSource" object representing this qualified
        probe.

        returns -- A "ProbeSource" object."""


    def GetDefinedSymbols(self, probe_platform):

        """Get the list of symbols defined by this probe.

        'probe_platform' -- A name designating the scripting language
        and other characteristics of the probe platform.

        raise $$$ -- No script for 'probe_platform'.

        returns -- List of Symbol objects These have already been
        initialized with the appropriate "ProbeSource" objects."""


    def GetRequiredSymbols(self, probe_platform):

        """Get the list of symbols required by this probe.  These
        symbols will need values before the probe script can be
        executed.

        'probe_platform' -- A name designating the scripting language
        and other characteristics of the probe platform.

        raise $$$ -- No script for 'probe_platform'.

        returns -- List of Symbol objects."""


    def GetScript(self, probe_platform):

        """Get the script needed to execute this probe.

        'probe_platform' -- A name designating the scripting language
        and other characteristics of the probe platform.

        raise $$$ -- No script for 'probe_platform'.

        returns -- The script."""


class Probe:

    """Class representing a probe."""

    def Qualify(self, probe_dp, probe_aux):

        """Qualify this probe with the supplied parameters.

        'probe_dp' -- The distinguished parameters to this probe.

        'probe_aux' -- Auxiliary parameters for this probe, which may
        come from a ProbeAuxDB.

        raise $$$ -- Incomplete set of parameters, or spurious
        parameters.

        returns -- A qualified probe."""
        

    def GetPatternSet(self, prog_lang, set_name=None):

        """Get a pattern for identifying symbols relating to this
        probe.

        'prog_lang' -- Name of the programming language for which we
        need a pattern.

        'set_name' -- Name of the pattern set.  Some programming
        languages may define several sorts of symbols, e.g., for
        matching magic header files, for matching preprocessor
        symbols, etc.  Other languages may have a single pattern set,
        in which case this parameter may be omitted.

        returns -- A list of patterns.  These may be regular
        expressions.  Really, they are whatever the language-specific
        scanner requires."""


    def GetName(self):

        """Get the name of this probe.

        returns -- The name of the probe."""


class ProbeAuxDB:

    """Database of auxiliary information for probes.  A probe is
    selected by parsing symbol names, and may include certain
    "distinguished" parameters to differentiate between similar uses
    of the same probe.  (For instance, we probably want a single probe
    to test for the existence of a function; we distinguish instances
    with the function name.)  However, there may be additional
    parameters needed to test for a function that should not be
    overloaded into symbol names. (With the function test example, for
    example, we may need to specify header files, link libraries, and
    possibly a test program.)  These additional parameters can come
    from the probe auxiliary database."""


    def AddProbe(self, probe_name, probe_dp_types, probe_aux_types):

        """Add information about a probe to the auxiliary probe
        database.

        'probe_name' -- The probe being added to the database.

        'probe_dp_type' -- A dictionary mapping distinguished
        parameter names to their types.

        'probe_aux_types' -- A dictionary mapping auxiliary parameter
        names to their types.

        $$$ We need to decide how to represent these types...

        raise 'KeyError' -- There already is probe information for
        'probe_name' in this database.

        returns -- None"""


    def AddProbeParameters(self, probe_name, probe_dp, probe_aux):

        """Add a set of parameters to a distinguished probe.

        'probe_name' -- The probe for which information is being
        added.

        'probe_dp' -- Distinguished parameters for 'probe_name'.  This
        is a mapping of parameter names to values.

        'probe_aux' -- A mapping of auxiliary parameter names to
        values.

        raise 'KeyError' -- There is no information for 'probe_name'
        with the specified parameters in this database."""


    def GetProbeParameters(self, probe_name, probe_dp={}):

        """Find the set of auxiliary parameters for a probe.

        'probe_name' -- The name of the probe being checked.

        'probe_dp' -- Distinguished parameters for 'probe_name'.  This
        is a mapping of parameter names to values.

        raise 'KeyError' -- There is no information for 'probe_name'
        with the specified parameters in this database.

        raise 'IndexError' -- One or more distinguished parameters for
        'probe_name' are missing.

        returns -- A dictionary mapping parameter names to values."""


class ProbeDB:

    """Base class for probe databases."""


    def DeriveFrom(self, pdb):

        """Add a base probe database to this database.  This
        relationship persists until 'self' is closed.

        'pdb' -- Probe database from which to derive probe information.

        returns -- None"""


    def Update(self, pdb):

        """Update probes from another probe database (perhaps a master
        probe repository).  This may add new probes to 'self'.

        'pdb' -- The probe database from which to add or update

        objects.

        returns -- None"""


    def Commit(self):

        """Commit all changes to the actual database representing
        'self'.

        raise 'IOError' -- The database cannot be written.

        returns -- None"""


    def AddProbeAuxDB(self, padb):

        """Add a ProbeAuxDB object to the list of auxiliary databases
        used by this probe database.  This relationship persists until
        'self' is closed. These databases are searched in the order
        given for additional parameters.

        'padb' -- The ProbeAuxDB being added to the list.

        returns -- None"""


    def AddProbe(self, probe):

        """Add a Probe object to this database.

        precondition -- There is not already a probe with the same
        name as 'probe'.

        'probe' -- The new probe object.

        raise $$$ --

        postcondition -- There is now a probe in 'self' whose name is
        taken from 'probe'.

        returns -- None"""


    def ChooseProbe(self, symbol_name, prog_lang, set_name=None):

        """Select a probe object."""
]]></programlisting></para>

</section>

<!--
  Local Variables:
  mode: sgml
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("qmconfig.xml" "book" "chapter" "section")
  End:
-->
