<?xml version="1.0"?>
<!--

  File:   design-basic.xml
  Author: R. Lindsay Todd
  Date:   2000-12-27

  Contents:
    Describe basic classes.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<section id="sec-design-interfaces-basic">
 <title>Basic Classes</title>

 <para>A number of classes are common to several modules of
 &qmconfig;.  These are defined in the <classname
 role="module">common</classname> module, shown in <xref
 linkend="fig-cl-tailorsym"></xref>.</para>

 <figure id="fig-cl-tailorsym" float="1">
  <title>Basic Classes</title>

  <mediaobject>

   <imageobject>
    <imagedata align="center" scale="40" scalefit="1"
               fileref="cl_tailorsym.png" format="PNG"></imagedata>
   </imageobject>
   <textobject>
    <phrase>Basic Classes</phrase>
   </textobject>

  </mediaobject>
 </figure>

 <section id="mod.tailor-sym.SymbolType">
  <title><classname>SymbolType</classname> class</title>

  <para> The <classname>SymbolType</classname> is a base class for
  types for symbols.  Derived types are used to represent boolean,
  string, and integer values.  We will also want to support
  enumerations, and possibly specialized strings like file
  names.</para>

  <para><programlisting>
 <![CDATA[
class SymbolType:

    """Base class for symbol types."""

    def IsValid(self, val):

        """Test if a value is valid for this type.

        'val' -- Value to be tested.

        returns -- 1 if 'val' is valid for this type; 0 otherwise."""
]]></programlisting></para>

 </section>

 <section id="mod.tailor-sym.Symbol">
  <title><classname>Symbol</classname> class</title>

  <para>The <classname>Symbol</classname> class represents symbols.
  Besides having a name and a type, a symbol also has documentation
  associated with it that can be used to assist the &D-tailor;.  This
  documentation may be available for different languages, and comes in
  both a brief and extended form.  Each <classname>Symbol</classname>
  objects is also associated with a <classname>SymbolType</classname>
  object.</para>

  <para><programlisting>
<![CDATA[
class Symbol:

    """Class representing symbols."""

    def __init__(self, symbol_name, symbol_type, def_val,
                 short_doc, long_doc):

        """Define a new symbol.

        'symbol_name' -- Name of the new symbol.

        'symbol_type' -- Type of the new symbol.  $$$ What are our
        types?  Need to be able to include enumerations!

        'def_val' -- Default value for this symbol.

        $$$ Do we want some sort of substitution to take place?  If
        so, then ideally it is Pythonic.  But some of the most useful
        substitutions would take place at tailoring time, making it
        necessary to have Python available then.  Other possibilities
        are a shell-like format, or different versions for different
        probe platforms.

        'short_doc' -- Brief description for this symbol.

        'long_doc' -- Longer description for this symbol."""


    def AddDescription(self, lang, short_doc, long_doc=None):

        """Add a description for this symbol in some natural language.

        'lang' -- Designator for a natural language.

        'short_doc' -- Short documentation string for this symbol,
        presumably written in the natural language indicated by
        'lang'.  (The 'short_doc' string from when the symbol was
        created is a fallback description.)

        'long_doc' -- Longer documentation string for the symbol,
        again presumably written in the natural language indicated by
        'lang'.  If 'long_doc' is None, then there is no longer
        documentation string."""


    def GetName(self):

        """Get the name of this symbol.

        returns -- The name of the symbol."""


    def GetType(self):

        """Get the type of this symbol.

        returns -- The type of this symbol."""


    def GetDefault(self):

        """Get the default value for this symbol.

        returns -- The default value for this symbol, or None if there
        is no default."""


    def GetShortDescription(self, lang=None):

        """Get the short documentation string for this symbol for the
        specified language.  If not found, return the fallback short
        documentation string.

        'lang' -- Indicate the natural language, or None to get the
        fallback.

        returns -- The short documentation string."""


    def GetLongDescription(self, lang=None):

        """Get the long documentation string for this symbol for the
        specified language.  If not found, return the fallback long
        documentation string.

        'lang' -- Indicate the natural language, or None to get the
        fallback.

        returns -- The long documentation string."""
]]></programlisting></para>
 </section>

 <section id="mod.tailor-sym.ProbeSource">
  <title><classname>ProbeSource</classname> class</title>

  <para><classname>ProbeSource</classname> objects are used in a
  number of places to represent invocations of probes.  As we shall
  see in <xref linkend="sec-design-interfaces-probe"></xref>, probes
  have parameters.  So <classname>ProbeSource</classname> objects must
  convey both the probe name and the parameters.</para>

  <para>Probes have two sorts of parameters.  <firstterm
  id="D-disparm">Distinguished parameters</firstterm> are used to
  fully identify the probe.  For example, we may have a "function"
  probe to search for a function.  The actual probe is only fully
  identified when bound with a function name.  Since probes are
  determined by parsing special symbol names in found in the source
  code, any symbol associated with a probe must provide the
  &D-disparms;.  The other sort of parameters are <firstterm
  id="D-auxparm">auxiliary parameters</firstterm>.  An &D-auxparm;
  receives a value from an auxiliary probe database, or from a default
  associated with the probe.  An example of an &D-auxparm; would be
  the name of a library in which to search for a function.</para>

  <para>Additionally, probes execute on a <firstterm
  id="D-probeplat">probe platform</firstterm>, an abstraction that may
  be used to distinguish between different scripting languages or
  other major execution platform differences.  A
  <classname>ProbeSource</classname> object must thus indicate the
  probe platform.  The &D-probeplat; may determine the set of
  &D-auxparms; to be associated with a probe.</para>

  <para><programlisting>
 <![CDATA[
class ProbeSource:

    """Symbols whose source is a probe store information about the
    source probe and parameters in a "ProbeSource" object."""


    def __init__(self, probe_name, probe_platform, probe_dp, probe_ap):

        """Create the "ProbeSource" object.

        precondition -- 'probe_platform' is a valid execution platform
        for this probe.

        precondition -- 'probe_dp' is valid and complete for this
        probe.

        precondition -- 'probe_ap' is valid and complete for this
        probe on 'probe_platform', with default values to parameters
        already assigned.

        'probe_name' -- Name of the probe.

        'probe_platform' -- Name of the probe execution platform.

        'probe_dp' -- Distinguished parameters for this probe.  This
        is a mapping of parameter names to values.

        'probe_ap' -- Auxiliary parameters for this probe on
        'probe_platform'.  This is a mapping of parameters names to
        values."""


    def GetProbeName(self):

        """Get the name of the probe.

        returns -- Name of the probe used as a source for this
        object."""


    def GetProbePlatform(self):

        """Get the probe platform for which this probe source is
        valid.

        returns -- A string representing a probe execution
        platform."""


    def GetDistinguishedParameters(self):

        """Get the distinguished parameters needed to identify and
        execute this probe.

        returns -- A dictionary mapping parameter names to values
        (which are strings)."""


    def GetAuxiliaryParameters(self):

        """Get the auxiliary parameters needed to execute this probe
        on its execution platform.

        returns -- A dictionary mapping parameter names to values
        (which are strings)."""
]]></programlisting></para>
 </section>


</section>

<!--
  Local Variables:
  mode: sgml
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("qmconfig.xml" "book" "chapter" "section")
  End:
-->
