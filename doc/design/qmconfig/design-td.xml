<?xml version="1.0"?>
<!--

  File:   design-td.xml
  Author: R. Lindsay Todd
  Date:   2000-12-05

  Contents:
    Design of qmconfig tailoring database.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<section id="sec-design-interfaces-td">
 <title>&M-TD;</title>

 <para>The actual &M-TD; used to tailor a kit may be composed from
 several separate databases.  This allows the &D-tailor; to use
 central system-wide or personal databases to share tailoring
 information across a number of &D-kits;, while still individually
 tailoring a particular &D-kit;.</para>

 <para>The &M-TD; contains both metadata about the different tailoring
 symbols needed to tailor an application, and the values of those
 symbols.  Static metadata includes they type of the symbol, text
 describing the symbol, what requires the symbol's value, and what
 probe provides a symbol (for symbols derived from probe results).
 Dynamic metadata indicates from when a symbol's value came &mdash;
 from the &D-tailor;, or from a probe.  Information about the needed
 probes is stored in the &M-TD; itself.  Additionally, if we have
 files that collect symbols, e.g, header files similar to
 &Qautoconf;'s <filename class="headerfile">config.h</filename>, we
 need to store information about them, too.</para>

 <para>In normal operation, &qmconfig; creates a &M-TD;, sans values,
 by scanning source files and the &M-PDD; for <firstterm
 id="D-dirsym">direct symbols</firstterm>, those that are directly
 used by the &D-kit;.  Some of these &D-dirsyms; may be the results of
 probes, which in turn may depend on additional symbols; these
 additional symbols will be added to the &M-TD;. This empty &M-TD; is
 distributed as part of the &D-kit;.</para>

 <para> At tailoring time, &qmconfig; must make sure that all
 &D-dirsyms; have values.  If necessary, probes are executed to get
 values for symbols.  We always prefer values provided by the
 &D-tailor; and we only execute a probe if one of its results does not
 have a value.  Once all &D-dirsyms; have values, the &M-ADAPT; can
 modify and create tailored files.</para>

 <para>We expect the &M-TD; to be stored in &Q-XML; files.  However,
 centralized tailoring databases may be more appropriately referenced
 by a <acronym>URL</acronym>, or stored in an &Q-LDAP; database.
 &D-Kits; tailored using bootstrap scripts will use a small C
 program<footnote> <para>Why C?  We reason that the only time we
 <emphasis>must</emphasis> run a bootstrap script is to tailor
 &Qpython; or one of its prerequisites, and these are programmed in C
 &mdash; so C must be available, or the exercise is moot.</para>
  </footnote>
 to access the &M-TD; and adapt files, so we expect these to
 <emphasis>only</emphasis> support the &Q-XML; local file
 format.</para>

 <figure id="fig-cl-tailor" float="1">
  <title>Tailoring Database</title>

  <mediaobject>

   <imageobject>
    <imagedata align="center" scale="40" scalefit="1"
               fileref="cl_tailor.png" format="PNG"></imagedata>
   </imageobject>

   <textobject>
    <phrase>Tailoring database</phrase>
   </textobject>

  </mediaobject>
 </figure>

 <para>The module <classname role="module">tailor_db</classname>
 contains the class definitions for the tailoring database itself,
 illustrated in <xref linkend="fig-cl-tailor"></xref>.</para>

 <section>
  <title><classname>MetaProbeSource</classname> class</title>

  <para>As discussed in <xref
  linkend="mod.tailor-sym.ProbeSource"></xref>, a
  <classname>ProbeSource</classname> object represents an invocation
  of a probe.  This information must be stored in the &M-TD;.  As
  information is collected during tailoring, additional information
  must be associated with <classname>ProbeSource</classname> objects,
  such as whether the probe must actually be executed.  This
  information is stored in <classname>MetaProbeSource</classname>
  object.</para>

  <para><programlisting>
<![CDATA[
class MetaProbeSource:

    """Information about probe sources, including auxiliary
    parameters, must be stored in the tailoring database, since we
    wish it to be self-contained.  Operations on "MetaSymbol" use
    "MetaProbeSource" objects, so we do not get inconsistencies in
    auxiliary parameters."""

    def __init__(self, probe_source, tdb):

        """Associated 'self' with the 'probe_source' object.

        'probe_source' -- A "ProbeSource" object to be associated with
        'self'.

        'tdb' -- The "TailorDB" object associated with 'self'."""


    def GetProbeSource(self):

        """Get the "ProbeSource" object associated with 'self'.

        return -- The "ProbeSource" object."""


    def IsRequired(self):

        """Determine whether or not the probe must be executed for the
        tailoring database to be usable.  A probe need not be executed
        if there are values for each of the symbols it specifies.

        return -- 1 if the probe is required, 0 otherwise."""


    def ResetProbeResults(self):

        """Reset the values of symbols set by a probe, unless those
        symbols received their values from the tailor.  If there are
        other probes that depend on these symbols, the results of
        those probes are also reset.

        return -- None"""
]]></programlisting></para>
 </section>

 <section>
  <title><classname>MetaSymbolCollector</classname> class</title>

  <para>Some symbol values are tailored not by changing source files
  but by collecting definitions into a common file.  For example,
  &Qautoconf; can create a <filename
  class="headerfile">config.h</filename> with manifest constants
  defined.  Such a file is called a <firstterm id="D-symcoll">symbol
  collector</firstterm>.</para>

  <para>A <classname>MetaSymbolCollector</classname> object represents
  a &D-symcoll; file.  It will contain a list of the
  <classname>Symbol</classname> objects that should be stored in the
  file.  Note that a symbol may be associated with more than one
  &D-symcoll;.</para>

  <para><programlisting>
<![CDATA[
class MetaSymbolCollector:

    """A collector file holds symbol assignments. For example, a
    header file may be created to hold symbol assignments for a
    collection of related files."""


    def __init__(self, file_name, tdb):

        """Create a "MetaSymbolCollector" object associated with the
        collector file, 'file_name'.

        'file_name' -- The file that will collect the symbol
        definitions.

        'tdb' -- The "TailorDB" object associated with 'self'."""


    def GetFileName(self):

        """Get the name of the file associated with 'self'.

        return -- The file name."""


    def GetCollectedSymbols(self):

        """Get the list of symbols in this collection.  Note that a
        symbol may belong to more than one collection.

        return -- A list of "MetaSymbol" objects representing the
        symbols."""
]]></programlisting></para>
 </section>

 <section>
  <title><classname>MetaSymbol</classname> class</title>

  <para>The <classname>Symbol</classname> objects, discussed in <xref
  linkend="mod.tailor-sym.Symbol"></xref>, provide information about
  tailoring symbols.  In the &M-TD;, values may be associated with
  these symbols.  A <classname>MetaSymbol</classname> associates a
  value with a <classname>Symbol</classname> object, as well as other
  metadata necessary for the operation of &qmconfig;.</para>

  <para><programlisting>
<![CDATA[
class MetaSymbol:

    """Symbols in a tailoring database may have values and other
    metadata associated with them.  This class represents these
    symbols, allowing the metadata to be managed.  Note that changes
    to metadata may cause other changes in the tailoring database
    itself."""

    def __init__(self, symbol, tdb):

        """Associate 'symbol' with this "MetaSymbol" object.

        'symbol' -- A "Symbol" object to associate with 'self'.

        'tdb' -- The tailoring database associated with 'self'."""


    def GetSymbol(self):

        """Get the "Symbol" object associated with 'self'.

        return -- The associated "Symbol" object."""


    def SetValueFromTailor(self, val, probe_platform=None):

        """Enter or change a value for a symbol, where the value is
        assigned by the tailor.

        precondition -- 'val' is compatible with the type associated
        with the symbol.

        'val' -- The value being assigned to the symbol.  This is a
        string representing a value.

        'probe_platform' -- A string representing a probe platform.
        If this is None, then the value is set for all probe platforms
        from which this symbol may be defined.

        raise 'TypeError' -- The type of 'symbol_name' is not
        compatible with 'value'.

        return -- None"""


    def SetValueFromProbe(self, val, probe_platform):

        """Enter or change a value for this symbol, where the value is
        a result of executing the probe associated with this symbol on
        a particular probe execution platform.  This has no effect if
        the value of the symbol was already set by the tailor.

        precondition -- 'val' is compatible with the type associated
        with the symbol.

        'val' -- The value being assigned to the symbol.  This is a
        string representing a value.

        'probe_platform' -- A string representing a probe platform.

        raise 'KeyError' -- There is no probe source associated with
        'self' for 'probe_platform'.

        raise 'TypeError' -- The type of the symbol is not compatible
        with 'value'.

        return -- None"""


    def GetValue(self, probe_platform):

        """Get the value of the symbol for a particular probe execution
        platform.

        'probe_platform' -- Name of the probe execution platform for
        which we want the symbol value.

        raise 'KeyError' -- No value, not even a default, is found for
        'probe_platform' in 'self'.

        return -- The value."""


    def ResetValue(self, probe_platform=None):

        """Reset the value of the symbol to its default.  If there are
        probes that depend on those symbols, then the results of those
        probes are also reset.

        'probe_platform' -- Probe execution platform for which we want
        to reset the value.  If this is None, then the value for all
        probe platforms is reset.

        return -- None"""


    def IsValueSet(self, probe_platform):

        """Determine whether or not a symbol has been assigned a
        value for a particular probe platform.

        'probe_platform' -- Name of the probe execution platform to be
        tested.

        return -- 1 if there is a value associated with
        'probe_platform', 0 otherwise."""


    def IsValueFromTailor(self, probe_platform):

        """Determine whether or not a symbol has been assigned a value
        by a tailor.  This is true, even if we inherit the value from
        another tailoring database in which the value had been
        assigned by a tailor.

        'probe_platform' -- Name of the probe execution platform to be
        tested.

        return -- 1 if there is a value associated with
        'probe_platform' that was set by a tailor, 0 otherwise."""


    def IsValueFromProbe(self, probe_platform):

        """Determine whether or not a symbol has received a value
        computed by executing a probe.  This is true, even if we
        inherit the value from another tailoring database in which the
        value had been assigned by a executing a probe.

        'probe_platform' -- Name of the probe execution platform to be
        tested.

        return -- 1 if there is a value associated with
        'probe_platform' that was set by a probe, 0 otherwise."""


    def IsRequired(self):

        """Determine whether or not a symbol must be assigned a value.
        If a symbol is only required for probes that will not be
        executed, then no value need be assigned to that symbol in
        order to tailor.

        return -- 1 if the symbol is required, 0 otherwise."""


    def MakeDirect(self):

        """Indicate that this symbol is directly required by the
        project.  This means that it is used in one of the source
        files, build scripts, etc. (as opposed to being needed only by
        other probe scripts).  The project cannot be constructed
        unless a value is assigned to this symbol.

        return -- None"""


    def AddProbeConsumer(self, mps):

        """Indicate that this symbol is required by 'probe_source'.

        precondition -- 'mps' is associated with the same "TailorDB"
        object as 'self'.

        'mps' -- A "MetaProbeSource" object, representing a probe that
        requires this symbol.

        return -- None"""


    def AddProbeSource(self, mps):

        """Indicate that this symbol can be set by 'mps'.

        precondition -- 'mps' is associated with the same "TailorDB"
        object as 'self'.

        'mps' -- A "MetaProbeSource" object representing the source.

        return -- None"""


    def AddSymbolCollector(self, msc):

        """Add this symbol to a symbol collector.

        precondition -- 'msc' is associated with the same "TailorDB"
        object as 'self'.

        'msc' -- A "MetaSymbolCollector" with which this symbol will
        be associated."""
]]></programlisting></para>
 </section>

 <section>
  <title><classname>TailorDB</classname> class</title>

  <para>A <classname>TailorDB</classname> object is an actual
  tailoring database.  A &M-TD; may refer to other tailoring
  databases, both in a hereditary and inclusionary sense.  In the
  hereditary sense, using the <methodname>DeriveFrom</methodname>
  method, a <classname>TailorDB</classname> object will retrieve
  values and other information for undefined symbols from another
  <classname>TailorDB</classname> object.  This is useful for
  providing common site-wide, work group, or personal tailoring
  information; changing the common <classname>TailorDB</classname>
  object will affect &D-kits; as they are re-tailored and rebuilt.  In
  the inclusionary sense, using the <methodname>Update</methodname>
  method, values are directly loaded into one
  <classname>TailorDB</classname> from another.  We expect this
  operation to be useful for creating partially tailored
  &M-TD;'s.</para>

  <para><programlisting>
<![CDATA[
class TailorDB:

    """Base class for tailoring databases.  Instances of these classes
    represent tailoring databases.  Project may be tailored using a
    set of tailoring databases."""


    # Basic operations.

    def DeriveFrom(self, tdb):

        """Add a base tailoring database to this database.  This
        relationship persists until 'self' is closed.  Any symbol in
        'self' that has not been assigned a value will inherit its
        value from 'tdb', if the corresponding symbol in 'tdb' has the
        same symbol type and has an assigned value.  (If the value is
        defaulted in both 'self' and 'tdb', then the default in 'self'
        prevails.)

        'tdb' -- The base tailoring database from which this database
        will inherit values."""


    def Update(self, tdb):

        """Update the values stored in 'self' from 'tdb'.  Only values
        in 'self' for which there are definitions will be updated, and
        only if the type of a symbol in 'self' matches the type from
        'tdb', and only if the value of a symbol in 'self' is the
        default, but is an assigned value in 'tdb'.

        'tdb' -- The tailoring database from which this database will
        obtain values.

        return -- None"""


    def Clear(self):

        """Empty this tailoring database, including all definitions.
        This does not break any "DeriveFrom" relationships, but it
        does remove the effects of any "Update" operations.  This
        operation is needed if the tailoring database must be
        recreated."""


    def ResetAllSymbols(self):

        """Reset the values of all symbols to their defaults.

        return -- None"""


    def ResetAllProbeResults(self):

        """Reset the values of all symbols that were set as the result
        of a probe operation.

        return -- None"""


    def Commit(self):

        """Commit all changes to the actual database representing
        'self'.

        raise 'IOError' -- The database cannot be written.

        return -- None"""


    # Operations of symbols and their metadata.


    def AddSymbol(self, symbol):

        """Add a new symbol to the tailoring database.

        precondition -- There is not already a symbol with the same
        name as 'symbol'.

        'symbol' -- A Symbol object representing the symbol.  The name
        of the symbol comes from this object.

        raise $$$ -- Already a symbol with this name.

        postcondition -- The is now a symbol in the database with the
        name taken from 'symbol'.

        return -- The "MetaSymbol" object associated with this
        symbol."""


    def AddProbeSource(self, probe_source):

        """Add a probe source to the tailoring database.

        precondition -- There is not already a probe source with the
        same probe name, distinguished parameters, and probe platform
        as 'probe_source'.

        'probe_source' -- The "ProbeSource" object to add to 'self'.

        raise 'KeyError' -- There already is a "ProbeSource" object
        with the same probe name, distinguished parameters, and probe
        platform.

        return -- The "MetaProbeSource" object to use for associating
        the probe source with symbols."""


    def AddSymbolCollector(self, file_name):

        """Add a symbol collector file to the tailoring database.

        precondition -- There is not already a symbol collector
        associated with 'file_name'.

        'file_name' -- Name of the file to collect the symbol
        definition.

        raise 'KeyError' -- There already is a symbol collector named
        'file_name'.

        return -- The "MetaSymbolCollector" object to use for
        associating symbols with 'file_name'."""


    def GetMetaSymbol(self, symbol_name):

        """Get the "MetaSymbol" object named 'symbol_name'.

        precondition -- There is a symbol in this database named
        'symbol_name'.

        'symbol_name' -- Name of the Symbol object.

        raise 'KeyError' -- No symbol named 'symbol_name'.

        return -- The Symbol object."""


    def GetMetaProbeSource(self, probe_name, probe_dp, probe_platform):

        """Get a "MetaProbeSource" object identified by the probe
        name, distinguished parameters, and probe execution platform.

        precondition -- There is a probe source with these attributes.

        'probe_name' -- Name of the probe.

        'probe_dp' -- Distinguished parameters identifying this probe.
        This is a dictionary mapping names to values (strings).

        'probe_platform' -- A string identifying the execution
        platform.

        raise 'KeyError' -- ('probe_name', 'probe_dp',
        'probe_platform') do not identify a registered probe source.

        return -- A "MetaProbeSource" object."""


    def GetMetaSymbolCollector(self, file_name):

        """Locate a "MetaSymbolCollector" object associated with a
        file.

        precondition -- 'file_name' has been registered as a symbol
        collector.

        'file_name' -- Name of the file being used as a symbol
        collector.

        raise 'KeyError' -- 'filename' has not been designated as a
        symbol collector.

        return -- A "MetaSymbolCollector" object."""


    def GetAllDirectSymbols(self):

        """Get a list of all direct symbols.

        return -- A list of "MetaSymbol" objects."""


    def GetAllSymbols(self):

        """Get a list of all the symbols in the tailoring database.

        return -- A list of "MetaSymbol" objects."""


    def GetAllProbeSources(self):

        """Get a list of all the probe sources associated with this
        tailoring database.

        return -- A list of "MetaProbeSource" objects."""


    def GetAllSymbolCollectors(self):

        """Get a list of all the symbol collectors associated with
        this tailoring database.

        return -- A list of "MetaSymbolCollector" objects."""
]]></programlisting></para>
 </section>

 <section>
  <title>Miscellaneous classes</title>

  <para>The <classname>TailorDB</classname> class is an abstract base
  class.  It should be possible to create various repositories for
  tailoring databases, such as &Q-LDAP; or a <acronym>SQL</acronym>
  database.  The most useful form will probably be an &Q-XML; database
  stored in a file, represented by an
  <classname>TailorDBXMLFile</classname> object.  &D-Kits; will ship
  with such databases already generated.  It might be possible to read
  an &Q-XML; tailoring database through some other mechanism, such as
  <acronym>HTTP</acronym>, so we generalize this with the
  <classname>TailorDBXML</classname> class.</para>

  <para><programlisting>
<![CDATA[
class TailorDBXML(TailorDB):

    """Tailoring databases stored as XML."""


class TailorDBXMLFile(TailorDBXML):

    """Tailoring databases, stored as XML, in simple files."""

    def __init__(self, file_name):

        """Constructor for a TailorDB object.

        'file_name' -- Name of a file containing a tailoring
        database."""
]]></programlisting></para>
 </section>

 <section>
  <title>Command-line interface</title>

  <para>Besides the &Qpython; &api; described above, there is a
  command-line interface to manage the &M-TD;, using the
  <command>tailordb</command> command.  This is necessary since probes
  will need to be able to set values as they execute; the probe
  scripts may not necessarily be in &Qpython;.</para>

  <para>We intend the <command>tailordb</command> to be implemented in
  &Qpython;.  We also intend for their to be a simple implementation
  in C, for use on systems that require bootstrap scripts.</para>

  <synopsis>
  <command>tailordb</command> <optional>options</optional> <replaceable>subcommand</replaceable> <optional>arguments</optional>
  </synopsis>

  <para>The <replaceable>subcommand</replaceable> possibilities are:
   <variablelist>

    <varlistentry>
     <term><synopsis><command>adapt</command> <replaceable>filename</replaceable></synopsis></term>
     <listitem>
      <para>Adapt <replaceable>filename</replaceable> to the tailoring
      symbols in the tailoring database.  The &Qpython; version of the
      <command>tailordb</command> will have the full file adapter
      capabilities described in <xref
      linkend="sec-design-interfaces-lm"></xref>.  The C version will
      have a limited set of file adapters.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><synopsis><command>checkprobe</command> <replaceable>probe</replaceable></synopsis></term>
     <listitem>
      <para>Check whether or not <replaceable>probe</replaceable>, a
      probe name with distinguished parameters, needs to be executed.
      Probes do not need to be executed if all the symbols they define
      are already defined, or are only needed by other probes that
      will not be executed.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><synopsis>clear</synopsis></term>
     <listitem>
      <para>Clear all values from the tailoring database.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><synopsis><command>get</command> <replaceable>symbol</replaceable></synopsis></term>
     <listitem>
      <para>Retrieve the value of <replaceable>symbol</replaceable>,
      writing it to standard output.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
    <term><synopsis><command>set</command> <replaceable>symbol</replaceable> <replaceable>value</replaceable></synopsis></term>
     <listitem>
      <para>Set the value of <replaceable>symbol</replaceable> to
      <replaceable>value</replaceable>.</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>The C source code for <command>tailordb</command> is
  distributed with a &D-kit; requiring bootstrapping.  The source is
  broken up into a few files; one is a small "dispatch table" that may
  be modified to add additional language adapters, if necessary.  The
  code is divided this way so that updates to the main version
  distributed with &qmconfig; can be directly used.</para>

 </section>

 <section>
  <title>&xml; Representation</title>

  <para>The &Q-XML; representation for a &M-TD; is not yet developed;
  we do not have a DTD for it.  However, the example shown in <xref
  linkend="fig-xml-tailordb"></xref> demonstrates the flavor of what
  we think such a database would look like.</para>

  <para>The C version of the <command>tailordb</command> command is
  unlikely to have a full validating &Q-XML; parser.  We nee to choose
  a representation that will be simple and efficient to
  implement.</para>

  <figure id="fig-xml-tailordb">
   <title>&xml; representation for a tailoring database</title>
    <programlisting><![CDATA[
<?xml version="1.0"?>
<tailordb>
 <probesource id="p1" name="function">
  <dparam name="strerror"/>
 </probesource>
 <symbol id="s1" name="has_strerror" type="int" fromprobe="p1">
  <value>1</value>
 </symbol>
</tailordb>
]]></programlisting>
  </figure>

 </section>

</section>

<!--
  Local Variables:
  mode: sgml
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("qmconfig.xml" "book" "chapter" "section")
  End:
-->
