<?xml version="1.0"?>
<!--

  File:   design-td.xml
  Author: R. Lindsay Todd
  Date:   2000-12-05

  Contents:
    Design of qmconfig tailoring database.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<section>
 <title>&M-TD;</title>

 <para>The actual &M-TD; used to tailor a kit may be composed from
 several separate databases.  This allows the &D-tailor; to use
 central system-wide or personal databases to share tailoring
 information across a number of &D-kits;, while still individually
 tailoring a particular &D-kit;.</para>

 <para>The &M-TD; contains both metadata about the different tailoring
 symbols needed to tailor an application, and the values of those
 symbols.  Static metadata includes they type of the symbol, text
 describing the symbol, what requires the symbol's value, and what
 probe provides a symbol (for symbols derived from probe results).
 Dynamic metadata indicates from when a symbol's value came &mdash;
 from the &D-tailor;, or from a probe.</para>

 <para>In normal operation, &qmconfig; creates a &M-TD;, sans values,
 by scanning source files and the &M-PDD; for <firstterm
 id="D-dirsym">direct symbols</firstterm>, those that are directly
 used by the &D-kit;.  Some of these &D-dirsyms; may be the results of
 probes, which in turn may depend on additional symbols; these
 additional symbols will be added to the &M-TD;. This empty &M-TD; is
 distributed as part of the &D-kit;.</para>

 <para>At tailoring time, &qmconfig; must make sure that all
 &D-dirsyms; have values.  If necessary, probes are executed to get
 values for symbols.  We always prefer values provided by the
 &D-tailor; and we only execute a probe if one of its results does not
 have a value.  Once all &D-dirsyms; have values, the &M-ADAPT; can
 modify and create tailored files.</para>

 <para>We expect the &M-TD; to be stored in &Q-XML; files.  However,
 centralized tailoring databases may be more appropriately referenced
 by a <acronym>URL</acronym>, or stored in an &Q-LDAP; database.
 &D-Kits; tailored using bootstrap scripts will use a small C
 program<footnote> <para>Why C?  We reason that the only time we
 <emphasis>must</emphasis> run a bootstrap script is to tailor
 &Qpython; or one of its prerequisites, and these are programmed in C
 &mdash; so C must be available, or the exercise is moot.</para>
  </footnote>
 to access the &M-TD; and adapt files, so we expect these to
 <emphasis>only</emphasis> support the &Q-XML; local file
 format.</para>

 <figure id="fig-cl-tailorsym" float="1">
  <title>Tailoring Database</title>

  <mediaobject>

   <imageobject>
    <imagedata align="center" width="6in" scalefit="1"
               fileref="cl_tailorsym.png"></imagedata>
   </imageobject>
   <textobject>
    <phrase>Tailoring database</phrase>
   </textobject>

  </mediaobject>
 </figure>

 <para>The module <classname role="module">tailor_sym</classname>
 contains the definitions for symbols and symbol types.  The
 <classname>SymbolType</classname> is a base class for types for
 symbols.  Derived types are used to represent boolean, string, and
 integer values.  We will also want to support enumerations, and
 possibly specialized strings like file names.  The
 <classname>Symbol</classname> class represents symbols.  Besides
 having a name and a type, a symbol also has documentation associated
 with it that can be used to assist the &D-tailor;.  <xref
 linkend="fig-cl-tailorsym"></xref> shows the related class diagrams.

 <programlisting>
 <![CDATA[
class SymbolType:

    """Base class for symbol types."""

    def IsValid(self, val):

        """Test if a value is valid for this type.

        'val' -- Value to be tested.

        returns -- 1 if 'val' is valid for this type; 0 otherwise."""


class ProbeSource:

    """Symbols whose source is a probe store information about the
    source probe and parameters in a "ProbeSource" object."""


    def __init__(self, probe_platform, probe_name, probe_dp, probe_ap):

        """Create the "ProbeSource" object.

        precondition -- 'probe_platform' is a valid execution platform
        for this probe.

        precondition -- 'probe_dp' is valid and complete for this
        probe.

        precondition -- 'probe_ap' is valid and complete for this
        probe on 'probe_platform', with default values to parameters
        already assigned.

        'probe_platform' -- Name of the probe execution platform.

        'probe_name' -- Name of the probe.

        'probe_dp' -- Distinguished parameters for this probe.  This
        is a mapping of parameter names to values.

        'probe_ap' -- Auxiliary parameters for this probe on
        'probe_platform'.  This is a mapping of parameters names to
        values."""


    def GetProbePlatform(self):

        """Get the probe platform for which this probe source is
        valid.

        returns -- A string representing a probe execution
        platform."""



    def GetProbeName(self):

        """Get the name of the probe.

        returns -- Name of the probe used as a source for this
        object."""


    def GetDistinguishedParameters(self):

        """Get the distinguished parameters needed to identify and
        execute this probe.

        returns -- A dictionary mapping parameter names to values
        (which are strings)."""


    def GetAuxiliaryParameters(self):

        """Get the auxiliary parameters needed to execute this probe
        on its execution platform.

        returns -- A dictionary mapping parameter names to values
        (which are strings)."""


class Symbol:

    """Class representing symbols."""

    def __init__(self, symbol_name, symbol_type, def_val,
                 short_doc, long_doc):

        """Define a new symbol.

        'symbol_name' -- Name of the new symbol.

        'symbol_type' -- Type of the new symbol.  $$$ What are our
        types?  Need to be able to include enumerations!

        'def_val' -- Default value for this symbol.

        $$$ Do we want some sort of substitution to take place?  If
        so, then ideally it is Pythonic.  But some of the most useful
        substitutions would take place at tailoring time, making it
        necessary to have Python available then.  Other possibilities
        are a shell-like format, or different versions for different
        probe platforms.

        'short_doc' -- Brief description for this symbol.

        'long_doc' -- Longer description for this symbol."""


    def AddDescription(self, lang, short_doc, long_doc=None):

        """Add a description for this symbol in some natural language.

        'lang' -- Designator for a natural language.

        'short_doc' -- Short documentation string for this symbol,
        presumably written in the natural language indicated by
        'lang'.  (The 'short_doc' string is used when the symbol was
        created is a fallback description.)

        'long_doc' -- Longer documentation string for the symbol,
        again presumably written in the natural language indicated by
        'lang'.  If 'long_doc' is None, then there is no longer
        documentation string."""


    def GetName(self):

        """Get the name of this symbol.

        returns -- The name of the symbol."""


    def GetType(self):

        """Get the type of this symbol.

        returns -- The type of this symbol."""


    def GetDefault(self):

        """Get the default value for this symbol.

        returns -- The default value for this symbol, or None if there
        is no default."""


    def GetShortDescription(self, lang=None):

        """Get the short documentation string for this symbol for the
        specified language.  If not found, return the fallback short
        documentation string.

        'lang' -- Indicate the natural language, or None to get the
        fallback.

        returns -- The short documentation string."""


    def GetLongDescription(self, lang=None):

        """Get the long documentation string for this symbol for the
        specified language.  If not found, return the fallback long
        documentation string.

        'lang' -- Indicate the natural language, or None to get the
        fallback.

        returns -- The long documentation string."""
]]></programlisting></para>

 <figure id="fig-cl-tailor" float="1">
  <title>Tailoring Database</title>

  <mediaobject>

   <imageobject>
    <imagedata align="center" width="6in" scale="50" scalefit="1"
               fileref="cl_tailor.png"></imagedata>
   </imageobject>

   <textobject>
    <phrase>Tailoring database</phrase>
   </textobject>

  </mediaobject>
 </figure>

 <para>The module <classname role="module">tailor_db</classname>
 contains the class definitions for the tailoring database itself,
 illustrated in <xref linkend="fig-cl-tailor"></xref>.
 <programlisting>
<![CDATA[ class TailorDB:
class MetaProbeSource:

    """Information about probe sources, including auxiliary
    parameters, must be stored in the tailoring database, since we
    wish it to be self-contained.  Operations on "MetaSymbol" use
    "MetaProbeSource" objects, so we do not get inconsistencies in
    auxiliary parameters."""

    def __init__(self, probe_source, tdb):

        """Associated 'self' with the 'probe_source' object.

        'probe_source' -- A "ProbeSource" object to be associated with
        'self'.

        'tdb' -- The "TailorDB" object associated with 'self'."""


    def GetProbeSource(self):

        """Get the "ProbeSource" object associated with 'self'.

        return -- The "ProbeSource" object."""


    def IsRequired(self):

        """Determine whether or not the probe must be executed for the
        tailoring database to be usable.  A probe need not be executed
        if there are values for each of the symbols it specifies.

        return -- 1 if the probe is required, 0 otherwise."""


    def ResetProbeResults(self):

        """Reset the values of symbols set by a probe, unless those
        symbols received their values from the tailor.  If there are
        other probes that depend on these symbols, the results of
        those probes are also reset.

        return -- None"""


class MetaSymbolCollector:

    """A collector file holds symbol assignments. For example, a
    header file may be created to hold symbol assignments for a
    collection of related files."""


    def __init__(self, file_name, tdb):

        """Create a "MetaSymbolCollector" object associated with the
        collector file, 'file_name'.

        'file_name' -- The file that will collect the symbol
        definitions.

        'tdb' -- The "TailorDB" object associated with 'self'."""


    def GetFileName(self):

        """Get the name of the file associated with 'self'.

        return -- The file name."""


    def GetCollectedSymbols(self):

        """Get the list of symbols in this collection.  Note that a
        symbol may belong to more than one collection.

        return -- A list of "MetaSymbol" objects representing the
        symbols."""


class MetaSymbol:

    """Symbols in a tailoring database may have values and other
    metadata associated with them.  This class represents these
    symbols, allowing the metadata to be managed.  Note that changes
    to metadata may cause other changes in the tailoring database
    itself."""

    def __init__(self, symbol, tdb):

        """Associate 'symbol' with this "MetaSymbol" object.

        'symbol' -- A "Symbol" object to associate with 'self'.

        'tdb' -- The tailoring database associated with 'self'."""


    def GetSymbol(self):

        """Get the "Symbol" object associated with 'self'.

        return -- The associated "Symbol" object."""


    def SetValueFromTailor(self, val, probe_platform=None):

        """Enter or change a value for a symbol, where the value is
        assigned by the tailor.

        precondition -- 'val' is compatible with the type associated
        with the symbol.

        'val' -- The value being assigned to the symbol.  This is a
        string representing a value.

        'probe_platform' -- A string representing a probe platform.
        If this is None, then the value is set for all probe platforms
        from which this symbol may be defined.

        raise 'TypeError' -- The type of 'symbol_name' is not
        compatible with 'value'.

        return -- None"""


    def SetValueFromProbe(self, val, probe_platform):

        """Enter or change a value for this symbol, where the value is
        a result of executing the probe associated with this symbol on
        a particular probe execution platform.  This has no effect if
        the value of the symbol was already set by the tailor.

        precondition -- 'val' is compatible with the type associated
        with the symbol.

        'val' -- The value being assigned to the symbol.  This is a
        string representing a value.

        'probe_platform' -- A string representing a probe platform.

        raise 'KeyError' -- There is no probe source associated with
        'self' for 'probe_platform'.

        raise 'TypeError' -- The type of the symbol is not compatible
        with 'value'.

        return -- None"""


    def GetValue(self, probe_platform):

        """Get the value of the symbol for a particular probe execution
        platform.

        'probe_platform' -- Name of the probe execution platform for
        which we want the symbol value.

        raise 'KeyError' -- No value, not even a default, is found for
        'probe_platform' in 'self'.

        return -- The value."""


    def ResetValue(self, probe_platform=None):

        """Reset the value of the symbol to its default.  If there are
        probes that depend on those symbols, then the results of those
        probes are also reset.

        'probe_platform' -- Probe execution platform for which we want
        to reset the value.  If this is None, then the value for all
        probe platforms is reset.

        return -- None"""


    def IsValueSet(self, probe_platform):

        """Determine whether or not a symbol has been assigned a
        value for a particular probe platform.

        'probe_platform' -- Name of the probe execution platform to be
        tested.

        return -- 1 if there is a value associated with
        'probe_platform', 0 otherwise."""


    def IsValueFromTailor(self, probe_platform):

        """Determine whether or not a symbol has been assigned a value
        by a tailor.  This is true, even if we inherit the value from
        another tailoring database in which the value had been
        assigned by a tailor.

        'probe_platform' -- Name of the probe execution platform to be
        tested.

        return -- 1 if there is a value associated with
        'probe_platform' that was set by a tailor, 0 otherwise."""


    def IsValueFromProbe(self, probe_platform):

        """Determine whether or not a symbol has received a value
        computed by executing a probe.  This is true, even if we
        inherit the value from another tailoring database in which the
        value had been assigned by a executing a probe.

        'probe_platform' -- Name of the probe execution platform to be
        tested.

        return -- 1 if there is a value associated with
        'probe_platform' that was set by a probe, 0 otherwise."""


    def IsRequired(self):

        """Determine whether or not a symbol must be assigned a value.
        If a symbol is only required for probes that will not be
        executed, then no value need be assigned to that symbol in
        order to tailor.

        return -- 1 if the symbol is required, 0 otherwise."""


    def MakeDirect(self):

        """Indicate that this symbol is directly required by the
        project.  This means that it is used in one of the source
        files, build scripts, etc. (as opposed to being needed only by
        other probe scripts).  The project cannot be constructed
        unless a value is assigned to this symbol.

        return -- None"""


    def AddProbeConsumer(self, mps):

        """Indicate that this symbol is required by 'probe_source'.

        precondition -- 'mps' is associated with the same "TailorDB"
        object as 'self'.

        'mps' -- A "MetaProbeSource" object, representing a probe that
        requires this symbol.

        return -- None"""


    def AddProbeSource(self, mps):

        """Indicate that this symbol can be set by 'mps'.

        precondition -- 'mps' is associated with the same "TailorDB"
        object as 'self'.

        'mps' -- A "MetaProbeSource" object representing the source.

        return -- None"""


    def AddSymbolCollector(self, msc):

        """Add this symbol to a symbol collector.

        precondition -- 'msc' is associated with the same "TailorDB"
        object as 'self'.

        'msc' -- A "MetaSymbolCollector" with which this symbol will
        be associated."""


class TailorDB:

    """Base class for tailoring databases.  Instances of these classes
    represent tailoring databases.  Project may be tailored using a
    set of tailoring databases."""


    # Basic operations.

    def DeriveFrom(self, tdb):

        """Add a base tailoring database to this database.  This
        relationship persists until 'self' is closed.  Any symbol in
        'self' that has not been assigned a value will inherit its
        value from 'tdb', if the corresponding symbol in 'tdb' has the
        same symbol type and has an assigned value.  (If the value is
        defaulted in both 'self' and 'tdb', then the default in 'self'
        prevails.)

        'tdb' -- The base tailoring database from which this database
        will inherit values."""


    def Update(self, tdb):

        """Update the values stored in 'self' from 'tdb'.  Only values
        in 'self' for which there are definitions will be updated, and
        only if the type of a symbol in 'self' matches the type from
        'tdb', and only if the value of a symbol in 'self' is the
        default, but is an assigned value in 'tdb'.

        'tdb' -- The tailoring database from which this database will
        obtain values.

        return -- None"""


    def Clear(self):

        """Empty this tailoring database, including all definitions.
        This does not break any "DeriveFrom" relationships, but it
        does remove the effects of any "Update" operations.  This
        operation is needed if the tailoring database must be
        recreated."""


    def ResetAllSymbols(self):

        """Reset the values of all symbols to their defaults.

        return -- None"""


    def ResetAllProbeResults(self):

        """Reset the values of all symbols that were set as the result
        of a probe operation.

        return -- None"""


    def Commit(self):

        """Commit all changes to the actual database representing
        'self'.

        raise 'IOError' -- The database cannot be written.

        return -- None"""


    # Operations of symbols and their metadata.


    def AddSymbol(self, symbol):

        """Add a new symbol to the tailoring database.

        precondition -- There is not already a symbol with the same
        name as 'symbol'.

        'symbol' -- A Symbol object representing the symbol.  The name
        of the symbol comes from this object.

        raise $$$ -- Already a symbol with this name.

        postcondition -- The is now a symbol in the database with the
        name taken from 'symbol'.

        return -- The "MetaSymbol" object associated with this
        symbol."""


    def AddProbeSource(self, probe_source):

        """Add a probe source to the tailoring database.

        precondition -- There is not already a probe source with the
        same probe name, distinguished parameters, and probe platform
        as 'probe_source'.

        'probe_source' -- The "ProbeSource" object to add to 'self'.

        raise 'KeyError' -- There already is a "ProbeSource" object
        with the same probe name, distinguished parameters, and probe
        platform.

        return -- The "MetaProbeSource" object to use for associating
        the probe source with symbols."""


    def AddSymbolCollector(self, file_name):

        """Add a symbol collector file to the tailoring database.

        precondition -- There is not already a symbol collector
        associated with 'file_name'.

        'file_name' -- Name of the file to collect the symbol
        definition.

        raise 'KeyError' -- There already is a symbol collector named
        'file_name'.

        return -- The "MetaSymbolCollector" object to use for
        associating symbols with 'file_name'."""


    def GetMetaSymbol(self, symbol_name):

        """Get the "MetaSymbol" object named 'symbol_name'.

        precondition -- There is a symbol in this database named
        'symbol_name'.

        'symbol_name' -- Name of the Symbol object.

        raise 'KeyError' -- No symbol named 'symbol_name'.

        return -- The Symbol object."""


    def GetMetaProbeSource(self, probe_name, probe_dp, probe_platform):

        """Get a "MetaProbeSource" object identified by the probe
        name, distinguished parameters, and probe execution platform.

        precondition -- There is a probe source with these attributes.

        'probe_name' -- Name of the probe.

        'probe_dp' -- Distinguished parameters identifying this probe.
        This is a dictionary mapping names to values (strings).

        'probe_platform' -- A string identifying the execution
        platform.

        raise 'KeyError' -- ('probe_name', 'probe_dp',
        'probe_platform') do not identify a registered probe source.

        return -- A "MetaProbeSource" object."""


    def GetMetaSymbolCollector(self, file_name):

        """Locate a "MetaSymbolCollector" object associated with a
        file.

        precondition -- 'file_name' has been registered as a symbol
        collector.

        'file_name' -- Name of the file being used as a symbol
        collector.

        raise 'KeyError' -- 'filename' has not been designated as a
        symbol collector.

        return -- A "MetaSymbolCollector" object."""


    def GetAllDirectSymbols(self):

        """Get a list of all direct symbols.

        return -- A list of "MetaSymbol" objects."""


    def GetAllSymbols(self):

        """Get a list of all the symbols in the tailoring database.

        return -- A list of "MetaSymbol" objects."""


    def GetAllProbeSources(self):

        """Get a list of all the probe sources associated with this
        tailoring database.

        return -- A list of "MetaProbeSource" objects."""


    def GetAllSymbolCollectors(self):

        """Get a list of all the symbol collectors associated with
        this tailoring database.

        return -- A list of "MetaSymbolCollector" objects."""


class TailorDBXML(TailorDB):

    """Tailoring databases stored as XML."""


class TailorDBXMLFile(TailorDBXML):

    """Tailoring databases, stored as XML, in simple files."""

    def __init__(self, file_name):

        """Constructor for a TailorDB object.

        'file_name' -- Name of a file containing a tailoring
        database."""
]]></programlisting></para>

</section>

<!--
  Local Variables:
  mode: sgml
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("qmconfig.xml" "book" "chapter" "section")
  End:
-->
