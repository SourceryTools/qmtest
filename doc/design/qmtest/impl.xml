<?xml version="1.0"?>
<!--

  File:   core.xml
  Author: Mark Mitchell, Greg Wilson, Alex Samuel
  Date:   2000-11-01

  Contents:
    Core QMTest implementation.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<chapter id="impl"><title>Implementation</title>
  
 <para>This chapter describes the Python classes that correspond to
 the major &qmtest; <link linkend="concepts">concepts</link>.  Most of
 these classes are designed as polymorphic classes that can be
 replaced by users to create customized testing environments.
 Therefore, the information provided here does not go beyond the
 interfaces of these classes; a valid implementation of each class
 must provide at least the functionality described in these
 interfaces.</para>

  <section><title>Major Classes</title>

  <para>The most important classes provided by the
  <classname>QMTest</classname> package are
  <classname>Engine</classname>, <classname>Suite</classname>,
  <classname>Test</classname>, <classname>Result</classname>,
  <classname>Filter</classname>.  

  The <classname>Engine</classname> class traverses the tree of suites
  and tests specified by the user.  It performs setup and cleanup,
  filters tests based on the users' criteria (if any), runs tests, and
  collates their results.  Users do <emphasis>not</emphasis> override
  the <classname>Engine</classname> class. </para>

  <para>The <classname>Suite</classname> and
  <classname>Test</classname> classes provide information about suites
  and tests respectively.  Both are derived from an abstract class
  <classname>QMTest.Testable</classname>, so that they share methods
  such as <classname>setup</classname>,
  <classname>cleanup</classname>, <classname>getProperty</classname>,
  <classname>run</classname>, and so on. </para>

  <para>The <classname>Suite</classname> class has a method
  <classname>getChildren</classname>, which returns a list of the
  tests and suites it contains.  This method may return an empty list
  (e.g. if it is a placeholder while tests are being written, or if
  none of its children survive filtering).  If this method returns
  <classname>None</classname>, however, the execution engine will then
  try to iterate on the suite object, using the standard Python
  iteration protocol.  This allows dynamic generation of large numbers
  (millions) of tests without excessive memory requirements; it also
  simplifies task farming of parallelizable tests. Note that the
  engine does <emphasis>not</emphasis> guarantee to execute tests in the order
  in which the suite provides them, as it may need to delay execution
  of a test until its prerequisites have been run. </para>

  <para>The <classname>Result</classname> class is purely
  informational. A single instance of this class is returned each time
  <classname>QMTestable.run</classname> is called.  The
  <classname>Engine</classname> class translates the
  <classname>Result</classname> instance into a test database
  record. </para>

  <para>The <classname>Filter</classname> class encapsulates a
  function which produces a Boolean result from a test's properties,
  the current state of the engine, and the contents of the test
  database. </para>

  </section>

  <section><title>Execution Model</title>

  <para>The engine works by translating the contents of input files
  into instances of appropriate classes, running the instance methods,
  and capturing any <classname>Result</classname> objects that are
  produced. </para>

   <section><title>Invoking Instance Methods</title>

   <para>As an input file is translated into one or more class
   instances, the engine passes those instances through its filters.
   The prerequisites of any objects which survive filtering are then
   examined.  If those prerequisites have already been satisfied, the
   object is placed in the engine's "ready" pool.  If they have not,
   the object is placed in the engine's "ready" pool.</para>

   <para>The engine repeatedly removes items from its "ready" pool,
   and invokes their setup, execution, and cleanup methods in order.
   The execution of a test produces a result object; the execution of
   a suite produces more objects for the "pending" and "ready" pools.
   Once an object's cleanup method has been executed, the engine
   checks its "pending" pool to see whether any pending objects are
   now ready.  If so, it moves them to its ready pool.  If at any
   point the ready pool is empty, and there are items in the pending
   pool, "DEFERRED" records are created for them, with "unsatisfied
   prerequisite" listed as a reason. </para>

   </section>

   <section><title>Capturing Results</title>

   <para>As with input, the simplest way for a test or suite to report
   results from the engine's point of view is for it to explicitly
   create a <classname>Result</classname> object.  However, this is a
   burden for novice test authors, and is not even be possible for
   tests written in other languages, or which are specified using flat
   text or XML. </para>

   <para>The raw results of executing a test (including exit status,
   return value, and standard stream output) are therefore passed to a
   <classname>Translator</classname> object.  This object then creates
   a <classname>Result</classname>, which is passed in turn to the
   engine.  Translators are stacked, in the same way as environment
   changes, so that suites and individual tests can safely specify how
   to interpret their results.  Any translators specified in setup
   methods are automatically removed during cleanup.</para>

  </section>

  </section>

 <section><title>Test representation</title>
   
  <section><title>Test class implementations</title>

   <para>Each &qmtest; test class is implemented as a Python class.
   Though &qmtest; does not recognize any notion of test class
   inheritance, this may be produced in effect via Python class
   inheritance.</para>

   <para>A test class should have the following members:
    <itemizedlist>
     <listitem>
      <para>An initialization method (<function>__init__</function>),
      that is used to instantiate test instances.  Test instances are
      Python instances of the Python class corresponding to the test
      class.  The parameters of the <function>__init__</function>
      method are the test class parameters.  All parameters must be
      named; positional parameters are not allowed.  A final
      <token>**</token> parameter is allowed.</para>

      <para>If a new test class is created via inheritance from a
      previous test class, the derived <function>__init__</function>
      is expected to invoke the base class
      <function>__init__</function>, passing unused parameters.</para>
     </listitem>

     <listitem>
      <para>An <function>is_valid</function> method.  This method
      takes a <classname>Configuration</classname> object and returns
      as boolean whether the particular test instance is appropriate
      to run on that configuration.</para>
     </listitem>

     <listitem>
      <para>A <function>run</function> method.  The
      <function>run</function> method is passed the same configuration
      that was previously validated by the same test instance's
      <function>is_valid</function> method.
      <!-- FIXME: What are the parameters to the run method? -->
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>After this point, we will use the term test to refer to the
   corresponding Python class sometimes, when there is no
   ambiguity.</para>

   <para>Instantiating a test instance requires locating and
   instantiating test class.  This is done via these two methods:
    <orderedlist>
     <listitem>
      <para>The test class is located in the Python execution
      environment in the usual way, using the
      <envar>PYTHONPATH</envar> mechanism.</para>
     </listitem>

     <listitem>
      <para>If the class has not been found, the test is asked to
      locate the test class.  The test database is provided with the
      name of the test class and also with the test identifier being
      instantiated.  (This allows the test database to handle relative
      paths in its conceptual tree, between the test id and the test
      class.)</para>
     </listitem>
    </orderedlist>
  </para>

  </section>

  <section><title>Test records</title>

   <para>Test records are represented by instances of the class
   <classname>&qmtest;.TestRecord</classname>.  This class has the
   following members:</para>

   <para><programlisting>
<![CDATA[
class TestRecord:
   """The canonical representation of a test."""

   def GetId(self):
       """Return the test id of this test."""

   def GetClassName(self):
       """Return the name of the test class of which this is an
       instance."""

   def GetArguments(self):
       """Returns the arguments to the test class.  Arguments are
       presented as a mapping from text argument names to argument
       values.  Argument values are text Python expressions."""

   def GetCategories(self):
       """Return a sequence of names of categories to which this test
       belongs."""

   def GetPrerequisites(self):
       """Return a sequence of pairs representing prerequisite tests
       for this test.  The first element of the pair is the test id
       of the prerequisite test.  The second element is the outcome
       that that test must produce for the prerequisite to be
       considered met.  If the second element is None, any outcome is
       considered sufficient."""

   def GetPreactions(self):
       """Return a sequence of action ids of actions that must be run
       and produce a successful outcome before this test is run."""

   def GetPostactions(self):
       """Return a sequence of action ids of actions that must be run
       after this test is run."""

   def GetDesignTimeArguments(self):
       """Fix me."""
]]>
   </programlisting></para>
   
   <para>Note that test record objects are not polymorphic, regardless
   of the test class of the test.</para>

   <para>Test records are the representation of tests that are stored
   in and returned by test databases.  Most test database
   implementations will externalize test records to a persistent
   store.  The preferred text-based format for doing this is
   XML.</para>

  </section>

  <section><title>Test instances</title>

   <para>A <firstterm>test instance</firstterm> is an instance of a
   test classes.  For a test to be run, a test instance must be
   created.  To do this, the test class is first obtained from the
   test class name stored in the test record.  The test arguments are
   extracted from the test record and evaluated in the test-time
   execution context.  The results are passed to the initialization
   function of the test class to create the instance.  To run the
   test, the instance's run method is invoked.</para>
   
  </section>

 </section>

 <section>
  <title>The test system</title>

  <section><title>Action implementation</title>

   <para>
   <!-- FIXME: Same as test implementation, except we do somethign
   different with the outcomes, right?  Or is there a different set
   of outcomes for actions? -->
   </para>

  </section>

  <section><title>Test result implementation</title>

   <para></para>

  </section>

 </section>

</chapter>

<!--
  Local Variables:
  mode: sgml
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("qmtest.xml" "book" "chapter")
  End:
-->
