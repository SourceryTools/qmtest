<?xml version="1.0"?>
<!--

  File:   triggers.xml
  Author: Alex Samuel
  Date:   2000-11-20

  Contents:
    Section `Triggers' of qmtrack design document.

  This is part of the master document contained in qmtrack.xml.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
 <section id="chap-triggers">
  <title>Triggers</title>

  <para><firstterm id="def-trigger">Triggers</firstterm> provide a
  mechanism for extending a &qmtrack; issue database in two important
  ways.
  <orderedlist>
    <listitem>
     <para>A trigger can be used to impose a constraint on the issue
     database.  For instance, a trigger can check that a certain
     condition is fulfilled before allowing a modification to the
     issue database.</para>
    </listitem>

    <listitem>
     <para>A trigger can be used to implement issue database policies
     and workflow by invoking operations in response to user
     actions.</para>
    </listitem>
   </orderedlist>
  </para>

  <para>A trigger, conceptually, is a Python function which is
  executed when the &idb; is accessed.  A trigger is registered with
  the &idb; as one of three trigger types:
   <orderedlist>
    <listitem>
     <para>A <literal>"get"</literal> trigger is called before an
     issue is returned from a query or another issue retrieval
     operation.  The trigger may produce side effects related to the
     operation, such as gathering query statistics, or veto the
     operation, for instance to implement access control.</para>
    </listitem>

    <listitem>
     <para>A <literal>"preupdate"</literal> trigger is called before
     an update to an issue takes place.  The trigger will usually not
     produce any side effects, but may veto the update if it is
     invalid, inappropriate, or unauthorized, or may modify the
     updated record itself.</para>
    </listitem>

    <listitem>
     <para>A <literal>"postupdate"</literal> trigger is called after
     an update to an issue takes place.  The trigger takes actions
     based on the update, such as notifying interested parties.</para>
    </listitem>
   </orderedlist>
  </para>

  <para>Triggers are one of the most important ways of extending and
  customizing &qmtrack;.  In particular, triggers are design to make
  the implementation of procedural and workflow practices easy.  The
  following sections describe triggers which will be part of the
  standard &qmtrack; system and will implement important features
  expected by issue tracking users.</para>

  <section id="sec-state-model">
   <title id="sec-state-model-title">State model</title>

   <para>Bug tracking systems typically include the notion of
   <firstterm id="def-state">state</firstterm>.  Most projects and
   organizations have a formal or informal workflow process, which
   structures the submission, processing, and retirement of isssues.
   An issue's state reflects its status or position in this workflow
   process.</para>

   <para>In &qmtrack;, the workflow process is represented by a finite
   state machine.  Each issue must be in one state of the state model,
   and only transitions along arcs in the state model are permitted
   (except perhaps in exceptional circumstances).</para>

   <para><xref linkend="example-state-model"/> shows a simple
   state model example that might be used to represent a project's bug
   tracking workflow.  Newly-reported bugs are placed in the "New"
   state.  Once a bug is reproduced, it is assigned, then resolved and
   verified.  Once the resolution is accepted by the user, the bug is
   placed in the "Closed" state.  If a new bug cannot be reproduced,
   it is placed immediately into the "Unreproducible" state.
   Periodically, "Closed" and "Unreproducible" bugs may be moved into
   the "Deleted" state; though not actually deleted from the &idb;,
   "Deleted" issued are automatically excluded from queries, reports,
   and issue listings.</para>

   <example id="example-state-model">
    <title>Sample state model</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="state-model-example.png" format="PNG"
      scale="50"/>
     </imageobject>
    </mediaobject>
   </example>

   <para>The state of an issue is represented by the
   <literal>state</literal> <link
   linkend="sec-mandatory-fields">mandatory field</link>.  This field
   is an enumeration of allowed state values.  The state model is
   enforced by a preupdate trigger, whiche examines the state of the
   issue before the proposed update and after.  If the two states
   differ and the transition is not along an arc in the state model,
   the trigger vetoes the update.</para>

   <para>&qmtrack; will provide an out-of-the-box state model,
   carefully designed by software quality experts, which will be
   appropriate for bug tracking in small and medium-sized projects.
   This will encourage users with little experience of quality
   managment process to utilize the additional structure of the state
   model system.  Advanced users or those using &qmtrack; for other
   purposes will have the opportunity to customize the state model to
   their particular needs and their project's processes.</para>

   <para>Even installations which do not impose an issue workflow that
   can be represented by a state model will use &qmtrack;'s state
   mechanism.  For such users, a simple two-state model consisting of
   "Active" and "Deleted" will allow bugs to be deleted as described
   above.</para>

  </section>

  <section id="sec-notification">
   <title id="sec-notification-title">Notification</title>

   <para>&qmtrack;'s user interfaces will provide flexible
   "pull" methods of communication, with which users can examine the
   state of the system and other users' actions.  Most workflow models
   will require "push" communication capabilities as well, in which
   users are notified about actions taken in the system.</para>

   <para>&qmtrack; provides two schemes for notification by e-mail.
   E-mail is an obvious choice for this, since it is the
   <foreignphrase>de facto</foreignphrase> and ubiquitous messaging
   system used by computer workers.  (Non e-mail-based systems may
   also be implemented next to or on top of the e-mail-based
   notification systems.)</para>

   <para>&qmtrack; supports traditional rule-based notification of
   &idb; actions.  Using a "postupdate" trigger, &qmtrack; will notify
   one or several parties of changes to the &idb; by sending an e-mail
   message.  The trigger may be configured to notify users selectively
   based on which issue is updated or the nature of the update, using
   the <link linkend="sec-queries">query expression syntax</link>.
   Graphical configuration will allow the &idb; administrator to
   specify notification rules without writing any code.</para>

   <para>&qmtrack; can also supports a dynamic "<firstterm
   id="def-nosy-list">nosy list</firstterm>" notification scheme.  A
   nosy list is a list of &qmtrack; users who are interested in being
   notified of changes to a particular issue.  The issue incorporates
   a <literal>nosy_list</literal> <link
   linkend="sec-standard-fields">standard field</link>, which lists
   these users' &uid;s.  The nosy list is implemented with a
   "postupdate" trigger, which sends e-mail notification to users on
   an issue's nosy list when the issue is updated.  The trigger may
   also be configured to maintain the nosy list automatically, by
   placing any user on the nosy list who modifies an issue.</para>

  </section>

  <section id="sec-access-control">
   <title id="sec-access-control-title">Access control</title>

   <para>Often, an organization or project may wish to restrict access
   and modification of the issue database under certain
   circumstances.  For instance,
    <itemizedlist>
     <listitem>
      <para>End-users may only create, but not modify, bug
      reports.</para>
     </listitem>

     <listitem>
      <para>End-users may only view bug reports that they have
      submitted.</para>
     </listitem>

     <listitem>
      <para>Certain issue fields are visible only to
      management.</para>
     </listitem>

     <listitem>
      <para>A developer may only change issues that relate to her area
      of responsibility in the project.</para>
     </listitem>

     <listitem>
      <para>Only testers may change a bug report's state to
      "Verified".</para>
     </listitem>

     <listitem>
      <para>Only administrators may delete an issue.</para>
     </listitem>
    </itemizedlist>
   Such resrictions represent controls on the workflow in the project
   or organization, and must be enforced by &qmtrack;.</para>

   <para>Access control is implemented in &qmtrack; via "get" and
   "preupdate" triggers.  The "get" trigger examines each query for
   authorization, and vetoes any issues that the user is not allowed
   to access.  If the user is authorized to access some but not all
   fields of the issue, the trigger removes the values of those fields
   the user may not access.  The "update" trigger examines whether the
   user is authorized to make the particlar update to the issue.  If
   not, the trigger vetoes the update.</para>

   <para>The authorization triggers will be configurable, without any
   programming, to enforce these types of authorization restrictions:
    <orderedlist>
     <listitem>
      <para>Read and read-write access to individual issues based on
      the field contents, using the <link linkend="sec-queries">query
      expression syntax</link>.</para>
     </listitem>

     <listitem>
      <para>Read and read-write access to individual fields based on
      the field contents.</para>
     </listitem>
    </orderedlist>
   </para>

  </section>

 </section>
 
<!--
  Local Variables:
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("qmtrack.xml" "chapter" "section")
  End:
-->
