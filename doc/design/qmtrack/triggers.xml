<?xml version="1.0"?>
<!--

  File:   triggers.xml
  Author: Alex Samuel
  Date:   2000-11-20

  Contents:
    Section `Triggers' of qmtrack design document.

  This is part of the master document contained in qmtrack.xml.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
 <section id="chap-triggers">
  <title>Triggers</title>

  <para><firstterm id="def-trigger">Triggers</firstterm> provide a
  mechanism for extending a &qmtrack; issue database in two important
  ways.
  <orderedlist>
    <listitem>
     <para>A trigger can be used to impose a constraint on the issue
     database.  For instance, a trigger can check that a certain
     condition is fulfilled before allowing a modification to the
     issue database.</para>
    </listitem>

    <listitem>
     <para>A trigger can be used to implement issue database policies
     and workflow by invoking operations in response to user
     actions.</para>
    </listitem>
   </orderedlist>
  </para>

  <para>A trigger, conceptually, is a Python function which is
  executed when the &idb; is accessed.  A trigger is registered with
  the &idb; as one of three trigger types:
   <orderedlist>
    <listitem>
     <para>A <firstterm id="def-get-trigger">get trigger</firstterm>
     is called before an issue is returned from a query or another
     issue retrieval operation.  The trigger may produce side effects
     related to the operation, such as gathering query statistics, or
     veto the operation, for instance to implement access
     control.</para>
    </listitem>

    <listitem>
     <para>A <firstterm
     id="def-preupdate-trigger">preupdate trigger</firstterm> is
     called before an update to an issue takes place.  The trigger
     will usually not produce any side effects, but may veto the
     update if it is invalid, inappropriate, or unauthorized, or may
     modify the updated record itself.</para>
    </listitem>

    <listitem>
     <para>A <firstterm
     id="def-postupdate-trigger">postupdate trigger</firstterm> is
     called after an update to an issue takes place.  The trigger
     takes actions based on the update, such as notifying interested
     parties.</para>
    </listitem>
   </orderedlist>
  </para>

  <para>Triggers are one of the most important ways of extending and
  customizing &qmtrack;.  In particular, triggers are design to make
  the implementation of procedural and workflow practices easy.  The
  following sections describe triggers which will be part of the
  standard &qmtrack; system and will implement important features
  expected by issue tracking users.</para>

  <section id="sec-state-model">
   <title id="sec-state-model-title">State model</title>

   <para>Bug tracking systems typically include the notion of
   <firstterm id="def-state">state</firstterm>.  Most projects and
   organizations have a formal or informal workflow process, which
   structures the submission, processing, and retirement of issues.
   An issue's state reflects its status or position in this workflow
   process.</para>

   <para>In &qmtrack;, the workflow process is represented by a finite
   state machine.  Each issue must be in one state of the state model,
   and only transitions along arcs in the state model are permitted
   (except perhaps in exceptional circumstances).</para>

   <para><xref linkend="example-state-model"/> shows a simple
   state model example that might be used to represent a project's bug
   tracking workflow.  Newly-reported bugs are placed in the "New"
   state.  Once a bug is reproduced, it is assigned, then resolved and
   verified.  Once the resolution is accepted by the user, the bug is
   placed in the "Closed" state.  If a new bug cannot be reproduced,
   it is placed immediately into the "Unreproducible" state.
   Periodically, "Closed" and "Unreproducible" bugs may be moved into
   the "Deleted" state; though not actually deleted from the &idb;,
   "Deleted" issued are automatically excluded from queries, reports,
   and issue listings.</para>

   <example id="example-state-model">
    <title>Sample state model</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="state-model-example.png" format="PNG"
      scale="50"/>
     </imageobject>
    </mediaobject>
   </example>

   <para>The state of an issue is represented by the
   <literal>state</literal> <link
   linkend="sec-mandatory-fields">mandatory field</link>.  This field
   type is an enumeration of allowed state values.  The state model is
   enforced by a preupdate trigger, which examines the state of the
   issue before the proposed update and after.  If the two states
   differ and the transition is not along an arc in the state model,
   the trigger vetoes the update.</para>

   <para>&qmtrack; will provide an out-of-the-box state model,
   carefully designed by software quality experts, which will be
   appropriate for bug tracking in small and medium-sized projects.
   This will encourage users with little experience of quality
   management process to utilize the additional structure of the state
   model system.  Advanced users or those using &qmtrack; for other
   purposes will have the opportunity to customize the state model to
   their particular needs and their project's processes.</para>

   <para>Even installations which do not impose an issue workflow that
   can be represented by a state model will use &qmtrack;'s state
   mechanism.  For such installations, a simple two-state model
   consisting of "Active" and "Deleted" will allow bugs to be deleted
   as described above.</para>

  </section>

  <section id="sec-notification">
   <title id="sec-notification-title">Notification</title>

   <para>&qmtrack;'s user interfaces will provide flexible
   "pull" methods of communication, with which users can examine the
   state of the system and other users' actions.  Most workflow models
   will require "push" communication capabilities as well, in which
   users are notified about actions taken in the system.</para>

   <para>&qmtrack; provides two schemes for notification by e-mail.
   E-mail is an obvious choice for this, since it is the
   <foreignphrase>de facto</foreignphrase> and ubiquitous messaging
   system used by computer workers.  (Non e-mail-based systems may
   also be implemented next to or on top of the e-mail-based
   notification systems.)</para>

   <para>&qmtrack; supports traditional rule-based notification of
   &idb; actions.  Using a postupdate trigger, &qmtrack; will notify
   one or several parties of changes to the &idb; by sending an e-mail
   message.  The trigger may be configured to notify users selectively
   based on which issue is updated or the nature of the update, using
   the <link linkend="sec-queries">query expression syntax</link>.
   Graphical configuration will allow the &idb; administrator to
   specify notification rules without writing any code.</para>

   <para>&qmtrack; can also supports a dynamic <firstterm
   id="def-nosy-list">notification list</firstterm> scheme.  A
   notification list is a list of &qmtrack; users who are interested
   in being notified of changes to a particular issue.  The issue
   incorporates a <literal>notification_list</literal> <link
   linkend="sec-standard-fields">standard field</link>, which lists
   these users' &uid;s.  The notification list is implemented with a
   postupdate trigger, which sends e-mail notification to users on
   an issue's notification list when the issue is updated.  The
   trigger may also be configured to maintain the nosy list
   automatically, by placing any user on the notification list who
   modifies an issue.</para>

  </section>

  <section id="sec-access-control">
   <title id="sec-access-control-title">Access control</title>

   <para>Often, an organization or project may wish to restrict access
   and modification of the issue database under certain
   circumstances.  For example,
    <itemizedlist>
     <listitem>
      <para>End-users may only create, but not modify, bug
      reports.</para>
     </listitem>

     <listitem>
      <para>End-users may only view bug reports that they have
      submitted.</para>
     </listitem>

     <listitem>
      <para>Certain issue fields are visible only to
      management.</para>
     </listitem>

     <listitem>
      <para>A developer may only change issues that relate to her area
      of responsibility in the project.</para>
     </listitem>

     <listitem>
      <para>Only testers may change a bug report's state to
      "Verified".</para>
     </listitem>

     <listitem>
      <para>Only administrators may delete an issue.</para>
     </listitem>
    </itemizedlist>
   Such restrictions represent controls on the workflow in the project
   or organization, and must be enforced by &qmtrack;.</para>

   <para>Access control is implemented in &qmtrack; via get and
   preupdate triggers.  The get trigger examines each query for
   authorization, and vetoes any issues that the user is not allowed
   to access.  If the user is authorized to access some but not all
   fields of the issue, the trigger hides the values of those fields
   the user may not access.  The preupdate trigger examines whether
   the user is authorized to make the particular update to the issue.
   If not, the trigger vetoes the update.</para>

   <para>The authorization triggers will be configurable, without any
   programming, to enforce these types of authorization restrictions:
    <orderedlist>
     <listitem>
      <para>Read and read-write access to individual issues based on
      the field contents, using the <link linkend="sec-queries">query
      expression syntax</link>.</para>
     </listitem>

     <listitem>
      <para>Read and read-write access to individual fields based on
      the field contents.</para>
     </listitem>
    </orderedlist>
   </para>

  </section>

 </section>
 
<!--
  Local Variables:
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("qmtrack.xml" "chapter" "section")
  End:
-->
