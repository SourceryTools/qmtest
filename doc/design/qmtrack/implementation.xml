<?xml version="1.0"?>
<!--

  File:   implementation.xml
  Author: Alex Samuel
  Date:   2000-11-07

  Contents:
    Chapter `Implementation' of qmtrack design document.

  This is part of the master document contained in qmtrack.xml.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<chapter id="chap-implementation">
 <title id="chap-implementation-title">Implementation</title>

 <para>This section describes the Python &api;s which are satisfied by
 the principal components of the &qmtrack; system.  These components
 correspond to the concepts presented in <xref
 linkend="chap-concepts"/>.</para>

 <section id="sec-issue-class-api">
  <title id="sec-issue-class-api-title">Issue Classes</title>

  <section>
   <title>Issue Fields</title>

   <para>Each field in an issue class is represented by an instance of
   a subclass of <classname>IssueField</classname>.  The particular
   subclass determines the type of the field.  For instance, an
   <classname>IssueFieldInteger</classname> instance represents an
   integer field, an <classname>IssueFieldText</classname> instance
   represents a text field, etc.</para>

   <section>
    <title>Attributes</title>

    <para>In addition, each field incorporates a set of attributes.
    Attributes are simply mappings from attributes names (strings) to
    string values (the <literal>"contents"</literal> attribute of a
    set field, described <link
    linkend="sec-issuefieldset">below</link> is a special-case
    exception).  An attribute applies to a field of an issue class,
    not to the issues in that issue class or the issues' field values.
    A single field of an issue class may include several attributes.
    For boolean attributes, the value is either
    <literal>"true"</literal> or <literal>"false"</literal>.</para>

    <para>Modules written to extend &qmtest; may define additional
    attributes, with which to attach hints or other information to
    issue fields.</para>

    <para>Each field has a an attribute called
    <literal>"name"</literal>, which contains the name of the field.
    Other attributes are used for various properties of other field
    types.  Some attributes are used as hints, providing information
    to the &qmtrack; user interface implementations and database
    implementations about how the field value should be displayed and
    stored, respectively.  Extensions to &qmtrack; may define and use
    additional attributes as well.</para>

    <para>The "read-only" attribute may be defined for any field.  If
    defined to a true value, a user may not change the value of that
    field for any issue after that issue has been created.</para>

   </section>

   <section>
    <title><classname>IssueField</classname></title>

    <para><classname>IssueField</classname> is the base class for
    other field types.</para>

    <programlisting>
<![CDATA[
class IssueField:
    """Base class for issue field types."""

    def __init__(self, name):
        """Create a new (generic) field.

        Sets the '"name"' attribute to 'name'."""


    def GetName(self):
        """Return the name of the field."""

        return self.GetAttribute("name")


    def GetAttribute(self, attribute_name, default_value=""):
        """Return the value of an attribute.

        Return the value of the attribute named by 'attribute_name'.
        If that attribute is not set, return 'default_value'."""


    def SetAttribute(self, attribute_name, attribute_value):
        """Set the value of an attribute."""


    def UnsetAttribute(Self, attribute_name):
        """Remove an attribute."""
]]>
    </programlisting>
   </section>

   <section>
    <title><classname>IssueFieldInteger</classname></title>

    <para>An instance of <classname>IssueFieldInteger</classname>
    represents an integer field.  The field must be able to store at
    least a 32-bit signed value.  Values for this field type are
    represented in memory as ordinary Python integers.</para>

    <programlisting>
<![CDATA[
class IssueFieldInteger(IssueField):

    def __init__(self, name):
        """Create an integer field.

        The field must be able to represent a 32-bit signed
        integer."""
]]>
    </programlisting>

   </section>

   <section>
    <title><classname>IssueFieldText</classname></title>

    <para>An instance of <classname>IssueFieldText</classname>
    represents a field that contains text.  There is no restriction on
    the length of the field contents.  Values of this field type are
    represented in memory as ordinary Python strings.</para>

    <programlisting>
<![CDATA[
class IssueFieldText(IssueField):
    """A field that contains text.  

    A text field uses the following attributes:

    '"multiline"' -- If true, the field may contain line breaks, and
    is presented to the user accordingly.

    '"verbatim"' -- If true, the contents of the field are quoted as a
    block when the field is externalized; otherwise, individual
    characters are quoted as required by the externalizaton mechanism.

    '"big"' -- This is a hint that, if true, recommends to issue
    database mechanisms that the contents of the field may be large
    and should be stored out-of-line."""

    def __init__(self, name):
        """Create a text field."""
]]>
    </programlisting>

    <para>The <literal>"verbatim"</literal> attribute is used to flag
    a field that typically will contain text incorporating punctuation
    characters that may need to be quoted, for example program source
    code.  An &idb; implementation may choose to quote the entire
    contents, rather than escaping individual punctuation separately.
    For instance, an &xml;-based &idb; implementation might store the
    field contents inside a marked CDATA section
    ("<literal>&lt;![CDATA[ ... ]]&gt;</literal>").</para>

    <para>The <literal>"big"</literal> attribute flags that the
    contents of the field may be quite large.  An &idb; implementation
    may choose to store the field contents separately from the rest of
    the issue.  For instance, an &rdbms; &idb; implementation might
    store the field contents in a separate text repository instead of
    in the main issue table.</para>

   </section>    

   <section>
    <title id="sec-issuefieldset"><classname>IssueFieldSet</classname></title>

    <para>An instance of <classname>IssueFieldSet</classname>
    represents a set field.  A set field is a collection of zero or
    more instances of another field type.  All elements of a set must
    be of the same type.  A set field may not contain sets.  A values
    of this field type is represented in memory as a Python sequence,
    with the type of sequence elements given by the contained field
    type.</para>

    <programlisting>
<![CDATA[
class IssueFieldSet(IssueField):
    """A field containing zero or more instances of some other field.

    All contents must be of the same field type.  A set field uses the
    following attributes:

    '"contents"' -- An 'IssueField' describing the elements of the
    set.  It may not be an 'IssueFieldSet'."""

    def __init__(self, contained_field):
        """Create a set field.

        The name of the contained field is taken as the name of this
        field."""
]]>
    </programlisting>

    <para>The <literal>"contents"</literal> attribute of a set field
    takes a special value: another <classname>IssueField</classname>
    subclass instance, representing the type of the contents of the
    set.</para> 

   </section>

   <section>
    <title><classname>IssueFieldAttachment</classname></title>

    <para>An instance of <classname>IssueFieldAttachment</classname>
    represents a field that contains an attachment.</para>

    <para>The value in memory of an issue field is either
    <literal>None</literal>, indicating no attachment, or an instance
    of <link
    linkend="sec-file-attachments"><classname>Attachment</classname></link>
    .</para>

    <programlisting>
<![CDATA[
class IssueFieldAttachment(IssueField):

    def __init__(self, name):
        """Create an attachment field."""
]]>
    </programlisting>    

   </section>

   <section>
    <title><classname>IssueFieldEnumeration</classname></title>

    <para>An instance of <classname>IssueFieldEnumeration</classname>
    corresponds to a field containing an enumeral.  An in-memory
    enumeration field value is a Python integer.</para>

    <programlisting>
<![CDATA[
class IssueFieldEnumeration(IssueField):
    """A field that contains an enumeral value.

    The enumeral value is selected from an enumerated set of values.
    An enumeral field uses the following attributes:

    '"enumeration"' -- A mapping from enumeral names to enumeral
    values.  Names are converted to strings, and values are stored as
    integers.

    '"ordered"' -- If non-zero, the enumerals are presented to the
    user ordered by value."""


    def __init__(self, name, enumeration):
        """Create an enumeral field."""
]]>
    </programlisting>

   </section>

   <section>
    <title>Field type extensions</title>

    <para>Extensions to &qmtest; may add additional field types.  A
    new field type must be implemented as a subclass for one of the
    standard field types, and it must be possible (if suboptimal) to
    store the field contents using the representation of the
    base-class field type.  This allows &idb; implementations
    unfamiliar with the extended field type to store those fields
    regardless.  An &idb; implementation may also check for the
    extended field type and use a more optimized representation for
    those fields.</para>

   </section>

  </section>

  <section id="sec-issueclass">
   <title id="sec-issueclass-title"><classname>IssueClass</classname></title>
    
   <para>An issue class is represented by an instance (<emphasis>not a
   subclass!</emphasis>) of <classname>IssueClass</classname>.</para>

   <programlisting>
<![CDATA[
class IssueClass:

    def __init__(self, name):
        """Create a new issue class named 'name'.

        The issue class initially includes mandatory fields only."""


    def GetName(self):
        """Return the name of this class."""


    def GetFields(self):
        """Return the fields in this class.

        returns -- A map from field names to field values.  The keys
        of the map are strings.  The values are 'IssueField'
        instances."""

        
    def AddField(self, field, retroactive_value):
        """Adds a new field to the issue class.

        'field' -- An instance of a subclass of 'IssueField' which
        describes the field to be added.  The object is copied, and
        subsequent modifications to it will not affect the issue class.

        'default_value' -- The value to assign for this field to
        existing issues of the issue class."""
]]>
   </programlisting>

  </section>
   
 </section>
  
 <section id="sec-idb-api">
  <title id="sec-idb-api-title">Issue database API</title>

  <para>The <classname id="class-IdbBase">IdbBase</classname> class is
  the base class for &idb; implementations.</para>

  <programlisting>
<![CDATA[
class IdbBase:
    """Base class for idb implementations."""


    def GetIssueClass(self, name):
        """Return the issue class named by 'name'."""


    def GetIssue(self, iid):
        """Return the current revision of issue 'iid'."""


    def GetIssueRevision(self, iid, revision_number):
        """Return the revision 'revision_number' of issue 'iid'."""


    def GetAllRevisions(self, iid):
        """Return a sequence of all revisions of an issue.

        'iid' -- The issue of which to retrieve all revisions.

        returns -- A sequence of 'IssueRecord' objects, all
        corresponding to 'iid', indexed by revision number."""


    def GetCurrentRevisionNumber(self, iid):
        """Return the current revision number for issue 'iid'."""


    def Query(self, query_record, current_revision_only=1):
        """Return a sequence of issues matching 'query_record'.

        'query_record' -- An instance of IssueRecord specifying the query.

        'current_revision_only -- If true, don't match revisions other
        than the current revision of each issue."""
]]>
  </programlisting>

  <para>See <link linkend="sec-trigger-api"
  endterm="sec-trigger-api-title"></link> for
  <classname>IdbBase</classname> methods for registering
  triggers.</para>

 </section>

 <section id="sec-issue-api">
  <title id="sec-issue-api-title">Issues</title>

  <para>The canonical in-memory representation of an issue is an
  <classname>IssueRecord</classname> instance.</para>

  <programlisting>
<![CDATA[
class IssueRecord:
    """The canonical representation of an issue."""

    def GetClassName(self):
        """Return the name of the issue class of this issue."""


    def GetField(self, field_name):
        """Return the value of the field given by field_name."""


    # Convenience methods for returning values of mandatory fields.

    def GetId(self):
        """Return the iid."""


    def GetRevisionNumber(self):
        """Return the revision number."""


    def GetTime(self):
        """Return the time  at which this revision was recorded."""


    def GetSummary(self):
        """Return a short summary."""


    def GetCategories(self):
        """Return a categories to which this issue belongs.

        return -- A sequence of string names of categories."""


    def GetParents(self):
        """Return a sequence of iids of parents of this issue."""


    def GetChildren(self):
        """Return a sequence of iids of children of this issue."""
]]>
  </programlisting>

  <section id="sec-diff-issue-records">
   <title id="sec-diff-issue-records-title">Difference issue records</title>

   <para>An <classname>IssueRecord</classname> instance may also be
   used to represent the <emphasis>difference</emphasis> between two
   revisions of the same issue.  Only fields that differ between the
   two issue revisions are included in the issue record; other fields
   are omitted.</para>

   <para>The revision number returned by
   <function>GetRevisionNumber</function> for such an object is a pair
   of numbers, <varname>(from_rev, to_rev)</varname>.  To obtain the
   issue record corresponding to revision number
   <varname>to_rev</varname>, retrieve the issue record corresponding
   to revision number <varname>from_rev</varname>, and replace any
   fields present in the difference issue record.</para>

   <para>Functions are provided to obtain a difference given two issue
   records, and to apply a difference to an issue record to obtain the
   revised issue record:
    <programlisting><![CDATA[
def issue_record_diff(from_record, to_record):
    """Calculate the difference between two issue records.

    'from_record' -- An 'IssueRecord' instance.

    'to_record' -- An 'IssueRecord' instance corresponding to a
    revision of the same issue given by 'from_record'.

    returns -- A difference issue record between 'from_record' and
    'to_record'."""


def issue_record_patch(from_record, diff_record):
    """Apply a difference  to a full issue record.

    'from_record' -- An 'IssueRecord' instance.

    'diff_record' -- A difference 'IssueRecord' instance.

    returns -- An issue record containing 'from_record' with all
    fields present in 'diff_record' replaced.

    invariant -- The result of 'issue_record_patch(r1,
    issue_record_diff(r1, r2))' is identical to 'r2'."""
]]>
    </programlisting>
   </para>

  </section>

 </section>

 <section id="sec-file-attachments">
  <title>File attachments</title>

  <para>The <classname>Attachment</classname> class represents an
  attachment.
   <programlisting>
<![CDATA[
class Attachment:
    """A file attachment to an issue."""

    def __init__(self, data, mime_type, description):
        """Create a new IdbAttachment instance."""


    def GetLocation(self):
        """Return the location of the attachment data.

        returns -- An opaque, implementation-defined string specifying
        the location of the data."""


    def GetFile(self):
        """Return a file handle to the attachment data.

        returns -- A readable file object, positioned at the beginning
        of the data."""


    def GetMimeType(self):
        """Return the MIME type of the attachment."""


    def GetDescription(self):
        """Return a description of the attachment."""
]]>
   </programlisting>
  </para>

 </section>

 &xml-repr.xml;

 <section id="sec-trigger-api">
  <title id="sec-trigger-api-title">Trigger API</title>

  <para>A <link linkend="def-trigger">trigger</link> is implemented as
  an instance of a subclass of <classname>Trigger</classname>.  The
  principal method is <function>__call__</function>, which is passed
  two arguments, both <classname>IssueRecord</classname>
  instances.</para>

  <programlisting>
<![CDATA[
class Trigger:
    """Base class for triggers."""

    def GetName(self):
        """Return the name of this trigger instance."""


    def __call__(self, issue, previous_issue):
        """Invoke the trigger.

        'issue' -- An 'IssueRecord' instance.  For a "get" trigger,
         the issue being retrieved.  For update triggers, the state of
         the issue as it will be or is after the update.

        'previous_issue' -- An 'IssueRecord' instance.  For a "get"
        trigger, 'None'.  For update triggers, the state of the issue
        before the update.

        returns -- A pair '(result, message)'.  The 'result' value
        evaulates to true if the operation is to continue, false if
        the operation is to be cancelled; this value is ignored for
        "postupdate" triggers.  'message' is a short string describing
        the trigger action, or 'None'.  
]]>
  </programlisting>

  <para>Triggers are registered with the &idb; instance, via these
  <classname>IdbBase</classname> methods.</para>

  <programlisting><![CDATA[
    def RegisterTrigger(self, type, trigger):
        """Register a trigger.

        'type' -- The type is a string indicating the trigger type.

           * '"get"' triggers are invoked on issue records that are
             retrieved or returned as query results.  

           * '"preupdate"' triggers are invoked before an issue is
             updated.  

           * '"postupdate"' triggers are invoked after an issue is
             updated.  

         'trigger' -- The trigger, a callable object.  The trigger
         takes two arguments, both instances of 'IssueRecord'.

         The same trigger may be registered more than once for each
         type, or for multiple types."""


    def UnregisterTrigger(self, type, trigger):
        """Unregister a trigger.

        'type' -- If 'None', all instances of 'trigger' are
        unregistered.  Otherwise, only instances matching 'type' are
        unregistered.

        'trigger' -- The trigger to unregister."""


    def GetTriggers(self, type):
        """Return a sequence registered triggers of type 'type'."""
]]>
  </programlisting>

  <para>Triggers are invoked in the order they are registered.</para>

  <para>A trigger returns a boolean value as the first element of its
  return value (a pair).
   <orderedlist>
    <listitem>
     <para>For "get" triggers, a false result causes the issue to be
     suppressed in the result of the &idb; operation.  If the operation
     was a query, the issue is omitted from the results.  If the
     operation is a single-issue access, the exception object is
     returned.</para>
    </listitem>

    <listitem>
     <para>For "preupdate" triggers, a false result causes the update
     to be canceled.</para>
    </listitem>

    <listitem>
     <para>For "postupdate" triggers, the boolean result is ignored
     silently.</para>
    </listitem>
   </orderedlist>
  </para>

  <para>Triggers may perform other actions as side effects.  Note that
  if multiple "preupdate" triggers are registered and the second or a
  subsequent trigger returns a false result, any side effects from
  previous triggers have taken effect; no attempt is made to reverse
  them.  Therefore, it is inadvisable to use preupdate triggers with
  side effects; side effect should be placed in postupdate triggers
  instead, to be invoked when the update has been committed.</para>
  
 </section>

 <section id="sec-rdbms-idb">
  <title id="sec-rdbms-idb-title">&rdbms; &idb; implementation</title>

  <para>The &idb; implementation provided with &qmtrack; will be based
  on an &sql; &rdbms;.  In the database, each issue revision is
  represented by a rows in one or more tables.  The &rdbms;
  implementation also relies on ordinary disk files for auxiliary
  storage, for such data as file attachment contents.</para>

  <para>The &sql; implementation provides the following advantages:
   <itemizedlist>
    <listitem>
     <para>Speed.  &rdbms;s are optimized for high-speed storage and
     retrieval of data.  A good &idb; implementation will take
     advantage of &rdbms; features such as indexing to speed up
     common operations.</para>
    </listitem>

    <listitem>
     <para>Scalability.  The efficiency and compactness of an
     &rdbms;'s data representation makes it suitable for very large
     deployments.</para>
    </listitem>

    <listitem>
     <para>Integrity.  Most &rdbms; systems provide mechanisms to
     preserve the database integrity in such eventualities as sudden
     system failure.</para>
    </listitem>
   </itemizedlist>
  </para>

  <section id="sec-rdbms-compatibility">
   <title>&rdbms; compatibility</title>

   <para>The &rdbms; &idb; implementation will be based on &sql;92 and
   the standard <interface>pydb</interface> interface.  This should
   permit &qmtrack; trivially or easily to be adapted to work with
   many database systems, such as the free-software <ulink
   url="http://www.mysql.com/"><application>MySQL</application></ulink>
   and <ulink
   url="http://postgresql.readysetnet.com/"><application>PostgreSQL</application></ulink>,
   and commercial systems such as
   <application>Oracle</application>.</para>

   <para>However, the burden of installing a full-blown &rdbms; system
   will be too onerous for many potential &qmtrack; users.  Some
   installers will not have the requisite experience and system
   privileges to install and configure a database server.
   Nevertheless, &qmtrack; needs to provide out-of-the-box
   functionality for these users, with fully-automated installation.
   For these users, the &qmtrack; distribution will include an
   in-process &rdbms; as the default issue database.  This system
   should be adequate for most installations.</para>

   <para>The selection of an &rdbms; for inclusion in &qmtrack; is
   still under investigation.  <ulink
   url="http://www.chordate.com/gadfly.html">Gadfly</ulink>, an
   all-Python, single-process database system with a liberal free
   software license, is a likely choice.</para>

  </section>

  <section id="sec-rdbms-schema">
   <title>Database schema</title>

   <para>Each issue class is implemented by a table in the database.
   Table columns correspond to fields in the issue class.  The issue
   ID and revision number fields will jointly comprise the primary key
   of each table.  Wherever possible, standard &sql; data types will be
   used to represent field types (<type>VARCHAR</type> columns for
   text fields, <type>TIMESTAMP</type> columns for time fields,
   etc.).</para>

   <para>Attachment fields are implemented with three
   <type>VARCHAR</type> columns.  The attachment data itself is not
   stored in the database; instead, the data for each attachment is
   stored in a separate file.  The first two attachment fields store
   the attachment description and MIME type, respectively.  The third
   stores the name of a file containing the attachment data.  The file
   name is automatically generated and not user-visible.</para>

   <para>Set fields are implemented with additional tables.  For each
   set field of each issue class, a new table is used.  Each row of a
   set table corresponds to a single element in a set field of a
   specific issue revision.  The row contains an issue ID and revision
   number of the issue revision to which it belongs, plus any
   additional column value(s) necessary to represent the element
   itself.</para> 

   <para>For example, a simplified issue class called "bugs" including
   these fields
    <orderedlist>
     <listitem>
      <para>"description": text</para>
     </listitem>

     <listitem>
      <para>"categories": enumeration set</para>
     </listitem>

     <listitem>
      <para>"severity": enumeration</para>
     </listitem>

     <listitem>
      <para>"attachments": attachment set</para>
     </listitem>
    </orderedlist>
   would be represented by three tables.  The first table would
   contain one row for each issue revision.  The second would contain
   elements of the "categories" field for the issues in this class.
   The third would contain elements of the "attachments" field.</para>

   <para>If this issue class contained a single issue, with two
   revisions, as given by the &xml; issue representation in <xref
   linkend="example-sql-xml-issue"/>, the three tables would look like
   these: <xref linkend="tab-sql-example-main"/> is the main table for
   issue revisions, <xref linkend="tab-sql-example-categories"/>
   stores entries in the "categories" field, and <xref
   linkend="tab-sql-example-attachments"/> stores entries in the
   "attachments" field.</para>

   <example id="example-sql-xml-issue">
    <title>&xml; representation of sample issue in &rdbms;</title>
    <programlisting><![CDATA[
<?xml version="1.0"?>
<!DOCTYPE issue PUBLIC "-//Software Carpentry//DTD QMTrack V0.1//EN">
<issue>
  <class>bugs</class>
  <iid>smith17</iid>
  <field-data revision="1">
    <field name="description">Core dump at startup.</field>
    <field name="categories">
      <item>user bug</item>
      <item>segmentation fault</item>
    </field>
    <field name="severity">critical</field>
    <field name="attachments">
      <attachment>
        <description>core file</description>
        <mime-type>application/octet-stream</mime-type>
        <external-name>attachment001</external-name>
      </attachment>
    </field>
  </field-data>
  <field-data revision="0">
    <field name="categories">
      <item>user bug</item>
    </field>
    <field name="severity">normal</field>
  </field-data>
</issue>
    ]]></programlisting>
   </example>

   <table id="tab-sql-example-main">
    <title>Example: main table for issue class "bugs"</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>IID</entry>
       <entry>revision</entry>
       <entry>description</entry>
       <entry>severity</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>smith17</entry>
       <entry>0</entry>
       <entry>Core dump at startup.</entry>
       <entry>0</entry>
      </row>
      <row>
       <entry>smith17</entry>
       <entry>1</entry>
       <entry>Core dump at startup.</entry>
       <entry>2</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="tab-sql-example-categories">
    <title>Example: table for "categories" fields of issue class
    "bugs"</title> 
    <tgroup cols="3">
     <thead>
      <row>
       <entry>IID</entry>
       <entry>revision</entry>
       <entry>category</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>smith17</entry>
       <entry>0</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry>smith17</entry>
       <entry>1</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry>smith17</entry>
       <entry>1</entry>
       <entry>6</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="tab-sql-example-attachments">
    <title>Example: table for "attachments" field of issue class
    "bugs"</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>IID</entry>
       <entry>revision</entry>
       <entry>description</entry>
       <entry>mime-type</entry>
       <entry>external-name</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>smith17</entry>
       <entry>0</entry>
       <entry>core file</entry>
       <entry>application/octet-stream</entry>
       <entry>attachments/smith17/0000</entry>
      </row>
      <row>
       <entry>smith17</entry>
       <entry>1</entry>
       <entry>core file</entry>
       <entry>application/octet-stream</entry>
       <entry>attachments/smith17/0000</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Note that enumerations, in this case the categories and
   severity, are stored as integers.  For this example, the mapping
   for categories is "user bug" -> 4, "segmentation fault" -> 6, and
   for severity, "normal" -> 0, "critical" -> 2.  The actual bytes in
   the core file are stored outside the database, in a file designated
   by <filename>attachments/smith17/0000</filename>.</para>

  </section>

 </section>

 <section id="sec-web-ui-implementation">
  <title>Web user interface implementation</title>

  <para>&qmtrack; will <firstterm id="def-dtml">&dtml;</firstterm>
  (Document Template Markup Language) to generate web pages in the
  web-based user interface.  &dtml;, developed as part of the <ulink
  url="http://www.zope.org">Zope project</ulink>, provides a mechanism
  for server-side generation of web pages from an &html;-like syntax.
  &dtml; can invoke Python functions directly during the generation
  procedure.  For more information about &dtml; see the <ulink
  url="http://www.zope.org/Documentation/Guides/DTML">&dtml;
  Reference</ulink> manual.</para>

  <para>The &dtml; code to display the forms will be similar to the
  following:
   <programlisting><![CDATA[
<html>
 <head>
  <title>QMTrack query form</title>
 </head>
 <body>
  <h1>QMTrack query form</h1>
  <dtml-expr "show_query_form()">
 </body>
</html>
   ]]></programlisting>
  Using &dtml;, the administrator will be able to specify headers and
  footers and other configuration-type information simply so the web
  interface looks and feels the way the administrator wishes.</para>

 </section>

</chapter>

<!--
  Local Variables:
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("qmtrack.xml" "book" "chapter")
  End:
-->
