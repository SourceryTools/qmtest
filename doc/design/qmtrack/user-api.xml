<?xml version="1.0"?>
<!--

 File:   user-api.xml
 Author: Benjamin Chelf
 Date:   2000-11-19

 Contents:
   Chapter `User Functionality API' of qmtrack design document.

 This is part of the master document contained in qmtrack.xml.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<chapter><title>User Functionality API</title>

 <section><title>Concepts</title>

  <para>The User Functionality API describes the set of functions any
  application can use to interface with the database to create new issues,
  edit existing issues, and perform queries on the database. The goal of
  this API is to provide a simple means for performing these operations
  regardless of the user interface (e.g., command line, email, web,
  etc.).</para>

  <para>We divide user functionality into three main categories:
   <orderedlist>
    <listitem>
     <para>Creating an issue.</para>
    </listitem>

    <listitem>
     <para> Editing an issue to create new revisions of the issue.</para>
    </listitem>
    
    <listitem>
     <para>Querying the database for all issues that match certain
     criteria.</para>
    </listitem>
   </orderedlist>
  </para>

 </section>

 <section><title>Creating Issues</title>

   <para>This section describes the basics of creating an issue. To create
   an issue, simply create an Issue object. You pass it initial values for
   the 'summary,' 'categories,' and 'attachment' and the corresponding
   objects represents the first revision of the new issue.</para>

   <para>Methods:
   <programlisting>
<![CDATA[
class Issue:
    """Base class for issues."""

    def __init__(self, summary, categories, attachment):
        """Returns the issue ID."""
]]>
   </programlisting>
  </para>
 </section>

 <section><title>Editing Issues</title>
    <para>This section describes the basics in editing an issue (i.e.,
    creating a new revision of the issue). Because the user may wish to
    edit more than one field of a given issue for a new revision, we
    provide a mechanism that allows users to encapsulate multiple edits to
    the issue under one revision.</para>

    <para>To edit an issue, simply call the BeginEdit method on the
    issue. This will return a copy of the current revision of the issue
    that can be edited (without changing the actual revision of the
    issue). After performing all edits, complete the revision update by
    calling the EndEdit method on the orignal issue, passing it the edited
    issue. This will complete the revision and store it in the
    database.</para>

    <para>Methods:
    <programlisting>
<![CDATA[
class Issue:
    """Base class for issues."""

    def BeginEdit(self):
        """Returns a copy of the current revision of the issue.

        The returned copy may be edited and then the EndEdit method can be
        called to commit the changes to the issue to create a new revision
        of the issue."""

    def EndEdit(self, new_issue):
        """Returns 0 if successful, 1 on error.

        Ends the editing process for an issue and creates a new revision
        of the issue based on the issue passed to the method."""

    def EditSummary(self, new_summary):
        """Changes the summary to 'new_summary'."""

    def AddCategory(self, new_category):
        """Adds 'new_category' to the list of categories of the issue."""

    def RemoveCategory(self, old_category):
        """Removes 'old_category' from the list of categories of the issue."""

    def AddAttachment(self, attachment):
        """Adds an attachment to the current revision of the issue."""

    def Join(self, issue):
        """Joins self and id together to form one issue from the two.

        Join must be called on all issues involved in the join."""

    def Separate(self):
        """Returns an issue that is a twin of the original.

        Separates the current issue into two issues. The new issue is a
        carbon copy of the old issue (with the same revision history,
        etc.) and is returned from this function."""

    def EditAux(self, field, value):
        """Edits one of the auxillary fields.

        Changes the value in 'field' to 'value.'"""
]]>
   </programlisting>
   </para>

 </section>

 <section><title>Queries</title>
    <para>This section describes the basics of querying the database for
    information about issues. For now, this only describes the basic
    queries on the database.</para>

    <para>Methods:
    <programlisting>
<![CDATA[
    def CreatedAfterDate(date)
        """Returns list of issues created after 'date.'"""

    def CreatedBeforeDate(date)
        """Returns list of issues created before 'date.'"""

    def CreatedRangeDate(date1, date2)
        """Returns list of issues created between 'date1' and 'date2.'"""

    def CreatedOnDate(date)
        """Returns list of issues created on 'date.'"""

    def SummaryContains(string)
        """Returns list of issues whose summary contains 'string.'"""

    def SummaryExact(string)
        """Returns list of issues whose summary is exactly 'string.'"""

    def BelongsTo(category)
        """Returns list of issues who belong to 'category.'"""

    def NotBelongsTo(category) 
        """Returns list of issues who do not belong to 'category.'"""

    def RelatedTo(issue)
        """Returns list of issues related to 'issue.'"""
]]>
    </programlisting>
    </para>
 </section>

</chapter>

<!--
  Local Variables:
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("qmtrack.xml" "book" "chapter")
  End:
-->
