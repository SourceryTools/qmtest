<?xml version="1.0"?>
<!--

  File:   concepts.xml
  Author: Alex Samuel
  Date:   2000-11-07

  Contents:
    Chapter `Conceptual Architecture' of qmtrack design document.

  This is part of the master document contained in qmtrack.xml.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<chapter id="chap-concepts">
 <title id="chap-concepts-title">Concepts</title>

 <para>The fundamental item of information in &qmtrack; is the <phrase
 id="def-issue"><firstterm>issue</firstterm></phrase>.  Each issue has
 a collection of data items associated with it called <phrase
 id="def-field"><firstterm>fields</firstterm></phrase>.  Issues are
 grouped into <link linkend="def-issue-class">issue classes</link> by
 the fields they include; all issues in a single issue class have the
 same fields.</para>

 <para>&qmtrack; is item-based in order to avoid the rigidity that
 often comes from forcing information to be classified into exactly
 one of a number of categories, or to fit it into a rigid hierarchy.
 In the real world, forcing each item into a single topic category is
 not just suboptimal but counterproductive: seekers of that item may
 expect to find it in a different category and conclude that the item
 is not present in the database -- which has them
 <emphasis>worse</emphasis> off than if the items were not categorized
 at all.</para>

 <section id="sec-issue-database">
  <title id="sec-issue-database-title">Issue Database</title>

  <para>The issue database is an abstract database model used by
  &qmtrack; to store, retrieve, and query issues.  &qmtrack; accesses
  the &idb; via an abstract interface, which allows multiple
  implementations with varying performance and maintenance attributes.
  We envision and accommodate implementations based on underlying
  database technologies such as,
   <itemizedlist>
    <listitem>
     <para>flat text files</para>
    </listitem>

    <listitem>
     <para>&xml; files</para> 
    </listitem>

    <listitem>
     <para>a persistent store of Python objects</para>
    </listitem>

    <listitem>
     <para>&sql;-based relational databases such as Postgres, MySQL,
     and Oracle</para>
    </listitem>

    <listitem>
     <para>custom client protocols with remote database
     servers</para>
    </listitem>
   </itemizedlist>
  However, all implementations must support the behavior specified
  here.</para>

  <para>Issues stored in the &idb; may incorporate different fields.
  Issues are divided according to the contents into issue classes.
  All issues in an issue class have the same fields (though some
  fields may be empty).  Certain fields are part of every issue class,
  and therefore included in every issue.</para>

  <para>The issue database can be thought of as a set of one or more
  tables, each containing issues.  Each table may have a different
  schema.  Each table corresponds to one issue class, and all issues
  stored in that table are members of that issue class.</para>

  <section id="sec-issue-classes">
   <title id="sec-issue-classes-title">Issue classes</title>

   <para>An <phrase id="def-issue-class"><firstterm>issue
   class</firstterm></phrase> is a set of issues that share the same
   fields.  When a new issue is created, an issue class is chosen for
   it, and once the issue is created, its class may not be changed
   (though a new issue may be created in another issue class by
   copying fields values).</para>

   <para>The set of available issue classes and the fields contained
   in each are part of the configuration of the &qmtrack; installation.
   New classes may be added to an existing installation, and new
   fields may be added to an existing installation.  However, classes
   may not be removed, and fields may not be removed from
   classes.</para>

  </section>

  <section id="sec-field-types">
   <title id="sec-fields-types-title">Field types</title>

   <para>The &idb; consists of a set of tables corresponding to issue
   classes.  Each row of this table corresponds to a single <link
   linkend="def-revision">revision</link> of an issue.</para>

   <para>The &idb; supports the following field data types:
    <orderedlist>
     <listitem>
      <para><constant>text</constant> fields contain arbitrary text.
      By convention, the text is not broken into lines with newlines
      (user interfaces will wrap text as necessary).  Paragraphs are
      ended with two newline characters.  There is no length limit on
      text fields.</para>
     </listitem>

     <listitem>
      <para><constant>integer</constant> fields contain a signed
      32-bit integer.</para>
     </listitem>

     <listitem>
      <para><constant>attachment</constant> fields contain an
      arbitrary file attachment.  The attachment consists of a (text)
      &mime; type, a text description, and the binary data of the file
      itself.</para>
     </listitem>

     <listitem>
      <para><constant>set</constant> fields contain zero or more
      instances of another field type other than a set.</para>
     </listitem>
    </orderedlist>
   </para>

   <para>The data types listed below are also stored in the &idb;, but
   don't necessarily require additional data type support from the
   underlying database.  The &qmtrack; system will supply an
   implementation of these data types using the above compulsory
   types, if required.  However, implementations may override the
   implementation for any or all of these types for space or time
   optimization.
    <orderedlist>
     <listitem>
      <para><constant>time</constant> fields store a
      <acronym>UTC</acronym> date/time.  This type field is based on
      the <constant>text</constant> field type.</para>
     </listitem>

     <listitem>
      <para><constant>uid</constant> fields store a user id.  This
      field type is based on the <constant>text</constant> field
      type.</para>
     </listitem>

     <listitem>
      <para><constant>iid</constant> fields contain an issue id as a
      <constant>text</constant> field.  This field type is based on
      the <constant>text</constant> field type.</para> 
      <!-- FIXME: Should these be integers, instead?  -->
     </listitem>

     <listitem>
      <para><constant>enumeration</constant> fields contain an
      enumerated value: exactly one value selected from a
      preconfigured set of alternatives.  This field type is based on
      <constant>integer</constant> fields; the mapping between values
      and enumerals is part of the &idb; configuration.</para>
     </listitem>

     <listitem>
      <para>The set of fields supported by &qmtrack; may be extended.
      However, each new field type must be based on one of the
      fundamental field types above.  This decouples &idb;
      implementations from field type extensions by permitting
      oblivious &idb; implementations to store custom field types
      using the underlying field representation.  However, specific
      &idb; implementations may understand a customized field type and
      handle it differently, as an optimization.</para>
     </listitem>
    </orderedlist>
   </para>    

  </section>

  <section id="sec-iids">
   <title id="sec-iids-title">Issue id</title>

   <para>Each issue has a unique <firstterm>issue id</firstterm>, or
   <firstterm>&iid;</firstterm>.  The &iid; is a text string.  Each
   &qmtrack; installation may choose one of two conventions for
   structuring &iid;s.
    <orderedlist>
     <listitem>
      <para>The &iid;s may be placed in a flat namespace.  The &iid;
      values are arbitrary, and may contain lower-case letters,
      decimal digits, and underscores.</para>
     </listitem>

     <listitem>
      <para>The &iid;s may be structured in a tree.  Each interior
      node of the tree has an arbitrary name (unique among its
      siblings).  Each leaf of the tree also has an arbitrary name,
      and corresponds to an issue.  The &iid; of the issue is the
      period-delimited sequence of node names, starting from the
      direct children of the root node.  All interior and leaf node
      names are named as described in (1).  Absolute paths in the tree
      begin with a period.</para>

      <!-- FIXME: How do we specify "up one directory"? -->
     </listitem>
    </orderedlist>
   </para>

  </section>

  <section id="sec-categories">
   <title id="sec-categories-title">Categories</title>

   <para>Issue IDs are not for organizational purposes; they serve
   simply to identity each issue uniquely.  <firstterm
   id="def-categories">Categories</firstterm> are used to group
   issues.  A category is simply a group of issues related in some way
   in the users' conceptions.  Membership in a category is recorded in
   the issue: each issue includes a list of categories to which it
   belongs.  An issue may belong to zero, one, or more
   categories.</para>

   <para>The enumeration of categories included in a particular
   &qmtrack; deployment is part of the &idb; configuration.</para>

  </section>
  
  <section id="sec-revisions">
   <title id="sec-revisions-title">Revisions and audit</title>

   <para>Rows in the &idb; are read-only; in normal circumstances,
   rows are never modified or removed from the table.  Instead, a new
   row is added whenever an issue is modified.  Each row corresponds
   to a single <firstterm id="def-revision">revision</firstterm> of
   the issue, and the latest revision of an issue is considered its
   current state.</para>

   <para>The &idb; schema includes a <firstterm>revision
   number</firstterm> field.  The revision number value for a row
   indicates which revision of the issue it corresponds to.  When a
   new issue is submitted to the &idb;, a new &iid; is assigned and a
   new row is added to the &idb; with revision number zero.  When this
   issue is subsequently modified, another row is added containing the
   revised data, and an incremented sequence number.  Previous rows are
   never deleted.  For an issue, the &idb; row with the corresponding
   &iid; and the highest revision number is the <firstterm>current
   revision</firstterm>.  (When we refer to an issue in this document
   or in the &qmtrack; API, we're referring to the current revision
   unless we specify a revision number explicitly.)</para>

   <para>An audit trail for an issue is obtained by querying the &idb;
   for all revisions of the issue, and sorting by revision number for
   chronological order.</para>

   <para>Issue revisions are generally not deleted from the &idb;,
   during normal use.  Issues that are no longer relevant and should
   not appear in queries are moved to the "Deleted" state (see <xref
   linkend="sec-state-model"/>).  However, they may be for
   house cleaning purposes; for instance, older revisions of retired
   issues may be removed to reduce the size of the &idb;.  To maintain
   referential integrity in the &idb;, there may be no user-visible
   persistent reference to a particular revision of an issue; users
   refer to issues by &iid; only.</para>

  </section>

 </section>

 <section id="sec-issues">
  <title id="sec-issues-title">Issues</title>

  <para>An <link linkend="def-issue">issue</link> is the principal
  data element in &qmtrack;.  Each issue corresponds to a bug report,
  feature request, or other process item in the &qmtrack;
  database.</para>

  <section id="sec-fields">
   <title id="sec-fields-title">Fields</title>

   <para>Each issue (or, more accurately, each revision of each issue)
   contains fields specified by the columns of the &idb; schema.  Fields
   fall into three categories:
    <orderedlist>
     <listitem>
      <para><firstterm>Mandatory fields</firstterm> are present in any
      &idb; issue class and thus in every &qmtrack; issue.  The field
      type and semantics of a mandatory field is invariant; &qmtrack;
      relies on the presence of these fields for its operation.</para>
     </listitem>

     <listitem>
      <para><firstterm>Standard fields</firstterm> need not be present
      in any particular issue class, but if they are, take a
      particular field type and have standard semantics.  Optional
      &qmtrack; features and modules may rely on standard fields for
      their operation.  A component of &qmtrack; or a module which
      uses a standard field must always check first whether the field
      is present, and degrade gracefully if it is not.</para>
     </listitem>

     <listitem>
      <para><firstterm>Custom fields</firstterm> are other fields
      which are added to an issue class.</para>
     </listitem>
    </orderedlist>
   </para>

   <section id="sec-mandatory-fields">
    <title id="sec-mandatory-fields-title">Mandatory fields</title>

    <para><xref linkend="tab-mandatory-fields"/> describes mandatory
    fields.</para>

    <table id="tab-mandatory-fields">
     <title>Mandatory fields</title>
     <tgroup cols="3">
      <colspec colnum="1" colwidth="1*"/>
      <colspec colnum="2" colwidth="1*"/>
      <colspec colnum="3" colwidth="2*"/>
      <thead>
       <row>
        <entry>field name</entry>
        <entry>type</entry>
        <entry>description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>iid</entry>
        <entry><constant>iid</constant></entry>
        <entry>issue id</entry>
       </row>
       <row>
        <entry>revision</entry>
        <entry><constant>integer</constant></entry>
        <entry>revision number</entry>
       </row>
       <row>
        <entry>user</entry>
        <entry><constant>uid</constant></entry>
        <entry>the user who created this revision</entry>
       </row>
       <row>
        <entry>timestamp</entry>
        <entry><constant>date</constant></entry> <entry>the date and
        time at which this issue revision was entered into the &idb;;
        if this is the current revision, it corresponds to the last
        modification time of this issue</entry>
       </row>
       <row>
        <entry>summary</entry>
        <entry><constant>string</constant></entry>
        <entry>short summary</entry>
       </row>
       <row>
        <entry>categories</entry>
        <entry><constant>enumeration set</constant></entry>
        <entry>the categories to which the issue belongs</entry> </row>
       <row>
        <entry>parents</entry>
        <entry><constant>iid set</constant></entry>
        <entry>the single &iid; of the parent issue if this issue was
        created in a split operation; the &iid; of all parent issues if
        this issue was created in a join operation; an empty set
        otherwise</entry>
       </row>
       <row>
        <entry>children</entry>
        <entry><constant>iid set</constant></entry>
        <entry>the single &iid; of the child issue if this issue was
        joined with other issues; the &iid; of all children if this issue
        was split; an empty set otherwise</entry>
       </row>
       <row>
        <entry>state</entry>
        <entry><literal>enumeration</literal></entry>
        <entry>the state in the issue data model for this class; see
        the <link linkend="sec-state-model">state model
        trigger</link></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   </section>

   <section id="sec-standard-fields">
    <title id="sec-standard-fields-title">Standard fields</title>

    <para><xref linkend="tab-standard-fields"/> describes standard
    fields.</para>

    <table id="tab-standard-fields">
     <title>Standard fields</title>
     <tgroup cols="3">
      <colspec colnum="1" colwidth="1*"/>
      <colspec colnum="2" colwidth="1*"/>
      <colspec colnum="3" colwidth="2*"/>
      <thead>
       <row>
        <entry>field name</entry>
        <entry>type</entry>
        <entry>description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>attachments</entry>
        <entry><literal>attachment set</literal></entry>
        <entry>a collection of zero or more file attachments containing
        arbitrary data</entry>
       </row>
       <row>
        <entry>notification_list</entry>
        <entry><literal>uid set</literal></entry>
        <entry>a collection of users who wish to be notified of
        changes to this issue; see <xref
        linkend="sec-notification"/>.</entry>
       </row>
       <row>
        <entry>severity</entry>
        <entry><literal>enumeration</literal></entry>
        <entry>a measure of the importance of this issue; the
        enumerals are user-defined</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   </section>

  </section>

  <section id="sec-attachments">
   <title id="sec-attachments-title">Attachments</title>

   <para>Arbitrary file attachments may be associated with an issue in
   the &idb;.  For most record-oriented implementations of the &idb;,
   though, the attachments themselves will not be stored in the
   database.  Instead, the attachment data itself will be stored on the
   side in some other repository (such as a file system) and
   incorporated by reference.</para>

   <para>Each attachment includes three pieces of information.
    <orderedlist>
     <listitem>
      <para>A specification of the location of the attachment
      data.</para>
     </listitem>

     <listitem>
      <para>A &mime; type, stored as a string.</para>
     </listitem>

     <listitem>
      <para>A description, stored as a string.</para>
     </listitem>
    </orderedlist>
   </para>

  </section>

 </section>

 <section id="sec-queries">
  <title id="sec-queries-title">Queries</title>

  <para>A <firstterm>query</firstterm> is used to select a subset of
  issues of an issue class.  A query is expressed as a Python boolean
  expression, using a restricted subset of Python syntax.  An &idb;
  implementation processes the query as if the expression is evaluated
  on each issue; if the expression evaluates to true, the the query is
  said to <firstterm>match</firstterm> and the issue is included in
  the query's result set.</para>

  <para>The following Python constructs are allowed in queries:
   <itemizedlist>
    <listitem>
     <para>Literals, including integers, strings, and
     dates/times.</para>
    </listitem>

    <listitem>
     <para>Logical operators: <function>and</function>,
     <function>or</function>, and <function>not</function>.</para>
    </listitem>

    <listitem>
     <para>Parentheses for grouping boolean expressions.</para>
    </listitem>

    <listitem>
     <para>Equality and inequality operators <function>==</function>
     and <function>!=</function>, taking text, integer, or
     enumeration operands.</para>
    </listitem>

    <listitem>
     <para>Comparison operators <function>&lt;</function>,
     <function>&lt;=</function>, <function>&gt;=</function>, and
     <function>&gt;</function>, taking integer, date, or enumeration
     operands.</para>
    </listitem>

    <listitem>
     <para>The <literal>in</literal> operator, taking a set right-hand
     operand.</para>
    </listitem>
   </itemizedlist>
  In addition, the following syntax elements are allowed:
   <itemizedlist>
    <listitem>
     <para>The name of a field in the issue class.  The name is
     replaced by the fields value.</para>
    </listitem>

    <listitem>
     <para>An enumeral name.  If collisions occur between enumeral
     names in multiple enumerations or between an enumeral name and a
     field name, the behavior is undefined.</para>
    </listitem>

    <listitem>
     <para>The <function>~</function> operator, taking text
     operands.  This operator denotes a regular expression match, ala
     Perl.</para>
    </listitem>

    <listitem>
     <para>The <function>in</function> operator, taking text operands.
     The operation evaluates to true if the left-hand keyword occurs
     in the right-hand string.</para>
    </listitem>
   </itemizedlist>
  </para>

  <para>The result of a query incorporating valid Python constructs
  not included in the subset presented above are &idb;
  implementation-defined.  An implementation may, but is not required
  to, implement a larger subset of valid Python boolean
  expressions.</para>

  <para>The same query interface is used for preparation of reports on
  the contents of the &idb;.</para>

  <section id="sec-query-examples">
   <title>Query examples</title>

   <para>Below are some examples of &qmtrack; issue queries
   incorporating operations on mandatory and standard fields.
    <segmentedlist>
     <segtitle>Query</segtitle>
     <segtitle>Interpretation</segtitle>
     <seglistitem>
      <seg>
       <userinput>front_end in categories and severity ==
       critical</userinput>
      </seg>
      <seg>
       Select all issues in the "front_end" category and at critical
       severity.
      </seg>
     </seglistitem>

     <seglistitem>
      <seg>
       <userinput>not "C++" in summary and timestamp &gt; "2000 Oct
       31"</userinput>
      </seg>
      <seg>
       Select all issues not containing the text "C++" in the summary
       and last revised after October 31.
      </seg>
     </seglistitem>
    </segmentedlist>
   </para>

  </section>

 </section>

 &triggers.xml;
 &user-interface.xml;

</chapter>

<!--
  Local Variables:
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("qmtrack.xml" "book" "chapter")
  End:
-->
