<?xml version="1.0"?>
<!--

 File:   user-interface.xml
 Author: Benjamin Chelf
 Date:   2000-11-25

 Contents:
   Section `User Interface' of qmtrack design document.

 This is part of the master document contained in qmtrack.xml.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
 <section id="sec-ui">
  <title id="sec-ui-title">User Interface</title>

  <para>This section describes the different methods the user can use
  to create issues, edit issues, and query the database. We invision
  three main modes for interaction: command line, email, and
  web. However, based on the specification in the previous section,
  any mode may be added.</para>

  <section id="sec-command-line">
   <title id="sec-command-line-title">Command line</title>
   
   <para>All &qmtrack; command-line functionality is accessed via the
   &qmtrack-cmd; command, using a command-line syntax popularized by
   the <application>CVS</application> program.  The user provides a
   <firstterm id="def-subcommand">subcommand</firstterm> with each
   invocation of &qmtrack-cmd;, which specifies the type of operation
   to be performed.  The user may specify options modifying
   &qmtrack;'s behavior, and, for certain subcommands, additional
   arguments.</para>

   <synopsis>
    qmtrack [ options ] command [ command_options ] [ command_args ]
   </synopsis>

   <para>When creating or modifying an issue, field values are
   specified as arguments.  The user specifies field values to
   &qmtrack-cmd; commands using assignment notation, as in
   <userinput><replaceable>field</replaceable>=<replaceable>value</replaceable></userinput>.
   For set fields, different notation is used instead to add or remove
   elements from the set.  To add elements, the user specifies
   <userinput><replaceable>field</replaceable>+=<replaceable>value</replaceable></userinput>.
   To remove elements, the <userinput>-=</userinput> symbol is used
   instead.  All of the commands to create and edit issues use the
   above three operators to specify new values for fields. Alternately,
   you may specify the issue to be created or edited in its &xml; form 
   as described in Section <link linkend="sec-xml-repr"
   endterm="sec-xml-repr-title"/>. If you choose to perform operations on
   the issue in this way, simply give the command and then, on
   <literal>stdin</literal>, give the &xml; of the issue to be created,
   edited, or queried on.</para>
   <section id="sec-qmtrack-commands">
    <title id="sec-qmtrack-commands-title">&qmtrack-cmd commands</title>

    <formalpara>
     <title><command>create</command></title> 

     <para>This command is used to create a new issue.  It takes as
     its mandatory arguments a summary and categories.  Optional
     arguments include any other field values you wish to set.  For
     example,
     <screen>
      &prompt;<userinput>qmtrack create summary="My first issue" categories+=simple categories+=first</userinput>
      <computeroutput>iss2</computeroutput>
     </screen>
     will create a new issue that has the summary, "My first issue"
     and belongs to the two categories, "simple" and "first". The
     value printed is the ID of the new issue.</para>
    </formalpara>

    <formalpara>
     <title><command>edit</command></title>

     <para>This command is used to edit an existing issue. It takes
     the ID of the command you wish to edit and then as arguments any
     fields you wish to edit. For example,
     <screen>
      &prompt;<userinput>qmtrack edit iss2 categories-=first</userinput>
      <computeroutput>iss2</computeroutput>
     </screen>
     will edit the issue with id "iss2" removing the category "first"
     from the issue. A new revision of the issue will be created and
     stored in the database.  &qmtrack; responds with the issue id of
     the edited issue.</para>
    </formalpara>

    <formalpara>
     <title><command>split</command></title>

     <para>The <command>split</command> command splits one issue into
     two.  The issue ids of the two new issues are printed (the old
     issue id is no longer used).  For example,
     <screen>
      &prompt;<userinput>qmtrack split foo</userinput>
      <computeroutput>foo.1, foo.2</computeroutput>
     </screen>
    </para>
    </formalpara>

    <formalpara>
     <title><command>join</command></title>

     <para>The <command>join</command> command joins two or more
     issues into a new issue.  If any field assignments are specified,
     these fields are modified in the newly-joined issue.  The issue
     id of the newly joined issue is printed.  For example,
     <screen>
      &prompt;<userinput>qmtrack join foo bar</userinput>
      <computeroutput>foo_bar</computeroutput>
     </screen>
    </para>
    </formalpara>

    <formalpara>
     <title><command>query</command></title>

     <para>This command is used to search the database for issues that
     match certain criteria.  A Python-like syntax is used to specify
     queries, as described in <link linkend="sec-queries"
     endterm="sec-queries-title"></link>.  For example,
     <screen>
      &prompt;<userinput> qmtrack query 'front_end in categories and severity &gt; serious'</userinput>
      <computeroutput>foo,bar,bar2,baz</computeroutput>
     </screen>
     searches for all issues in the category "front_end" at the
     severity level "serious" or greater.  &qmtrack; responds with the
     issue ids of matching issues.</para>
    </formalpara>

   </section>

   <section id="sec-output-options">
    <title id="sec-output-options-title">Output options</title>

    <para>By default, &qmtrack; displays a comma-separated list of
    issue ids created, edited, or matched by the user's operation.
    Other output may be selected using the <option>--format</option>
    (<option>-f</option>) option.  This option takes an option
    parameter, which is the name of a format style.  See <xref
    linkend="tab-format-params"></xref> for parameter values.</para>

    <table id="tab-format-params">
     <title><option>--format</option> parameters</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>format style</entry>
        <entry>description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>none</literal></entry>
        <entry>Don't display any issue output.</entry>
       </row>
       <row>
        <entry><literal>iid</literal></entry>
        <entry>Comma-delimited issue ids (default).</entry>
       </row>
       <row>
        <entry><literal>iid-single</literal></entry>
        <entry>Issue ids, delimited with newlines, useful for shell
        and line-oriented processing.</entry>
       </row>
       <row>
        <entry><literal>summary</literal></entry>
        <entry>Issue ids and summaries.</entry>
       </row>
       <row>
        <entry><literal>short</literal></entry>
        <entry>To be determined.</entry>
       </row>
       <row>
        <entry><literal>full</literal></entry>
        <entry>To be determined.</entry>
       </row>
       <row>
        <entry><literal>command</literal></entry> 
        <entry>Field assignments, in the format that would be passed
        to the <command>qmtrack create</command> command.  Note that
        some fields, such as attachment fields, cannot be represented
        this way.</entry>
       </row>
       <row>
        <entry><literal>xml</literal></entry>
        <entry>The issue(s) in canonical &xml; format.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>Additionally, the <option>--custom-format</option>
    (<option>-F</option>) option may be used to specify a different
    format.  This option takes as its parameter a comma-separated list
    of field names to display in tabular format.</para>

   </section>

  </section>

  <section id="sec-email">
   <title id="sec-email-title">E-mail</title>

   <para>To create, edit, and query issues via e-mail, simply construct an
   e-mail with the command as you would issue it on the command line and
   send it to the database. The database will respond with the information
   in &xml; form. For example, to create a new issue, you can send an e-mail
   like this:
    <programlisting>
Subject: create
To: qmtrack-database@domain.com
Date: Tue, 5 Dec 2000 23:42:15 -0800 (PST)

create summary="My issue" categories+=foo categories+=bar
    </programlisting>
   or like this:
    <programlisting><![CDATA[
Subject: create
To: qmtrack-database@domain.com
Date: Tue, 5 Dec 2000 23:42:15 -0800 (PST)

create
<?xml version="1.0"?>
<!DOCTYPE issue PUBLIC "-//Software Carpentry//DTD QMTrack V0.1//EN">
<issue>
 <field-data>
  <field name="summary">My issue</field>
  <field name="categories">
    <item>foo</item>
    <item>bar</item>
  </field>
 </field-data>
</issue>
    ]]></programlisting>
   Either way, you would receive an e-mail back containing the text:
    <programlisting><![CDATA[
Subject: Re: create
To: qmtrack-user@another-domain.com
Date: Tue, 5 Dec 2000 23:45:15 -0800 (PST)

<?xml version="1.0"?>
<!DOCTYPE issue PUBLIC "-//Software Carpentry//DTD QMTrack V0.1//EN">
<issue>
 <iid>iss2</iid>
 <field-data>
  <field name="summary">My issue</field>
  <field name="categories">
    <item>foo</item>
    <item>bar</item>
  </field>
 </field-data>
</issue>
    ]]></programlisting>
   indicating that the issue has been created. To edit an issue, you
   may either give the command line for editing the issue or request
   that the issue be sent back to you for editing and subsequently
   send it back after you have edited it. For example, to remove the
   category, foo, from the issue we just created, you could send the
   following message:
    <programlisting>
Subject: edit
To: qmtrack-database@domain.com
Date: Tue, 5 Dec 2000 23:42:15 -0800 (PST)

edit iss2 categories-=foo
    </programlisting>
   or you could send the following message:
    <programlisting>
Subject: edit
To: qmtrack-database@domain.com
Date: Tue, 5 Dec 2000 23:42:15 -0800 (PST)

edit iss2
    </programlisting>
   with no arguments to the edit command except for the issue. Sending
   an email of this form will cause the database to send you the
   following message:
    <programlisting><![CDATA[
Subject: Re: edit
To: qmtrack-user@another-domain.com
Date: Tue, 5 Dec 2000 23:45:15 -0800 (PST)

edit
<?xml version="1.0"?>
<!DOCTYPE issue PUBLIC "-//Software Carpentry//DTD QMTrack V0.1//EN">
<issue>
 <iid>iss2</iid>
 <field-data>
  <field name="summary">My issue</field>
  <field name="categories">
    <item>foo</item>
    <item>bar</item>
  </field>
 </field-data>
</issue>
    ]]></programlisting>
   which you would then edit to look like:
    <programlisting><![CDATA[
Subject: Re: edit
To: qmtrack-database@domain.com
Date: Tue, 5 Dec 2000 23:42:15 -0800 (PST)

edit
<?xml version="1.0"?>
<!DOCTYPE issue PUBLIC "-//Software Carpentry//DTD QMTrack V0.1//EN">
<issue>
 <iid>iss2</iid>
 <field-data>
  <field name="summary">My issue</field>
  <field name="categories">
    <item>bar</item>
  </field>
 </field-data>
</issue>
    ]]></programlisting>
   (removing the category "foo") and send back to the database.  If
   you wish to add an attachment to this revision of the issue, you
   can simply attach it to the email. In either case, you after the
   edit is complete, you would receive a message that looked like
   this: 
   <programlisting>
     <![CDATA[ 
Subject: Re: edit
To: qmtrack-user@another-domain.com
Date: Tue, 5 Dec 2000 23:45:15 -0800 (PST)

<?xml version="1.0"?> 
<!DOCTYPE issue PUBLIC "-//Software Carpentry//DTD QMTrack V0.1//EN">
<issue>
 <iid>iss2</iid>
 <field-data>
  <field name="summary">My issue</field>
  <field name="categories">
    <item>bar</item>
  </field>
 </field-data>
</issue>
    ]]></programlisting>
   </para>

   <para>As with creating and editing, you may also specify a query by
   sending an e-mail to the database. If you issue the command as is
   done on the command line, the syntax is identical to that on the
   command line. However, if you choose to use an &xml; representation
   for your query, you are more limited in the way you search. Imagine
   the following e-mail message to be sent to the database:
    <programlisting><![CDATA[
Subject: query
To: qmtrack-database@domain.com
Date: Tue, 5 Dec 2000 23:42:15 -0800 (PST)

query
<?xml version="1.0"?>
<!DOCTYPE issue PUBLIC "-//Software Carpentry//DTD QMTrack V0.1//EN">
<issue>
 <field-data>
  <field name="categories">
    <item>bar</item>
  </field>
 </field-data>
</issue>
    ]]></programlisting>
   This will return the &xml; representation for any issues that have
   <literal>bar</literal> in their category set. This would be
   equivalent to sending a message like this:
    <programlisting>
Subject: query
To: qmtrack-database@domain.com
Date: Tue, 5 Dec 2000 23:42:15 -0800 (PST)

query 'bar in categories'
    </programlisting>
   </para>

   <para>For more information about the query syntax that is allowed
   on the command line, see the section on <link linkend="sec-queries"
   endterm="sec-queries-title"></link>.</para>

  </section>

  <section>
   <title>Web</title> 

   <para>To create, edit, and perform queries on the web, the user
   will be presented with a form that has all the fields of an
   issue. This form will be generated by &dtml; using the special
   dtml-in tag that iterates over all the elements in a list (in this
   case, the fields of the issue). For more information about &dtml;
   and the <sgmltag>dtml-in</sgmltag> tag, see the <ulink
   url="http://www.zope.org/Documentation/Guides/DTML">&dtml;
   Reference</ulink> manual. The &dtml; code to display the forms will
   be similar to the following:
   <programlisting>
<![CDATA[
  <table>
  <dtml-in fields>
  <tr><td><dtml-var name></td>
      <td><dtml-expr "get_display"></td>
  </tr>
]]>
   </programlisting>
   where for each field, the field name is displayed and then the
   method <function>get_display</function> is called on each field to
   determine the way the field should be displayed (e.g., as a text
   box, as a set of check boxes, etc.). For querying, another line is
   added to the above to extract from the field what choices for
   querying the user has (e.g., exact match versus substring match,
   less than versus greater than, etc.). Using &dtml;, the
   administrator will be able to specify headers and footers and other
   configuration-type information simply so the web interface looks
   and feels the way the administrator wishes.</para>

   <para><xref linkend="fig-web-state-model"/> shows the state model
   for the primary &qmtrack; web pages.  Each state represents a web
   page.  
    <itemizedlist>
     <listitem>
      <para>The "New Issue Form" page displays controls for the fields
      in an issue, initially blank, to be filled out as a new issue
      entry.</para>
     </listitem>

     <listitem>
      <para>The "Edit Form" page displays the same form, but with
      the fields populated with the current field values from an
      existing issue.</para>
     </listitem>

     <listitem>
      <para>The "Query Form" page also displays a similar form, with
      the fields left blank; fields are filled in to specify the
      query.  The "Query Form" also contains a control that can be
      used to enter more complicated Python expression queries.</para>
     </listitem>

     <listitem>
      <para>The "View Issue" page shows the same form, but with
      non-editable controls displaying field values.  This page has a
      sub-state in which the audit trail (revision history) for the
      issue is also displayed.</para>
     </listitem>

     <listitem>
      <para>The "Issue List" page shows multiple issues resulting from
      a query in a summary format.  The page also contains query
      controls, by which the query results may be refined with
      additional restrictions.  This enables a "drill-down" model of
      browsing.</para>
     </listitem>
    </itemizedlist>
   </para>

   <figure id="fig-web-state-model">
    <title>Web GUI state model schematic</title>

    <mediaobject>
     <imageobject>
      <imagedata fileref="web-gui-states.png" format="PNG"
      align="center" scale="50"/>
     </imageobject>
    </mediaobject>
   </figure>

   <para>The main menu, as represented above in the state model, will look
   something like this:
    <mediaobject>
     <imageobject>
      <imagedata fileref="main1.jpg" format="JPG" scale="50"></imagedata>
     </imageobject>
    </mediaobject>
   This is the control center for the database. From this menu, the user
   can access the forms necessary to create new issues, view existing
   issues, edit issues, query for issues, and perform advanced queries
   with a subset of the python expressions.</para>

   <para>On clicking the "Create" button of the "Main Menu" page, the user
   will be presented with a form like the following:
    <mediaobject>
     <imageobject>
      <imagedata fileref="create1.jpg" format="JPG" scale="50"></imagedata>
     </imageobject>
    </mediaobject>
   This is the "New Issue" form described in the state model above. Notice
   how the fields are displayed. In this form, the fields are to be
   displayed in a way that allows them to be edited. This is one of the
   three methods of display. The other two, as will be described below,
   are the displays for read-only fields and querie fields. Each field can
   be displayed in one of the three ways based upon the context of the
   page. Once the user fills in the requisite information on the "New
   Issue" page and clicks the "Create" button, the user will be taken to a
   "View Issue" form that will show him/her the newly created issue. The
   following is an example of the "View Issue" form that would be seen
   after creating a new issue:
    <mediaobject>
     <imageobject>
      <imagedata fileref="create2.jpg" format="JPG"></imagedata>
     </imageobject>
    </mediaobject>
   Notice the read-only form of the fields in this "View Issue" page. None
   of the fields can be edited since this page is intended to display
   issues only. Also, the "View Issue" page allows more audit information
   to be displayed, as described in the state model above as well as a
   button to edit the issue being displayed.

   The user has two ways of getting to the "Edit Issue" page described
   above in the state model. One way is for the user can simply click the
   "Edit" button on a "View Issue" page. The other way, the user simply
   enters the ID of the issue he/she wants to edit on the "Main Menu" page
   and then clicks "Edit" from there. Either way, the user will be
   presented with a page like this:
    <mediaobject>
     <imageobject>
      <imagedata fileref="edit1.jpg" format="JPG"></imagedata>
     </imageobject>
    </mediaobject>
   Then the user can then edit the issue on the page. Notice that the
   fields are displated in their edit form, just as they were on the
   "Create Issue" page. The user then clicks "Edit" to commit the changes
   he/she made. Again, a "View Issue" page will be displayed with the
   issue that was just edited:
    <mediaobject>
     <imageobject>
      <imagedata fileref="edit2.jpg" format="JPG"></imagedata>
     </imageobject>
    </mediaobject>

   To perform queries, the user may either enter the Python expression
   query string on the "Main Menu" page described above, or click the
   "Query" button on that page. In the latter case, a page like the
   following for the "Query Form", descibed above in the state model, will
   be displayed:
    <mediaobject>
     <imageobject>
      <imagedata fileref="query1.jpg" format="JPG"></imagedata>
     </imageobject>
    </mediaobject>
   Then the user can simply put values in the fields as desired, choosing
   how to search on each field with the given pull down menus. Notice that
   this page shows the third type of display for fields, the query
   display. For queries, it is not sufficient to simply have an edit box
   for each field. Each field must accompanied by some options for how to
   query on that field. For example, for queries on integer fields, the
   user may wish to specify "less than," "greater than," or "exact"
   searches on that field. Therefore, there exist pull down menus on the
   page above representing the type of query on each field. The following
   demonstrates a potential query that the user might perform:
    <mediaobject>
     <imageobject>
      <imagedata fileref="query2.jpg" format="JPG"></imagedata>
     </imageobject>
    </mediaobject>
   After clicking the "Query" button, a page like the following is
   returned:
    <mediaobject>
     <imageobject>
      <imagedata fileref="query3.jpg" format="JPG"></imagedata>
     </imageobject>
    </mediaobject>
   This is the "Issue List" as described in the state model above. It is a
   list of all the issues that matched the criteria specified in the query
   (either an "Advanced Query" or "Basic Query"). From this page, the user
   may refine his/her search by clicking the "Refine Query" button. This
   will return the user to the "Query Form" page to enter additional
   information. The query will then be performed only on the issues in the
   issue list. Also, the user may view (and subsequently edit) individual
   issues in the issue list by clicking on their ID. Clicking on the ID
   will take the user to a "View Issue" page for that issue.
   </para>

  </section>

 </section>

<!--
  Local Variables:
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("qmtrack.xml" "chapter" "section")
  End:
-->
