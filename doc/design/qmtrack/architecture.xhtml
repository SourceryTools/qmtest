<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--

  File:   architecture.xhtml
  Author: Alex Samuel
  Date:   2000-10-24

  Contents:
    Architecture of the qmtrack tool.

  Copyright (C) 2000 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<html xhtmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <link rel="stylesheet" type="text/css" href="../../qm.css" />

    <title>qmtrack architecture</title>
  </head>

  <body>
    <a name="CHAP-architecture">
      <h3>Architecture</h3>
    </a>

    <p>This chapter describes the architecture of the core
    components of qmtrack.</p>

    <h4>Issue Database</h4>

    <p>The <a class="Term">issue database</a> is an abstract database
    model used by qmtrack to store, retrieve, and query issues.
    Qmtrack accesses the idb via an abstract interface, which allows
    multiple implementations with varying performance and maintenance
    attributes.  We envision and accomodate implementations based on
    underlying database technologies such as,</p>
    <ul>
      <li>a flat text file</li>
      <li>an XML file</li>
      <li>a persistent store of Python objects</li>
      <li>SQL-based relational databases such as Postgres, MySQL, and
      Oracle</li>
      <li>custom client protocols with remote database servers</li>
    </ul>
    <p>However, all implementations must support the behaviour
    specified here.</p>

    <p>The idb consists of a single table.  Each row of this table
    corresponds to a single revision of an issue.</p>

    <h5>Field types</h5>

    <p>The idb supports the following field data types:</p>
    <ol>
      <li><span class="Identifier">string</span> fields contain short
      character strings.  These fields should not contain newlines,
      carriage returns, tabs, or other control characters (but are
      under no fixed length limit).  Database implementations should
      validate that <span class="Identifier">string</span> fields
      contain appropriate values only.</li>

      <li><span class="Identifier">text</span> fields contain
      arbitrary text.  By convention, the text is not broken into
      lines with newlines (user interfaces will wrap text as
      necessary).  Paragraphs are ended with two newline characters.
      There is no length limit on text fields.</li>

      <li><span class="Identifier">integer</span> fields contain a
      signed 32-bit integer.</li>

      <li><span class="Identifier">integer list</span> fields contain
      a list of zero or more 32-bit integers.</li>
    </ol>

    <p>The data types listed below are also stored in the idb, but
    require no additional data type support from the underlying
    database.</p>
    <ol>
      <li><span class="Identifier">time</span> fields store a UTC
      date/time.  Time is stored as a string, with the format
      &quot;%Y-%m-%d %H:%M:%S&quot;.</li>

      <li><span class="Identifier">uid</span> fields store a <a
      class="Term">user id</a> as a <span
      class="Identifier">string</span>.</li>

      <li><span class="Identifier">iid</span> fields contain a
      reference to another issue in the same idb as an <span
      class="Identifier">integer</span> field.</li>

      <li><span class="Identifier">iid set</span> fields contain
      zero or more references to other issues in the same idb.  These
      fields are typically stored as <span class="Identifier">integer
      list</span> fields in the underlying idb implementation.</li>

      <li><span class="Identifier">enumeration</span> fields contain
      an enumerated value: exactly one value selected from a
      preconfigured set of alternatives.  Enumeration values are
      typically stored as integers; the mapping between values and
      enumerals is part of the idb configuration.</li>

      <li><span class="Identifier">enumeration set</span> fields
      contain a subset of elements of a preconfigured set of enumeral
      alternatives.  Enumeration set fields are typically stored as
      integer sets in the underlying idb implementation.</li>
   </ol>

    <h5>Issue id</h5>

    <p>Each issue is assigned a unique <a class="Term">issue id</a> at
    creation.  Issue ids are assigned sequentially starting from zero
    for each idb instance.</p>

    <h5>Revisions and audit</h5>

    <p>Rows in the idb are read-only; in normal circumstances, rows
    are never modified or removed from the table.  Instead, a new row
    is added whenever an issue is modified.</p>

    <p>The idb schema includes a <a class="TermDef">revision
    number</a> field.  The revision number value for a row indicates
    which revision of the issue it corresponds to.  When a new issue
    is submitted to the idb, a new <a class="Term">iid</a> is assigned
    and a new row is added to the idb with revision number zero.  When
    this issue is subsequently modified, another row is added
    containing the revised data, and an incremented sequece number.
    Previous rows are never deleted.  For an issue, the idb row with
    the corresponding iid and the highest revision number is the <a
    class="TermDef">current revision</a>.  (When we refer to an issue
    in this document or in the qmtrack API, we're referring to the
    current revision unless we specify a revision number
    explicitly.)</p>

    <p>An audit trail for an issue is obtained by querying the idb for
    all rows matching the corresponding idb, and sorting by sequence
    number for chronological order.</p>

    <p>Issues may not be deleted.  Rows are generally not deleted from
    the idb, except for housecleaning purposes.</p>

    <h4>Issue database API</h4>

    <p>The <span class="Class">IdbBase</span> class is the base class
    for idb implementations.</p>

    <p>Creation and setup methods.</p>

    <div class="API">
<pre>
class IdbBase:
    """Base class for idb implementations."""
</pre>
    </div>

    <p>Methods for retrieving issues and revisions.</p>

    <div class="API">
<pre>
    def GetIssue(self, iid):
        """Return the current revision of the issue corresponding to
        iid."""

    def GetIssueRevision(self, iid, revision_number):
        """Return the issue revision corresponding to iid and
        revision_number."""

    def GetIssueAllRevisions(self, iid):
        """Return an array of revisions of the issue given by iid.
        The array index is the revision number."""

    def GetCurrentRevisionNumber(self, iid):
        """Return the revision number of the current revision of the
        issue given by iid."""
</pre>
    </div>

    <h4>Issues</h4>

    <p>An <a class="Term">issue</a> is the principal data record in
    qmtrack.  Each issue corresponds to a bug report, feature request,
    or other process item in the qmtrack database.</p>

    <h5>Fields</h5>

    <p>Each issue (or, more accurately, each revision of each issue)
    contains fields specified by the columns of the idb schema.
    Fields fall into three categories:</p>
    <ol>
      <li><a class="TermDef">Mandatory fields</a> are present in any
      idb schema and thus in every qmtrack issue.  The field type and
      semantics of a mandatory field is invariant; qmtrack relies on
      the presence of these fields for its operation.</li>

      <li><a class="TermDef">Standard fields</a> need not be present,
      but if they are, take a particular field type and have standard
      semantics.  Option qmtrack features and modules may rely on
      standard fields for thier operation.</li>

      <li><a class="TermDef">Custom fields</a> may be configured at
      will in the idb schema.</li>
    </ol>

    <h5>Mandatory fields</h5>

    <table columns="3">
      <tr class="Heading">
        <td>field name</td>
        <td>type</td>
        <td>description</td>
      </tr>
      <tr>
        <td>id</td>
        <td><span class="Identifier">integer</span></td>
        <td><a class="Term">issue id</a></td>
      </tr>
      <tr>
        <td>revision number</td>
        <td><span class="Identifier">integer</span></td>
        <td><a class="Term">revision number</a></td>
      </tr>
      <tr>
        <td>time stamp</td>
        <td><span class="Identifier">date</span></td>
        <td>the date and time at which this issue revision was entered
        into the idb</td>
      </tr>
      <tr>
        <td>summary</td>
        <td><span class="Identifier">string</span></td>
        <td>short summary</td>
      </tr>
      <tr>
        <td>categories</td>
        <td><span class="Identifier">enumeration set</span></td>
        <td>the <a class="Term">categories</a> to which the issue
        belongs</td>
      </tr>              
      <tr>
        <td>attachments</td>
        <td>special</td>
        <td>a collection of zero or more file attachments containing
        arbitrary data</td>
      </tr>
      <tr>
        <td>parents</td>
        <td><span class="Identifier">iid set</span></td>
        <td>the single iid of the parent issue if this issue was
        created in a split operation; the iid of all parent issues if
        this issue was created in a join operation; an empty set
        otherwise</td>
      </tr>
      <tr>
        <td>children</td>
        <td><span class="Identifier">iid set</span></td>
        <td>the single iid of the child issue if this issue was joined
        with other issues; the iid of all children if this issue was
        split; an empty set otherwise</td>
      </tr>
    </table>

    <h6>Attachments</h6>

    <p>Arbitrary file attachments may be associated with an issue in
    the idb.  For most record-oriented implementations of the idb,
    though, the attachments themselves will not be stored in the
    database.  Instead, the attachment data itself will be stored on
    the side in some other repository (such as a file system) and
    incorporated by reference.</p>

    <p>Each attachment includes three pieces of information.</p>
    <ol>
      <li>A specification of the location of the attachment data.</li>

      <li>A MIME type, stored as a string.</li>

      <li>A description, stored as a string.</li>
    </ol>

    <p>The <span class="Class">IdbAttachment</span> class represents
    an attachment.</p>
    <div class="API">
<pre>
class IdbAttachment:
    """A file attachment to an issue."""

    def __init__(self, data, mime_type, description):
        """Create a new IdbAttachment instance."""

    def GetLocation(self):
        """Return a string giving the location of the attachment data.
        The contents of the string are opaque and
        implementation-defined, but uniquely and completely specify
        the location of the data."""

    def GetFile(self):
        """Return a readable file handle to the attachment data,
        positioned at the beginning."""

    def GetMimeType(self):
        """Return the MIME type of the attachment."""

    def GetDescription(self):
        """Return a description of the attachment."""
</pre>
    </div>

  </body>
</html>

<!-- 
  Local Variables:
  mode: html
  indent-tabs-mode: nil
  End:
-->
