<?xml version="1.0"?>
<!--

  File:   test-manual.xml
  Author: Alex Samuel
  Date:   2000-11-01

  Contents:
    Manual for QMTest.

  Copyright (C) 2001, 2002 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<chapter id="chap-test-manual">
 <title>Using &qmtest;</title>

  <para>This chapter describes &qmtest; in more detail.  It explains
  the fundamental concepts that &qmtest; uses, the test classes that
  come with &qmtest;, and how to extend &qmtest; to support new
  application domains.</para>

  <para>The central principle underlying the design of QMTest is that
  the problem of testing can be divided into a domain-dependent problem
  and a domain-independent problem.  The domain-dependent problem is
  deciding what to test and how to test it.  For example, should a
  database be tested by performing unit tests on the C code that makes
  up the database, or by performing integration tests using SQL queries?
  How should the output of a query asking for a set of records be
  compared to expected output?  Does the order in which the records
  presented in matter?  These are questions that only someone who
  understands the application domain can answer.</para>

  <para>The domain-independent part of the problem is managing the
  creation of tests, executing the tests, and displaying the results for
  users.  For example, how does a user create a new test?  How are tests
  stored?  Should failing tests be reported to the user, even if the
  failure was expected?  These questions are independent of the
  application domain; they are just as relevant for compiler tests as
  they are for database tests.</para>

  <para>QMTest is intended to solve the domain-independent part of the
  problem and to offer a convenient, powerful, and flexible interface
  for solving the domain-dependent problem.  QMTest is both a complete
  application, in that it can be used <quote>out of the box</quote> to
  handle many testing domains, and infrastructure, in that it can be
  extended to handle other domains.</para>

  <section id="sec-qmtest-concepts">
  <title>&qmtest; Concepts</title>

  <para>This section presents the concepts that underlie &qmtest;'s design.  By
  understanding these concepts, you will be able to better understand
  how &qmtest; works.  In addition, you will find it easier to extend
  &qmtest; to new application domains.</para>

  <section id="sec-tests">
   <title>Tests</title>

   <para>A <firstterm>test</firstterm> checks for the correct behavior
   of the target application.  What constitutes correct behavior will
   vary depending on the application domain.  For example, correct
   behavior for a database might mean that it is able to retrieve
   records correctly while correct behavior for a compiler might mean
   that it generates correct object code from input source code.</para>
 
   <para>Every test has a name that uniquely identifies the test,
   within a given <link linkend="sec-test-database">test
   database</link>.  Test names must be composed entirely of lowercase
   letters, numbers, the <quote>_</quote> character, and the
   <quote>.</quote> character.  You can think of test names like file
   names.  The <quote>.</quote> character takes the place of
   <quote>/</quote>; it allows you to place a test in a particular
   <firstterm>directory</firstterm>.  For example, the test name
   <filename>a.b.c</filename> names a test named
   <filename>c</filename> in the directory <filename>a.b</filename>.
   The directory <filename>a.b</filename> is a subdirectory of the
   directory <filename>a</filename>.</para>

   <para>Every test is an instance of some test class.  The test class
   dictates how the test is run, what constitutes success, and what
   constitutes failure.  For example, the
   <classname>command.ExecTest</classname> class that comes with
   &qmtest; executes the target application and looks at its output.
   The test passes if the actual output exactly matches the expected
   output.</para>

   <para>The arguments to the test parameterize the test; they are
   what make two instances of the same test class different from each
   other.  For example, the arguments to
   <classname>command.ExecTest</classname> indicate which application to
   run, what command-line arguments to provide, and what output is
   expected.</para>

   <para>Sometimes, it may be pointless to run one test unless another
   test has passed.  Therefore, each test can have a set of associated
   <firstterm>prerequisite tests</firstterm>.  If the prerequisite
   tests did not pass, &qmtest; will not run the test that depends
   upon them.</para>

  </section> <!-- sec-tests -->

  <section id="sec-resources">
   <title>Resources</title>

   <para>Some tests take a lot of work to set up.  For example, a
   database test that checks the result of SQL queries may require
   that the database first be populated with a substantial number of
   records.  If there are many tests that all use the same set of
   records, it would be wasteful to set up the database for each test.
   It would be more efficient to set up the database once, run all of
   the tests, and then remove the databases upon completion.</para>

   <para>You can use a <firstterm>resource</firstterm> to gain this
   efficiency.  If a test depends on a resource, &qmtest; will ensure
   that the resource is available before the test runs.  Once all
   tests that depend on the resource have been run &qmtest; will
   destroy the resource.</para>

   <para>Just as every test is an instance of a <firstterm>test
   class</firstterm>, every resource is an instance of a
   <firstterm>resource class</firstterm>.  The resource class explains
   how to set up the resource and how to clean up when it is no longer
   needed.  The arguments to the resource class are what make two
   instances of the same resource class different from each other.
   For example, in the case of a resource that sets up a database, the
   records to place in the database might be given as arguments.
   Every resource has a name, using the same format that is used for
   tests.  It is possible to have a test and resource with the same
   name; the test and resource namespaces are distinct.</para>

   <para>Under some circumstances (such as running tests on multiple
   machines at once), &qmtest; may create more than one instance of
   the same resource.  Therefore, you should never depend on there
   being only one instance of a resource.  In addition, if you have
   asked &qmtest; to run tests concurrently, two tests may access the
   same resource at the same time.</para>
 
   <para>Setting up or cleaning up a resource produces a result, just
   like those produced for tests.  &qmtest; will display these results
   in its summary output and record them in the results file.</para>

  </section> <!-- sec-resources -->

  <section id="sec-context">
   <title>Context</title>

   <para>When you create a test, you choose arguments for the test.
   The test class uses this information to run the test.  However, the
   test class may sometimes need information that is not available
   when the test is created.  For example, if you are writing compiler
   tests to verify conformance with the C programming language
   specification, you do not know the location of the C compiler
   itself.  The C compiler may be installed in different locations on
   different machines.</para>

   <para>A <firstterm id="def-context">context</firstterm> gives users
   a way of conveying this kind of information to tests.  The context
   is a set of key/value pairs.  The keys and values are always
   strings.  In general, all tests in a given use of &qmtest; will
   have the same context.  However, when a resource is set up, it may
   place additional information in the context of those tests that
   depend upon it; the tests can use this information to locate the
   resource.</para>

  </section> <!-- sec-context -->

  <section id="sec-test-results">
   <title>Test Results</title>

   <para>A <firstterm id="def-result">result</firstterm> is an
   <firstterm id="def-outcome">outcome</firstterm> together with some
   <firstterm>annotations</firstterm>.  The outcome indicates whether
   the test passed or failed.  The annotations give additional
   information about the result, such as the manner in which the test
   failed, the output the test produced, or the amount of time it took
   to run the test.</para>

   <section id="sec-outcomes">
    <title>Outcomes</title>

    <para>The outcome of a test indicates whether it passed or failed,
    or whether some exceptional event occurred.  There are four test
    outcomes:
     <itemizedlist>
      <listitem>
       <para>&PASS;: The test succeeded.</para>
      </listitem>

      <listitem>
       <para>&FAIL;: The test failed.</para>
      </listitem>

      <listitem>
       <para>&ERROR;: A problem occurred in the test execution
       environment, rather than in the tested system.  For example, this
       outcome is used when the test class attempted to run an
       executable in order to test it, but could not because the system
       call to create a new process failed.</para>

       <para>This outcome may also indicate a defect in &qmtest; or in
       the test class.</para>
      </listitem>

      <listitem>
       <para>&UNTESTED;: &qmtest; did not attempt to execute the test.
       For example, this outcome is used when &qmtest; determines that
       a prerequisite test failed.</para>
      </listitem>
     </itemizedlist>
    </para>

   </section> <!-- sec-outcomes -->

   <section id="sec-annotations">
    <title>Annotations</title>
  
    <para>An annotation is a key/value pair.  Both the keys and values
    must are strings.  When a test (or resource) runs it may add
    annotations to the result.  These annotations are displayed by
    &qmtest; and preserved in the results file.  If you write your own
    test class, you can use annotations to store information that will
    make your test class more informative.</para>

   </section> <!-- sec-annotations -->

  </section> <!-- sec-test-results -->

  <section id="sec-test-suite">
   <title>Test Suite</title>

   <para>A <firstterm>test suite</firstterm> is a collection of tests.
   &qmtest; can run an entire test suite at once, so by grouping tests
   together in a test suite, you make it easier to run a number of
   tests at once.  A single test can be a member of more than one test
   suite.  A test suite can contain other test suites; the total set
   of tests in a test suite includes both those tests included
   directly and those tests included as part of another test suite.
   Every test suite has a name, following the same conventions given
   above for tests and resources.</para>

   <para>One use of test suites is to provide groups of tests that are
   run in different situations.  For example, the
   <literal>nightly</literal> test suite might consist of those tests
   that should be run automatically every night, while the
   <literal>checkin</literal> test suite might consist of those tests
   that have to pass before any changes are made to the target
   application.</para>

   <section id="sec-implicit-test-suites">
    <title>Implicit Test Suites</title>

    <para><xref linkend="sec-tests"/> explains how you may arrange
    tests in a tree hierarchy, using a period
    (<quote><literal>.</literal></quote>) as the path separator in
    test names.  &qmtest; defines an <firstterm>implicit test
    suite</firstterm> for each directory.  The name of these implicit
    test suites is the same as the name of the directory.  The
    implicit test suite corresponding to a directory contains all
    tests in that directory or its subdirectories.</para>

    <para>Consider, for example, a test database which contains tests
    with these names:</para>

    <simplelist type="vert" columns="1">
     <member><filename>back_end.db_1</filename></member>
     <member><filename>back_end.db2</filename></member>
     <member><filename>front_end.cmdline</filename></member>
     <member><filename>front_end.gui.widget_1</filename></member>
     <member><filename>front_end.gui.widget_2</filename></member>
    </simplelist>

    <para>For this test database, &qmtest; defines implicit test suites
    with IDs <filename>back_end</filename>, <filename>front_end</filename>,
    and <filename>front_end.gui</filename>.  The test suite
    <filename>front_end</filename> contains the tests
    <filename>front_end.cmdline</filename>,
    <filename>front_end.gui.widget_1</filename>, and
    <filename>front_end.gui.widget_2</filename>.</para>

    <para>The suite named "<filename>.</filename>" (a single period) is
    the implicit test suite corresponding to the root directory in the
    test database.  This suite therefore contains all tests in the
    database.  For example, the command

    <screen>
&prompt;<userinput>qmtest run .</userinput>
    </screen>

    is equivalent to:

    <screen>
&prompt;<userinput>qmtest run</userinput>
    </screen>

    Both commands run all tests in the database.</para>

   </section> <!-- sec-implicit-test-suites -->

  </section> <!-- sec-test-suite -->

  <section id="sec-test-database">
   <title>Test Database</title>

   <para>A <firstterm id="def-test-database">test database</firstterm>
   stores tests, test suites, and resources.  When you ask &qmtest;
   for a particular test by name, it queries the test database to
   obtain the test itself.  &qmtest; stores a test database in a
   single directory, which may include many files and
   subdirectories.</para>
 
   <para>In general, &qmtest; can only use one test database at a
   time.  However, it is possible to create a test database which
   contains other test databases.  This mechanism allows you to store
   the tests associated with different parts of a large application in
   different test databases, and still combine them into a single
   large test database when required.</para>

   <para>A single test database can store many different kinds of
   tests.  By default, &qmtest; stores tests, resources, and test
   suites in the test database using subdirectories containing XML
   files.  Generally, there should be no need to examine or modify
   these files directly.  However, the use of an XML format makes it
   easy for you to automatically generate tests from another program,
   if required.</para>

  </section> <!-- sec-test-database -->

  <section id="sec-targets">
   <title>Targets</title>

   <para>A <firstterm id="def-target">target</firstterm> is &qmtest;'s
   abstraction of a machine.  By using multiple targets, you can run your
   tests on multiple machines at one.  If you have many tests, and
   many machines, you can greatly reduce the amount of time it takes
   to run all of your tests by distributing the tests across multiple
   targets.</para>

   <para>By default, &qmtest; uses only one target: the machine on
   which you are running &qmtest;.  You may specify other targets by
   creating a target file, which lists the available targets and their
   attributes, and specifying the target file when you invoke
   &qmtest-cmd;.  See <xref linkend="sec-target-files"/> for details
   on writing and using target files.</para>

   <para>Each target is a member of a single <firstterm
   id="def-target-group">target group</firstterm>.  All machines in
   the same target group are considered equivalent.  A target group is
   specified by a string.  If you are testing software on multiple
   platforms at once, the target group might correspond to machines
   running the same operating system.  For example, all Intel 80386
   compatible machines running GNU/Linux might be in the
   <quote><literal>i386-pc-linux-gnu</literal></quote> target
   group.</para>

   <para><xref linkend="sec-ref-targets"/> describes how you specify and
   use targets with &qmtest;.</para>

  </section> <!-- sec-targets -->

 </section> <!-- Concepts -->

 <section id="sec-running-tests">
  <title>Running Tests</title>

  <para>To run one or more tests, use the <command>&qmtest-cmd;
  run</command> command.  Each invocation of the <command>&qmtest-cmd;
  run</command> command is a single test run, and produces a single set
  of test results and statistics.  Specify as arguments the names of tests
  and test suites to run.  Even if you specify a test more than once,
  either directly or by incorporation in a test suite, &qmtest; runs it
  only once.</para>

  <para>If you wish to run all tests in the test database, use the
  implicit test suite <literal>.</literal> (a single period; see <xref
  linkend="sec-implicit-test-suites"/>), or omit all IDs from the
  command line.</para>

  <para>&qmtest; can run tests in multiple concurrent threads of
  execution or on multiple remote hosts.  See the documentation for the
  <link linkend="sec-testcmd-run"><command>run</command> command</link>
  for details.</para>

  <section id="sec-ordering-and-dependencies">
   <title>Ordering and Dependencies</title>

   <para>Given one or more input test names and test suite names, &qmtest;
   employs the following procedure to determine which tests and
   resources to run and the order in which they are run.</para>

   <orderedlist>
    <listitem>
     <para>&qmtest; resolves test names and test suite names.  Test suites
     are expanded into the tests they contain.  Since test suites may
     contain other test suites, this process is repeated until all test
     suites have been expanded.  The result is a set of tests that are
     to be run.</para>
    </listitem>

    <listitem>
     <para>&qmtest; computes a schedule for running the tests to be run
     such that a test's prerequisites are run before the test itself is
     run.  Prerequisites not included in the test run are ignored.
     Outside of this condition, the order in which tests are run is
     undefined.</para>

     <para>If &qmtest; is invoked to run tests in parallel or
     distributed across several <link
     linkend="def-target">targets</link>, the tests are distributed
     among them as well.  &qmtest; does not guarantee that a test's
     prerequisites are run on the same target, though.  On each target,
     tests are assigned to the next available concurrent process or
     thread.</para>
    </listitem>

    <listitem>
     <para>&qmtest; determines the required resources for the tests to be run.
     If several tests require the same resource, &qmtest; attempts to
     run all of the tests on the same target.  In this case, the
     resource is set up and cleaned up only once.  In some cases,
     &qmtest; may schedule the tests on multiple targets; in that case,
     the resource is set up and cleaned up once on each target.</para>
    </listitem>
   </orderedlist>

   <para>In some cases, a test, resource setup function, or resource
   cleanup function is not executed:</para>

   <itemizedlist>
    <listitem>
     <para>A test specifies for each of its prerequisite tests an
     expected outcome.  If the prerequisite is included in the test run
     and the actual outcome of the prerequisite test is different from
     the expected outcome, the test is not run.  Instead, it is given an
     &UNTESTED; outcome.</para>

     <para>If a test's prerequisite is not included in the test run,
     that prerequisite is ignored.</para>
    </listitem>

    <listitem>
     <para>If a setup function for one of the resources required by a
     test fails, the test is given an &UNTESTED; outcome.</para>
    </listitem>

    <listitem>
     <para>The cleanup function of a resource is run after the last test
     that requires that resource, whether or not that test was run.  The
     cleanup function is run even if the setup function failed.</para>
    </listitem>
   </itemizedlist>

  </section> <!-- Ordering and Dependencies -->

  <section id="sec-the-context">
   <title>The Context</title>

   <para>&qmtest; passes a context object to the
   <function>Run</function> method of a test that is run and to the
   <function>SetUp</function> method of a resource.</para>

   <para>Most of the properties of the context are the same for all
   tests and resource functions run during a single test run.  These
   properties are configured as part of the test run.  For example, when
   you run tests using the <command>&qmtest-cmd; run</command> command,
   you may specify individual context properties with the <link
   linkend="opt-test-run-context"><option>&dashdash;context</option>
   (<option>-c</option>)</link> or <link
   linkend="opt-test-run-context-file"><option>&dashdash;load-context</option>
   (<option>-C</option>)</link> options.</para>

   <para>In addition, a resource setup function may add additional
   properties to a context.  These added properties do not become part
   of the common context; they are hidden from other tests and resources
   except that the properties added by a resource are visible to tests 
   that require that resource.</para>

   <para>For instance, a resource <function>SetUp</function> function
   might allocate the resource and place a handle to it (for instance,
   a temporary directory name or a database session key) in the
   context as a context property.  Tests that require that resource
   have access to the temporary resource via the handle stored in the
   context.  The resource's cleanup function also uses the handle to
   deallocate the resource.  That information should be stored in the
   resource object itself since no context is made available to the
   <function>CleanUp</function>.</para>

  </section> <!-- The Context -->

 </section> <!-- Running Tests -->

 <section id="sec-database-contents">
  <title>Test Database Contents</title>

  <para>The default &qmtest; test database implementation stores the
  database as a directory hierarchy containing XML files.  Each QMTest
  subdirectrory is represented by a subdirectory in the filesystem.  A
  test, suite, or resource is represented by an XML file.  These files
  have file extensions <filename>.qmt</filename>,
  <filename>.qms</filename>, and <filename>.qma</filename>,
  respectively.</para>

  <para>Expert &qmtest; users may modify the contents of the test
  database directly by editing these files.  However, it is the user's
  responsibility to ensure the integrity and validity of the XML
  contents of each file.  For example, file and directory names should
  contain only characters allowed in identifiers (lower-case letters,
  digits, and underscores); a period should only be used before a file
  extension, such as <filename>.qmt</filename>.  Also, the files and
  directories in a test database should not be modified directly while
  &qmtest; is running with that test database.</para>

 </section> <!-- sec-database-contents -->

 <section id="sec-test-command-line">
  <title>Invoking &qmtest;</title>

  <para>All &qmtest; functionality is available using the &qmtest-cmd; 
  command.</para>

  <section>
   <title>&qmtest-cmd;</title>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd;</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
     <arg choice="plain">
      <replaceable>command</replaceable>
     </arg>
     <arg choice="opt" rep="repeat">
      <replaceable>command-option</replaceable>
     </arg>
     <arg choice="opt" rep="repeat">
      <replaceable>argument</replaceable>
     </arg>
    </cmdsynopsis>
   </section>

   <section>
    <title>Options</title>

    <para>These options can be used with any &qmtest; command, and must
    precede the command name on the command line.</para>

    <para>All options are available in a "long form" prefixed with
    "&dashdash;" (two hyphens).  Some options also may be specified in
    a "short form" consisting of a single hyphen and a one-letter
    abbreviation.  Short-form options may
    be combined; for example, <command>-abc</command> is equivalent to
    <command>-a -b -c</command>.</para>

    <variablelist>
     <varlistentry>
      <term><option>-D</option> <replaceable>path</replaceable></term>
      <term>
       <option>&dashdash;tdb</option> <replaceable>path</replaceable> 
      </term>
      <listitem>
       <para>Use the test database located in the directory given by
       <replaceable>path</replaceable>.  This flag overrides the value of
       the environment variable <envar>QMTEST_DB_PATH</envar>.  If
       neither this flag nor the environment variable is specified,
       &qmtest; assumes that the current directory should be used as the
       database.  See <xref linkend="sec-test-database"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-h</option></term>
      <term><option>&dashdash;help</option></term>
      <listitem>
       <para>Display help information, listing commands and general
       options for the &qmtest-cmd; command.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>&dashdash;verbose</option></term>
      <listitem>
       <para>Generate progress and status messages while executing.  This
       option may be specified more than once; the more times it is
       specified, the higher the verbose level, and the more messages are
       printed.</para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>Additional options are available for specific commands; these
    are presented with each command.  Options specific to a command must
    follow the command on the command line.  Specify the
    <option>&dashdash;help</option> (<option>-h</option>) option after the
    command for a description of the command and a list of of available
    options for that command.</para>
   </section>
  </section>

  <section id="sec-testcmd-create-tdb">
   <title><command>&qmtest-cmd; create-tdb</command></title>

   <section>
    <title>Summary</title>
    <para>Create a new test database.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; create-tdb</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
    </cmdsynopsis>
   </section>

   <section>
    <title>Description</title>
    <para>The <command>&qmtest-cmd; create-tdb</command> command
    creates a new, empty test database.  A test database is a
    directory in which &qmtest; stores configuration files, tests, and
    other data.  Certain test database classes may also store data
    elsewhere, such as in an external relational database.</para>

    <para>The test database is created in the directory specified by
    <option>&dashdash;tdb</option> (<option>-D</option>) option or by
    setting the <envar>QMTEST_DB_PATH</envar> environment variable.
    The path you specify for the new test database must not exist.
    (If no database path is specified, &qmtest; assumes that the
    current directory is the test database.  Since the current
    directory already exists, &qmtest; will issue an error.
    Therefore, when using the <command>create-tdb</command> command,
    the database directory must be explicitly specified.)</para>

    <para>By default, &qmtest; creates a new test database that uses the
    standard XML-based implementation.  (See <xref
    linkend="sec-ref-writing-database-classes"></xref> for information
    about writing a test database class.)</para>

    <para>The <command>create-tdb</command> command accepts these
    options:</para>

    <variablelist>
     <varlistentry> 
      <term><option>-c</option> <replaceable>class</replaceable></term>
      <term>
       <option>&dashdash;class</option> <replaceable>class</replaceable>
      </term>
      <listitem>
       <para>Use the test database class given by
       <replaceable>class</replaceable>.  Once you create a test
       database, you cannot change the test database implementation
       it uses.  If you do not use this option, &qmtest; will use the
       default test database implementation, which uses an XML file
       format to store tests.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>
  </section> <!-- sec-testcmd-create-tdb -->

  <section id="sec-testcmd-gui">
   <title><command>&qmtest-cmd; gui</command></title>

   <section>
    <title>Summary</title>
    <para>Start the graphical user interface.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; gui</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
    </cmdsynopsis>
   </section>

   <section>
    <title>Description</title>

     <para>The <command>&qmtest-cmd; gui</command> starts the
     graphical user interface.  The graphical user interface is
     accessed through a web browser.  You must have a web browser that
     supports JavaScript to use the graphical interface.  &qmtest; has
     been tested with recent versions of Internet Explorer and
     Netscape Navigator.  Other web browsers may or may nor work with
     &qmtest;.</para>

     <para>The <command>gui</command> command accepts these
     options:</para>

     <variablelist>
      <varlistentry>
       <term><option>-A</option> <replaceable>address</replaceable></term>
       <term>
        <option>&dashdash;address</option> <replaceable>address</replaceable>
       </term>
       <listitem>
        <para>Bind the server to the indicated internet
         <replaceable>address</replaceable>, which should be a dotted
         quad.  By default, the server binds itself to the address
         <literal>127.0.0.1</literal>, which is the address of the local
         machine.  If you specify another address, the server will
         be accessible to users on other machines.  QMTest does not
         perform any authentication of remote users, so you should
         not use this option unless you have a firewall in place that
         blocks all untrusted users.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>-c</option> <replaceable>name=value</replaceable></term>
       <term>
        <option>&dashdash;context</option> 
        <replaceable>name=value</replaceable>
       </term>
       <listitem>
        <para>For details about this option, see the description of the 
        <command>qmtest run</command> command.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>-C</option> <replaceable>file</replaceable></term>
       <term>
        <option>&dashdash;load-context</option> <replaceable>file</replaceable>
       </term>
       <listitem>
        <para>For details about this option, see the description of the 
        <command>qmtest run</command> command.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>-j</option> <replaceable>count</replaceable></term>
       <term>
        <option>&dashdash;concurrency</option> <replaceable>count</replaceable>
       </term>
       <listitem>
        <para>For details about this option, see the description of the 
        <command>qmtest run</command> command.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <option>&dashdash;no-browser</option>
       </term>
       <listitem>
        <para>Do not attempt to start a web browser when starting the
        GUI.  &qmtest; will still print out the URL at which the server
        can be accessed.  You can then connect to this URL
        manually using the browser of your choice.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <option>&dashdash;port <replaceable>port</replaceable></option>
       </term>
       <listitem>
        <para>Specify the <replaceable>port</replaceable> on which the
        &qmtest; GUI will listen for connections.  If this option is not
        provided, &qmtest; will select an available port
        automatically.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><option>-T</option> <replaceable>file</replaceable></term>
       <term>
        <option>&dashdash;targets</option> <replaceable>file</replaceable>
       </term>
       <listitem>
        <para>For details about this option, see the description of the 
        <command>qmtest run</command> command.</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </section>
   </section> <!-- sec-testcmd-gui -->

  <section id="sec-testcmd-run">
   <title><command>&qmtest-cmd; run</command></title>

   <section>
    <title>Summary</title>
    <para>Run tests or test suites.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; run</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
     <group choice="opt" rep="repeat">
      <arg choice="plain"><replaceable>test-name</replaceable></arg>
      <arg choice="plain"><replaceable>suite-name</replaceable></arg>
     </group>
    </cmdsynopsis>
   </section>

   <section>
    <title>Description</title>

    <para>The <command>&qmtest-cmd; run</command> command runs tests
    and displays the results.  If no test or suite names are
    specified, &qmtest; runs all of the tests in the test database.
    If test or suite names are specified, only those tests or suites
    are run.  Tests listed more than once (directly or by inclusion in
    a test suite) are run only once.</para>

    <para>The <command>run</command> command accepts these
    options:</para>

    <variablelist>
     <varlistentry id="opt-test-run-context">
      <term>
       <option>-c</option>
       <replaceable>name</replaceable>=<replaceable>value</replaceable>
      </term>
      <term>
       <option>&dashdash;context</option> 
       <replaceable>name</replaceable>=<replaceable>value</replaceable>
      </term>
      <listitem>
       <para>Add a property to the <link linkend="sec-the-context">test
       execution context</link>.  The name of the property is
       <replaceable>name</replaceable>, and its value is set to the string
       <replaceable>value</replaceable>.</para>

       <para>This option may be specified multiple times.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="opt-test-run-context-file">
      <term><option>-C</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;load-context</option> <replaceable>file</replaceable>
      </term>
      <listitem>
       <para>Read properties for the <link linkend="sec-the-context">test
       execution context</link> from the file
       <replaceable>file</replaceable>.</para>

       <para>The file should be a text file with one context property on
       each line, in the format <replaceable>name=value</replaceable>.
       Leading and trailing whitespace on each line are ignored.  Also,
       blank lines and lines that begin with "#" (a hash mark) are
       ignored as comments.</para>

       <para>This option may be specified more than once, and used in
       conjunction with the <option>&dashdash;context</option> option.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>format</replaceable></term>
      <term>
       <option>&dashdash;format</option> 
       <replaceable>format</replaceable>
      </term>
      <listitem>
       <para>Control the format used when displaying results.  The
       format specified must be one of <literal>full</literal>,
       <literal>brief</literal>, <literal>stats</literal>, or
       <literal>none</literal>.  The <literal>brief</literal> format
       is the default.  In the <literal>full</literal> format,
       &qmtest; displays any annotations provided in test results.  In
       the <literal>brief</literal> mode only the causes of failures
       are shown; detailed annotations are not shown.  In the
       <literal>stats</literal> format, no details about failing tests
       are displayed; only statistics showing the number of passing
       and failing tests are displayed.  In the
       <literal>none</literal> mode, no results are displayed, but a
       results file is still created, unless the
       <option>&dashdash;no-output</option> option is also provided.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>count</replaceable></term>
      <term>
       <option>&dashdash;concurrency</option> <replaceable>count</replaceable>
      </term>
      <listitem>
       <para>Run tests in multiple <replaceable>count</replaceable>
       concurrent processes on the local computer.  On multiprocessor
       machines, the processes may be scheduled to run in parallel on
       different processors.  &qmtest; automatically collects results
       from the processes and presents combines test results and summary.
       By default, one process is used.</para>

       <para>This option may not be combined with the <link
       linkend="opt-test-run-targets"><option>&dashdash;targets</option>
       (<option>-T</option>) option</link>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <option>&dashdash;no-output</option>
      </term>
      <listitem>
       <para>Do not produce a test results file.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-o</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;output</option> <replaceable>file</replaceable> 
      </term>
      <listitem>
       <para>Write full test results to <replaceable>file</replaceable>.
       Specify "<literal>-</literal>" (a hyphen) to write results to
       standard output.  If neither this option nor
       <option>&dashdash;no-output</option> is specified, the results
       are written to the file named <filename>results.qmr</filename>
       in the current directory.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-O</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;option</option> <replaceable>file</replaceable>
      </term>
      <listitem>
       <para>Treat <replaceable>file</replaceable> as a set of
       expected outcomes.  The <replaceable>file</replaceable> must
       have be a results file created either by <command>&qmtest-cmd;
       run</command>, or by saving results in the graphical user interface.
       &qmtest; will expect the results of the current test run to
       match those specified in the <replaceable>file</replaceable>
       and will highlight differences from those results.</para>
      </listitem>
     </varlistentry> 

     <varlistentry>
      <term><option>-s</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;summary</option> <replaceable>file</replaceable> 
      </term>
      <listitem>
       <para>Write a summary of the test run to
       <replaceable>file</replaceable>.  Specify "<literal>-</literal>"
       (a hyphen) to write results to standard output (the
       default).</para>

       <para>&qmtest; prints a summary of test results, including
       statistics and the names of tests that did not pass.  If
       expected outcomes were specified, the the names of tests that
       had unexpected results are printed, instead of the names of
       tests that did not pass.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>&dashdash;no-summary</option></term>
      <listitem> 
       <para>Do not produce a summary of the test run.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <option>&dashdash;seed</option> <replaceable>integer</replaceable>
      </term>
      <listitem>
       <para>For each test run, &qmtest; randomizes the order in which
       tests are run, subject to the constraints described in <xref
       linkend="sec-ordering-and-dependencies"/>.  The random number
       generator is seeded using the system time.  This maximizes the
       chance of detecting unanticipated dependencies among tests across
       multiple test runs.</para>

       <para>For debugging purposes, it is sometimes necessary to obtain
       a reproducible sequence of tests.  Use the
       <option>&dashdash;seed</option> option to specify the seed for the
       random number generator.</para>

       <para>Note that even with the same random number seed, if tests
       are run on targets with a concurrency greater than one, scheduling
       uncertainty may still produce variation in the order in which
       tests are run.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="opt-test-run-targets">
      <term><option>-T</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;targets</option> <replaceable>file</replaceable>
      </term>
      <listitem>
       <para>Use targets specified in target specification file
       <replaceable>file</replaceable>.  See <xref
       linkend="sec-target-files"/> for a description of the target file
       syntax.</para>
      </listitem>
     </varlistentry>

    </variablelist>
   </section>
  </section> <!-- sec-testcmd-run -->

  <section id="sec-testcmd-summarize">
   <title><command>&qmtest-cmd; summarize</command></title>

   <section>
    <title>Summary</title>
    <para>The <command>&qmtest-cmd; summarize</command> displays
    information stored in a results file.</para>
   </section>

   <section>
    <title>Synopsis</title>
    <cmdsynopsis>
     <command>&qmtest-cmd; summarize</command>
     <arg choice="opt" rep="repeat">
      <replaceable>option</replaceable>
     </arg>
     <group choice="opt" rep="repeat">
      <arg choice="plain"><replaceable>test-name</replaceable></arg>
      <arg choice="plain"><replaceable>suite-name</replaceable></arg>
     </group>
    </cmdsynopsis>
   </section>

   <section>
    <title>Description</title>
    <para>The <command>&qmtest-cmd; summarize</command> extracts
    information stored in a results file and displays this information
    on the console.  The information is formatted just as if the tests
    had just been run, but &qmtest; does not actually run the
    tests.</para>

    <para>The <command>summarize</command> command accepts the
    following options:</para>

    <variablelist>
     <varlistentry>
      <term><option>-f</option> <replaceable>format</replaceable></term>
      <term>
       <option>&dashdash;format</option> 
       <replaceable>format</replaceable>
      </term>
      <listitem>
       <para>For details about this option, see the description of the 
       <command>qmtest run</command> command.</para>
      </listitem>
     </varlistentry>
  
     <varlistentry>
      <term><option>-O</option> <replaceable>file</replaceable></term>
      <term>
       <option>&dashdash;option</option> <replaceable>file</replaceable>
      </term>
      <listitem>
       <para>For details about this option, see the description of the 
       <command>qmtest run</command> command.</para>
      </listitem>
     </varlistentry> 
    </variablelist>
   </section>
  </section> <!-- sec-testcmd-summarize -->

  <section id="sec-env-vars">
  <title>Environment Variables</title>

  <para>&qmtest; recognizes the following environment variables:</para>

  <variablelist>
   <varlistentry>
    <term>
     <envar>QM_PYTHON</envar>
    </term>
    <listitem>
     <para>If this environment variable is set, &qmtest; uses it as as
     the path to the Python interpreter.  If this environment variable
     is not set, &qmtest; looks for a file named
     <filename>python</filename> in the <filename>bin</filename>
     directory where QM is installed.  If this file does not exist,
     &qmtest; searches for <filename>python</filename> in the
     directories listed in the <envar>PATH</envar> environment
     variable.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <envar>QMTEST_CLASS_PATH</envar>
    </term>
    <listitem>
     <para>If this environment variable is set, it should contain a
     list of directories in the same format as used for the system's
     <envar>PATH</envar> environment variable.  These directories
     are searched (before the directories that &qmtest; searches by
     default) when looking for extension classes such as test classes
     and database classes.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <envar>QMTEST_DB_PATH</envar>
    </term>
    <listitem>
     <para>If this environment variable is set, its value is used as
     the location of the test database, unless the
     <option>&dashdash;tdb</option> (<option>-D</option>) option is
     used.  If this environment variable is not set and the
     <option>&dashdash;tdb</option> option is not used, the current
     directory is used as the test database.</para>
    </listitem>
   </varlistentry>
  </variablelist>
    
  </section> <!-- sec-env-vars -->
  
 </section>

 <section id="sec-ref-classes">
  <title>Test and Resource Classes</title>

  <para>This section describes test classes and resource classes
  included with &qmtest;.  <xref linkend="sec-writing-test-classes"/>
  provides instructions for writing your own test classes, <xref
  linkend="sec-writing-resource-classes"/> for resource classes.</para>

  <section id="sec-ref-test-classes">
   <title>Test Classes</title>

   <section id="sec-exectest">
    <title><classname>command.ExecTest</classname></title>

    <para>The <classname>command.ExecTest</classname> test class runs a
    program from an ordinary executable file.  Each test specifies the
    program executable to run, its full command line, and the data to
    feed to its standard input stream.  <classname>ExecTest</classname>
    collects the complete text of the program's standard output and
    standard error streams and the program's exit code, and compares
    these to expected values specified in the test.  If the standard
    output and error text and the exit code match the expected values,
    the test passes.</para>

    <para>A <classname>command.ExecTest</classname> test supplies the
    following arguments:</para>

    <glosslist>
     <glossentry>
      <glossterm><property>Program</property> (text field)</glossterm>
      <glossdef>
       <para>The name of the executable file to run.
       <classname>command.ExecTest</classname> attempts to locate the
       program executable in the path specified by the
       <property>path</property> property of the test context.</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Argument List</property> (set of strings)</glossterm>
      <glossdef>
       <para>The argument list for the program.  The elements of this
       set are sequential items from which the program's argument list
       is constructed.  <classname>command.ExecTest</classname>
       automatically prepends an implicit zeroth element, the full path
       of the program.</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Standard Input</property> (text
      field)</glossterm>
      <glossdef>
       <para>Text or data to pass to the program's standard input
       stream.  This data is written to a temporary file, and the
       contents of the file are directed to the program's standard
       input stream.</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Environment</property> (set of strings)</glossterm>
      <glossdef>
       <para>The environment (i.e. the set of environment variables)
       available to the executing program.  Each element of this
       argument is a string of the form
       "<replaceable>VARIABLE</replaceable>=<replaceable>VALUE</replaceable>".</para>

       <para><classname>command.ExecTest</classname> adds additional
       environment variables automatically.  Each context property is
       accessible as an environment variable; the name of the
       environment variable is the name of the context property,
       prefixed with "<envar>QMV_</envar>".</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Expected Exit Code</property> (integer
      field)</glossterm>
      <glossdef>
       <para>The exit code value expected from the program.  If the
       program produces an exit code value different from this one, the
       test fails.</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Expected Standard Output</property>
      (text field)</glossterm>
      <glossdef>
       <para>The text or data which the program is expected to produce
       on its standard output stream.  The actual text or data written
       to standard output is captured, and
       <classname>command.ExecTest</classname> performs a bytewise
       comparison to the expected text or data.  If they do not match,
       the test fails.</para>
      </glossdef>
     </glossentry>

     <glossentry>
      <glossterm><property>Expected Standard Error</property>
      (text field)</glossterm>
      <glossdef>
       <para>The text or data which the program is expected to produce
       on its standard error stream.  The actual text or data written to
       standard error is captured, and
       <classname>command.ExecTest</classname> performs a bytewise
       comparison to the expected text or data.  If they do not match,
       the test fails.</para>
      </glossdef>
     </glossentry>

    </glosslist>

   </section> <!-- sec-exectest -->

   <section id="sec-commandtest">
    <title><classname>command.ShellCommandTest</classname></title>

    <para><classname>command.ShellCommandTest</classname> is very
    similar to <classname>command.ExecTest</classname>, except that it
    runs a program via the shell rather than directly.  Instead of
    specifying an executable to run and the elements of its argument
    list, a test provides a single command line.  The shell is
    responsible for finding the executable and constructing its
    argument list.</para>

    <para>Standard input and the environment are specified in the test.
    The test passes if the command produces the expected standard
    output, standard error, and exit code.</para>

    <para>Note that most shells create local shell variables to mirror
    the contents of the environment when the shell starts up.
    Therefore, the environment set up by a
    <classname>command.ShellCommandTest</classname>, including the contents
    of the test context, are directly accessible via shell variables.
    The syntax to use depends on the particular shell.</para>

    <para><classname>command.ShellCommandTest</classname> has the same fields
    as <classname>command.ExecTest</classname>, except that the
    <property>Program</property> and <property>Argument List</property>
    properties are replaced with these:</para>

    <glosslist>
     <glossentry>
      <glossterm><property>Command</property> (text field)</glossterm>
      <glossdef>
       <para>The command to run.  The command is delivered verbatim to
       the shell.  The shell interprets the command according to its own
       quoting rules and syntax.</para>
      </glossdef>
     </glossentry>
    </glosslist>

   </section> <!-- sec-commandtest -->

   <section id="sec-scripttest">
    <title><classname>command.ShellScriptTest</classname></title>

    <para><classname>command.ShellScriptTest</classname> is an extension of
    <classname>command.CommandTest</classname> that lets a test specify
    an entire shell script instead of a single command.  The script
    specified in the test is written to a temporary file, and this file
    is interpreted by the specified shell or command interpreter
    program.</para>

    <para>Standard input, the environment, and the argument list to pass
    to the script are specified in the test.  The test passes if the
    script produces the expected standard output, standard error, and
    exit code.</para>

    <para>Note that most shells create local shell variables to mirror
    the contents of the environment when the shell starts up.
    Therefore, the environment set up by a
    <classname>command.ShellScriptTest</classname>, including the contents of
    the test context, are directly accessible via shell variables.  The
    syntax to use depends on the particular shell.</para>

    <para><classname>command.ShellScriptTest</classname> has the same fields
    as <classname>command.ExecTest</classname>, except that the
    <property>Program</property> property is replaced with:</para>

    <glosslist>
     <glossentry>
      <glossterm><property>Script</property> (text field)</glossterm>
      <glossdef>
       <para>The text of the script to run.</para>
      </glossdef>
     </glossentry>
    </glosslist>

   </section> <!-- sec-scripttest -->

  </section> <!-- sec-ref-test-classes -->

 </section> <!-- sec-ref-classes -->

 <section id="sec-ref-targets">
  <title>Test Targets</title>

  <para>Test targets represent entities that &qmtest; uses to run
  tests.  See <xref linkend="sec-targets"/> for an overview of how
  &qmtest; uses targets.</para>

  <section id="sec-target-specification">
   <title>Target Specification</title>

   <para>Each target specification includes the following:</para>

   <orderedlist>
    <listitem>
     <para>The name of the target.  This is a name identifying the
     target, such as the host name of the computer which will run the
     tests.  Target names should be unique in a single target
     file.</para>
    </listitem>

    <listitem>
     <para>The <firstterm id="def-target-class">target
     class</firstterm>.  Similar to a test class, a target class is a
     Python class which implements a type of target.  As with test
     classes, a target class is identified by its name, which includes
     the module name and the class name.</para>

     <para>For example,
     <classname>thread_target.ThreadTarget</classname> is the name of
     a target class, provided by &qmtest;, which runs tests in
     multiple threads on the local computer.</para>

     <para>&qmtest; includes several target class implementations.  See
     <xref linkend="sec-target-classes"/> for details.</para>
    </listitem>

    <listitem>
     <para>A <link linkend="def-target-group">target group</link> name.
     The test implementor may choose the syntax of target group names in
     a test implementation.  Target groups may be used to encode
     information about target attributes, such as architecture and
     operating system, and capabilities.</para>
    </listitem>

    <listitem>
     <para>A <firstterm
     id="def-target-concurrency">concurrency</firstterm> value, which
     must be a positive integer.  Most target classes support concurrent
     execution of multiple tests on the target.  This number allows the
     target specification to control how many tests are executed
     simultaneously.</para>
    </listitem>

    <listitem>
     <para>Optionally, a target specification may include additional
     properties.  Properties are named and have string values.  Some
     target classes may use property information to control their
     configuration.  For instance, a target class which executes tests
     on a remote computer would extract the network address of the
     remote computer from a target property.</para>
    </listitem>
   </orderedlist>

  </section> <!-- sec-target-specifation -->

  <section id="sec-target-files">
   <title>Target Files</title>

   <para>In a <firstterm id="def-target-file">target file</firstterm>,
   you specify the computers or other test targets on which &qmtest; runs
   tests.  Use the <link
   linkend="opt-test-run-targets"><option>&dashdash;targets</option>
   (<option>-T</option>) option</link> to the <command>&qmtest-cmd;
   run</command> command to specify the target file.</para>

   <para>A target file is an XML document containing elements
   representing <link linkend="sec-target-specification">target
   specifications</link>.  The document type is
   <literal>-//Software&nbsp;Carpentry//QMTest&nbsp;Target&nbsp;V0.1//EN</literal>,
   and the document element is <sgmltag
   class="element">targets</sgmltag>.</para>

   <para>Each target specification is represented by a 
   <sgmltag class="element">target</sgmltag> element, and includes
   <sgmltag class="element">name</sgmltag>, 
   <sgmltag class="element">class</sgmltag>, 
   <sgmltag class="element">group</sgmltag>, and 
   <sgmltag class="element">concurrency</sgmltag> elements.  Additional
   <sgmltag class="element">property</sgmltag> elements may provide
   target properties.</para>

   <para>For example, the following target file specifies two targets
   for running tests.</para>

   <programlisting>
<![CDATA[<?xml version='1.0' encoding='ISO-8859-1'?>
<!DOCTYPE targets PUBLIC "-//Software Carpentry//QMTest Target V0.1//EN" "http://www.software-carpentry.com/qm/xml/target.dtd">
<targets>
 <target>
  <name>local</name>
  <class>thread_target.ThreadTarget</class>
  <group>i386-pc-linux-gnu</group>
  <concurrency>1</concurrency>
 </target>
 <target>
  <name>remote</name>
  <class>rsh_target.RSHTarget</class>
  <group>sparc-sun-solaris2.5.1</group>
  <concurrency>2</concurrency>
  <property name="host">sunshine</property>
  <property name="arguments">-l test</property>
 </target>
</targets>
]]>
  </programlisting>

  <para>The first target is the <link
  linkend="sec-subprocess-target">local</link> GNU/Linux computer.  The
  second target is a remote computer running SPARC Solaris.  &qmtest;
  invokes tests on the remote target using a <link
  linkend="sec-remote-shell-target">remote shell</link> invocation.  The
  remote computer's name is "sunshine", and two tests are run
  concurrently on that target.</para>

  </section> <!-- sec-target-files -->

  <section id="sec-target-classes">
   <title>Target Classes</title>

   <para>&qmtest; includes these target class implementations.</para>

   <section id="sec-subprocess-target">
    <title>Thread Target</title>

    <para>The <classname>thread_target.ThreadTarget</classname> target
    class runs tests in one or more threads on the local computer
    (the computer on which the &qmtest-cmd; command is invoked).  The
    number of threads is the degree of concurrency specified for
    the target.</para>

   </section> <!-- sec-subprocess-target -->

   <section id="sec-remote-shell-target">
    <title>Remote Shell Target</title>

    <para>The <classname>rsh_target.RSHTarget</classname>
    target class runs tests on a remote computer via a remote shell
    invocation (<command>rsh</command>, <command>ssh</command>, or
    similar).  This target uses a remote shell to invoke a program
    similar to the &qmtest-cmd; command on the remote computer.  This
    remote program accepts test commands and responds with results from
    running these tests.</para>

    <para>To use <classname>RSHTarget</classname>, the remote
    computer must have &qmtest; installed and must contain an identical
    copy of the test database.  &qmtest; does not transfer entire tests
    over the remote shell connection; instead, it relies on the remote
    test database for loading tests.</para>

    <para>In addition, the remote shell program must be configured to
    allow a remote login without additional intervention (such as typing
    a password).  If you use <command>rsh</command>, you can use an
    <filename>.rhosts</filename> file to set this up.  If you use
    <command>ssh</command>, you can use an SSH public key and the
    <command>ssh-agent</command> program for this.  See the
    corresponding manual pages for details.</para>

    <para>The concurrency value of the target specification controls
    the number tests that may be run concurrently on the remote
    host.</para>

    <para>The <classname>RSHTarget</classname> target class
    takes its configuration from the following target properties:</para>

    <itemizedlist>
     <listitem>
      <para>The <property>remote_shell</property> property specifies the
      path to the remote shell program.  If omitted, the configuration
      variable <property>remote_shell</property> is used instead.  If
      neither is specified, the default is
      <filename>/usr/bin/ssh</filename>.  The remote shell program must
      accept the same command-line syntax as
      <command>rsh</command>.</para>
     </listitem>

     <listitem>
      <para>The <property>host</property> property specifies the remote
      host name.  If omitted, the target name is used.</para>
     </listitem>

     <listitem>
      <para>The <property>database_path</property> property specifies
      the path to the test database on the remote computer.  The test
      database must be identical to the local test database.  If
      omitted, the local test database path is used.</para>
     </listitem>

     <listitem>
      <para>The <property>arguments</property> property specifies
      additional command-line arguments for the remote shell program.
      The value of this property is split at space characters, and the
      arguments are added to the command line before the name of the
      remote host.</para>

      <para>For example, if you are using the <command>ssh</command>
      remote shell program and wish to log in to the remote computer
      using a different user account, specify the <literal>-l
      username</literal> option using the <property>arguments</property>
      property.</para>
     </listitem>

     <listitem>
      <para>&qmtest; uses the remote shell to invoke the
      <command>qmtest_remote</command> program on the remote host.  This
      program is installed by default in
      <filename>/usr/local/bin/qmtest_remote</filename>.  You may
      override this and use a version in a different place by specifying
      the <property>qmtest_remote</property> property.</para>
     </listitem>
    </itemizedlist>

   </section> <!-- sec-remote-shell-target -->

  </section> <!-- sec-target-classes -->

 </section> <!-- sec-ref-targets -->

 <section id="sec-writing-test-and-resource-classes">
  <title>Writing Test and Resource Classes</title>

  <para>You can implement many tests using the test classes supplied
  with &qmtest;.  However, expert test implementors may wish to create
  new test classes to customize existing tests or implement new testing
  behavior.  In addition, implementors will wish to create resource
  classes, to add customized setup and cleanup behavior to tests and
  groups of tests.</para>

  <section id="sec-writing-test-classes">
   <title>Writing Test Classes</title>

   <para>In &qmtest;, a test class is represented by a Python class.
   The class must inherit from
   <classname>qm.test.test.Test</classname>.  The class must include
   two things: an <varname>arguments</varname>
   attribute, whose value is a sequence of field objects, and a 
   <function>Run</function> function.</para>

   <section>
    <title>The <varname>arguments</varname> Attribute</title>

    <para>The test class must include an <varname>arguments</varname>
    attribute, indicating the types of the test class's parameters.  The
    <varname>arguments</varname> attributes value should be a sequence
    consisting of field objects.  A field object is an instance of a
    subclass of <classname>qm.fields.Field</classname>.  The names of
    the arguments (specified by the "name" attribute of the field object)
    are the names of the parameters of the test class.</para>

    <para>For instance, this definition of the <varname>arguments</varname>
    attribute declares two parameters for the test class.  One
    parameter, called &quot;input_text&quot;, takes a text value.  The
    other parameter, called &quot;value_list&quot;, takes a
    set of integers.</para>

    <programlisting>
<![CDATA[    arguments = [
        qm.fields.IssueFieldText(
            name="input_text"),
        qm.fields.IssueFieldSet(qm.fields.IssueFieldInteger(
            name="value_list")),
        ] 
]]>
    </programlisting>

    <para>Test classes should also initialize the
    <varname>title</varname> and <varname>description</varname>
    attributes of each field.  The values of these attributes help users
    of the test class identify the purpose and semantics of each of the
    test class's parameters.</para>

   </section> <!-- The arguments Attribute -->

   <section id="sec-run-function">
    <title>The <function>Run</function> Function</title>

    <para>The heart of the test class is the <function>Run</function>
    function.  This function runs the test and produces a test
    result.</para>

    <para>The <function>Run</function> function takes two arguments:
    the context and the result.  The context object satisfies the
    interface of the <classname>qm.test.context.Context</classname>
    Python class (though it may in actuality be an instance of a
    different Python class).</para>

    <para>The result object is an instance of
    <classname>qm.test.result.Result</classname>.  By default, the
    result will indicate that the test passes.  If the test fails, the
    test class should call the <function>Fail</function> method on the
    result to indicate failure.</para>

    <para>If the <function>Run</function> raises an unhandled exception,
    &qmtest; creates a result for the test with the outcome &ERROR;.
    Test classes should be designed so that they do not raise unhandled
    exceptions in the course of normal use (including test failures).
    An unhandled exception should reflect an internal error in the
    implementation of the test class.</para>

   </section> <!-- The Run Function -->

   <section>
    <title>Using the Context</title>

    <para>A context object is simply a dictionary of properties.  Use
    Python's map syntax to access a context's properties.  A property
    key is always a string composed of lower-case letters and
    underscores.  Property values are strings.</para>

    <para>A test's <function>Run</function> function only sees context
    properties added by &qmtest; itself and properties added by the
    setup functions of required resources.</para>

   </section> <!-- Using the Context -->

   <section id="sec-creating-results">
    <title>Creating Results</title>

    <para>In case of a &FAIL; result, it is conventional to assign the
    <literal>Result.CAUSE</literal> property a string value providing
    a description of why the test failed.  These two equivalent examples demonstrate how to indicates
    test failure (both assume that the
    <classname>qm.test.result.Result</classname> class has been
    imported into the module's global namespace).</para>

    <programlisting>
<![CDATA[        result.Fail()
        result[Result.CAUSE] = "Unexpected end of input."]]>
    </programlisting>

    <para>or</para>

    <programlisting>
<![CDATA[        result.Fail("Unexpected end of input.")]]>
    </programlisting>

    <para>Sometimes, a <function>Run</function> function implementation
    detects a failure by catching an exception.  The method
    <function>Result.NoteException</function> provides
    a convenient mechanism for creating a result that includes
    information about the exception.  For
    example: 

    <programlisting>
<![CDATA[        try:
            # ... run test code here ...
        except EndOfFileError:
            result.NoteException()
]]>
    </programlisting>

    The <function>NoteException</function> method will automatically
   add annotations describing the cause of the exception.</para>
   </section> <!-- Creating Results -->

  </section> <!-- Writing Test Classes -->

  <section id="sec-writing-resource-classes">
   <title>Writing Resource Classes</title>

   <para>Writing resource classes is similar to writing test classes.
   The requirements are the same except that, instead of a <link
   linkend="sec-run-function"><function>Run</function></link>
   function, you must provide two functions named
   <function>SetUp</function> and <function>CleanUp</function> to
   perform resource setup and cleanup.  The <function>SetUp</function>
   function must have the same signature as a test classs
   <function>Run</function>.  The <function>CleanUp</function>
   function is similar, but does not take a
   <parameter>context</parameter> parameter.</para>

   <para>The setup function may add additional properties to the
   context.  These properties will be visible only to tests that
   require this resource.  To insert a context property, use Python's
   map assignment syntax.</para>

   <para>Below is an example of setup and cleanup functions for a
   resource which calls <function>create_my_resource</function> and
   <function>destroy_my_resource</function> to do the work of creating
   and destroying the resource.  The resource is identified by a
   string handle, which is inserted into the context under the name
   <literal>Resource.handle</literal>, where it may be accessed by
   tests.  Context property names should always have the form
   <literal>Class.name</literal> so that there is no risk of collision
   between properties created by different resource classes.</para>

   <programlisting>
    def SetUp(self, context, result):
        try:
            handle = create_my_resource()
            self.__handle = handle
        except:
            result.NoteException()
        else:
            context["resource_handle"] = str(handle)

    def CleanUp(self, result):
        try:
            destroy_my_resource(self.__handle)
        except:
            result.NoteException()
   </programlisting>

  </section> <!-- sec-writing-resource-classes -->

  <section id="sec-specifying-test-class">
   <title>Specifying a Test or Resource Class</title>

   <para>To use your test or resource class, you must place the Python
   module file containing it in a location where &qmtest; can find it.
   &qmtest; looks in three places when loading module files for test and
   resource classes:</para>

   <itemizedlist>
    <listitem>
     <para>If the environment variable <envar>QMTEST_CLASS_PATH</envar>
     is defined, &qmtest first checks any directories listed in it.
     This value of this environment variable should be a list of
     directories to check for the module file, in the same format as
     the standard <envar>PATH</envar> environment variable.</para>
    </listitem>

    <listitem>
     <para>A test database may specify locations to check for module
     files when loading a class.  &qmtest; test database implementations
     generally check the subdirectory named <filename>QMTest</filename>
     in the top test database directory for test and resource classes.
     (Note that &qmtest; may place other files in this directory; you
     should not disturb them.)  Module files containing test and
     resource classes may be placed in this directory.</para>
    </listitem>

    <listitem>
     <para>Finally, &qmtest; checks a standard directory.  This
     directory, installed with &qmtest;, contains modules with the
     standard test classes described in <xref
     linkend="sec-ref-classes"/>.</para>
    </listitem>
   </itemizedlist>

   <para>You should generally place module files containing your test
   classes in the test database's test class directory, unless you plan
   to use the test classes in more than one test database.</para>

   <para>Assuming the Python module file containing the test class is
   located in one of the directories specified above, you can refer to
   it using the syntax <classname>module.Class</classname>, where
   <classname>module</classname> is the name of the module and
   <classname>Class</classname> is the name of the class.</para>

  </section> <!-- sec-specifying-test-class -->

 </section> <!-- sec-writing-test-and-resource-classes -->

 <section id="sec-ref-writing-database-classes">
  <title>Writing a Database Class</title>

  <para>The database class controls the format in which tests are
  stored.  &qmtest's default database class stores each test as an XML
  file, but you might want to use a format that is particularly well
  suited to your application domain or to your organization's
  arrangement of computing resources.</para>

  <para>For example, if you were testing a compiler, you might want to
  represent tests as source files with special embedded comments
  indicating what errors are expected when compiling the test.  You
  could write a test database class that can read and write tests
  in that format.</para>

  <para>Or, if you wanted to share a single test database with many
  people in such a way that everyone automatically saw updates to the
  database, you might want to put all of the tests on a central HTTP
  server.  You could write a test database class that retrieves tests
  from the server and creates new tests by uploading them to the
  server.</para>

  <para>A test database class is a Python class that is derived from
  <classname>qm.test.database.Database</classname>.  You must define
  methods that handle retrieving a test from the database, writing a
  test to the database, and other related tasks.  Read the code for
  <classname>qm.test.database.Database</classname> to see what methods
  need to be overridden.
  </para>
  
  <para>To use your new database class, create a new test database using
  the <link
  linkend="sec-testcmd-create-tdb"><option>&dashdash;class</option>
  (<option>-c</option>) option</link>.</para>

 </section> <!-- sec-ref-writing-database-classes -->

</chapter>
<!--
  Local Variables:
  mode: sgml
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("manual.xml" "book" "chapter")
  End:
-->
