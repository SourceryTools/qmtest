<?xml version="1.0"?>
<!--

  File:   track-manual.xml
  Author: Alex Samuel
  Date:   2001-05-25

  Contents:
    Manual for QMTrack.

  Copyright (C) 2001 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<chapter id="chap-track-manual">
 <title>Using &qmtrack;</title>
 
  <para>This chapter describes &qmtrack; in more detail.  It explains
  the basic concepts underlying &qmtrack; and how to use the &qmtrack;
  graphical user interface.</para>

 <section id="sec-qmtrack-concepts">
  <title>&qmtrack; Concepts</title>

  <para>This section describes the basic concepts of &qmtrack;.</para>

  <section id="sec-issues">
   <title>Issues</title>

   <para>An <firstterm>issue</firstterm> is the fundamental record of
   information in &qmtrack;.  An issue represents a single bug,
   problem report, enhancement request, etc. stored in &qmtrack;'s
   database.</para>

   <para>An issue is usually represented in &qmtrack;'s user
   interfaces as a form.  The form is made of fields, and the issue
   has a value for each field.  The value may, for some fields, be
   empty.  Like the blanks of a preprinted form, the fields in an
   issue define a standard set of information that is provided for
   each issue.</para>

  </section> <!-- sec-issues -->

  <section id="sec-issue-ids">
   <title>Issue IDs</title>

   <para>Each issue is represented by a unique <firstterm>issue
   ID</firstterm>, or <firstterm>IID</firstterm>.  The issue ID is a
   tag composed of lower case letters, digits, and underscores.</para>

   <para>When you create a new issue, you may choose any issue ID you
   wish, unless another issue already exists with the same issue ID in
   the issue database, or unless the issue database has been
   configured to assign issue IDs automatically.  Try to choose an
   issue ID that is short, and that is reminiscent of the just of the
   issue.</para>

  </section> <!-- sec-issue-ids -->

  <section id="sec-issue-classes">
   <title>Issue Classes</title>

   <para>Not all issues need have the same fields.  An
   <firstterm>issue classes</firstterm> defines a schema of fields
   that may be used for an issue.  Each issue belongs to a single
   issue class, which defines the fields that are present in the
   issue.  Issue classes are configured as part of the &qmtrack;
   database.</para>

   <para>When you create a new issue, you must choose one of the
   available issue classes for the new issue.  Once an issue has been
   created, its issue class cannot be changed.</para>

  </section> <!-- sec-issue-classes -->

  <section id="sec-revisions">
   <title>Revisions</title>

   <para>An issue is typically modified over the course of its
   lifetime.  For example, as a bug is analyzed and subsequently
   fixed, information and annotations are added to the bug report, and
   finally the bug is closed.</para>

   <para>When you change an issue, &qmtrack; does not simply discard
   the old version.  In fact, &qmtrack; preserves all the versions of
   each issue since its creation.  These versions are called
   <firstterm>revisions</firstterm>.  This allows you to view an
   issue's complete revision history.</para>

   <para>Revisions are numbered sequentially, starting with zero for
   an issue's initial revision.  Most users need not concern
   themselves with revision numbers, though, since they will generally
   be interested only with the highest-numbered revision of any issue,
   the <firstterm>current revision</firstterm>.</para>

  </section> <!-- sec-revisions -->

 </section> <!-- sec-qmtrack-concepts -->

 <section id="sec-qmtrack-gui">
  <title>Using the &qmtrack; GUI</title>

  <para>The &qmtrack; graphical user interface allows you to to
  manage issues from any web browser.</para>

  <para>Before accessing other functions of &qmtrack;, you should log
  in to the system.  Enter the user name and password provided you by
  your &qmtrack; administrator in the box on the left hand side of the
  screen.  Once you have done this, the login box will be replaced by
  a <guibutton>Log Out</guibutton> button.  Use this button when you
  are done using &qmtrack;.</para>

  <para>To create a new issue, select an issue class from the list of
  choices under the <guilabel>Create a New Issue</guilabel> heading
  and then click the <guibutton>New</guibutton> button.  &qmtest; will
  display a form prompting you for information about the issue.  The
  <guilabel>help</guilabel> link to the right of each field provides
  more information about the field, including the kinds of values that
  may be stored there.  When you are finished describing the issue,
  click the <guibutton>OK</guibutton> at the bottom of the
  page.</para>
 
  <para>To view an exsiting issue, return to the main page and enter
  an issue id in the box marked <guilabel>Show or Edit an Existing
  Issue</guilabel> and then click the <guibutton>Show</guibutton>
  button.  &qmtest; will display the current state of the issue.  By
  clicking the <guibutton>Edit Issue</guibutton> button in the
  upper-right corner, you can revise the issue description, using a
  form similar to the one used to create a new issue.  Alternatively,
  you can use the <guibutton>Show History</guibutton> to view the
  complete history of the issue.  This feature allows you to
  reconstruct every change that has been made to the issue over
  time.</para>

  <para>To find an issue, or a set of issues, click on the
  <guilabel>Search</guilabel> link at the top of every page. You can
  search by category or state using the controls in the
  <guilabel>Browse Issues</guilabel> box.  To perform more
  sophisticated searches, use the <guilabel>Python Query</guilabel>
  box.  The syntax used for searching in this box is a subset of the
  Python expression syntax.  Click the <guilabel>Help</guilabel> link
  in this box for a complete description of the synax.</para>

  <para>When you are done using &qmtrack;, return to the main page and
  click the <guibutton>Log Out</guibutton> button.</para>

 </section>

 <!-- This section is temporarily omitted, pending implementation of the
      features described.  -->
 <!-- &track-email.xml; -->

 <section id="sec-qmtrack-configuration">
  <title>Issue Database Configuration</title>

  <para>This section describes the components of an issue database, and
  how to configure them.</para>

  <section id="sec-triggers">
   <title>Triggers</title>

   <para>A <firstterm>trigger</firstterm> is code that is run when an
   issue is accessed.  A trigger runs when the issue is retrieved from
   the issue database, and when the issue is modified in the issue
   database (or a new issue is created).  There are three different
   trigger behaviors:</para>

   <itemizedlist>
    <listitem>
     <para>A trigger's "<firstterm>get</firstterm>" code is invoked when
     an issue is retrieved from the issue database.  The trigger may
     forbid the issue's retrieval; this enables the use of triggers for
     controlling access to issues.</para>
    </listitem>

    <listitem>
     <para>A trigger's "<firstterm>preupdate</firstterm>" code is
     invoked before an issue is changed in the issue database (or before
     a new issue is inserted).  The trigger may forbid the change; this
     enables the use of triggers for controlling changes to
     issues.</para>
    </listitem>

    <listitem>
     <para>A trigger's "<firstterm>postupdate</firstterm>" code is
     invoked after an issue is changed in the issue database (or after a
     new issue is inserted).</para>
    </listitem>

   </itemizedlist>

   <para>Triggers are configured independently for each issue class, and
   each issue class may have more than one trigger.</para>
 
  </section> <!-- sec-triggers -->

 </section> <!-- sec-qmtrack-configuration -->

 <section id="sec-writing-triggers">
  <title>Writing Trigger Classes</title>

  <para>A <link linkend="sec-triggers">trigger</link> contains code that
  is run when an issue is retrieved or stored in the issue database.
  Each <link linkend="sec-issue-classes">issue class</link> can be
  configured with one or more triggers, and triggers are invoked
  sequentially when an issue of that issue class is retrieved or
  stored.</para>

  <para>Triggers are represented by Python objects.  A trigger object is
  an instance of a <firstterm>trigger class</firstterm>, which is a
  subclass of the <classname>qm.track.issue_class.Trigger</classname>
  class.  By writing your own trigger class and adding triggers of this
  class to your issue classes, you can implement a wide variety of
  custom behavior in &qmtrack;.</para>

  <para>Instead of using ordinary Python attributes, a trigger class
  stores its configuration settings in named
  <firstterm>properties</firstterm>, whose values are strings.  The
  class may use the <function>GetProperty</function> and
  <function>SetProperty</function> methods of
  <classname>qm.track.issue_class.Trigger</classname> to set and get
  property values.  In addition, the class must declare those properties
  which compose the trigger's persistent configuration with the
  <varname>property_declarations</varname> variable (see below); this
  allows &qmtrack; to store and retreive the trigger configuration and
  generate user interfaces for modifying the trigger configuration.  A
  trigger class should use ordinary Python attributes only for transient
  data.</para>

  <para>A trigger class must satisfy the following requirements:</para>
 
  <itemizedlist>
   <listitem>
    <para>The class must be a (direct or indirect) subclass of
    <classname>qm.track.issue_class.Trigger</classname>.</para>
   </listitem>

   <listitem>
    <para>The class must define a class variable
    <varname>class_name</varname>, which contains a string
    representation of the Python class's name, fully-qualified with the
    name of the package containing it.</para>
   </listitem>

   <listitem>
    <para>The class must define a class variable
    <varname>property_declarations</varname>.  This is a tuple of
    <classname>qm.fields.PropertyDeclaration</classname> objects
    describing the properties that comprise the trigger's persistent
    configuration.</para>

    <para>Generally, a trigger classe will define this value by adding
    to the <varname>property_declarations</varname> tuple of its base
    class.  This ensures the base classes properties are included in the
    trigger's configuration.</para>
   </listitem>

   <listitem>
    <para>The class must define an <function>__init__</function>
    function.  This function should have a <varname>name</varname>
    parameter plus parameters for any other properties with values that
    always must be specified when the trigger is created.  The function
    should also accept arbitrary other named arguments, and pass them to
    its base-class <function>__init__</function> function.</para>
   </listitem>

   <listitem>
    <para>The class should redefine the <function>Get</function>
    function, if the trigger is to have "get" behavior.  This function
    is invoked before an issue is retrieved from the issue database, and
    passed the issue as its sole argument.</para>

    <para>The function should return a
    <classname>TriggerResult</classname> object, specifying the
    <literal>ACCEPT</literal> outcome if the retrieval is to continue.
    If the <function>Get</function> function specifies the
    <literal>REJECT</literal> outcome, the retrieval is cancelled, and
    the <function>Get</function> functions of other triggers are not
    run.</para>

    <para>The default <function>Get</function> function specifies the
    <literal>ACCEPT</literal> outcome and takes no other action.</para>
   </listitem>

   <listitem>
    <para>The class should redefine the <function>Preupdate</function>
    function, if the trigger is to have "preupdate" behavior.  This
    function is invoked before an issue is changed in the issue
    database, or before a new issue is inserted.  The function is passed
    two arguments: the first is the new or modified issue; the second is
    the previous revision of the same issue, or <literal>None</literal>
    if it is a new issue.</para>

    <para>The function should return a
    <classname>TriggerResult</classname> object, specifying the
    <literal>ACCEPT</literal> outcome if the issue modification or
    insertion is to continue.  If the <function>Preupdate</function>
    function specifies the <literal>REJECT</literal> outcome, the
    insertion is cancelled, and the <function>Preupdate</function>
    functions of other triggers are not run.</para>

    <para>The default <function>Preupdate</function> function specifies
    the <literal>ACCEPT</literal> outcome and takes no other
    action.</para>
   </listitem>

   <listitem>
    <para>The class should redefine the <function>Postupdate</function>
    function, if the trigger is to have "postupdate" behavior.  This
    function is invoked after an issue is changed in the issue database,
    or after a new issue is inserted.  The function is passed two
    arguments: the first is the new or modified issue; the second is the
    previous revision of the same issue, or <literal>None</literal> if
    it is a new issue.</para>

    <para>The <function>Postupdate</function> function's return value is
    ignored.  Since it is invoked after the issue modification or
    insertion has been committed to the issue database, it cannot
    prevent the action.</para>
   </listitem>

  </itemizedlist>

  <section id="sec-trigger-results">
   <title>Trigger Results</title>

   <para>The <function>Get</function> and <function>Preupdate</function>
   functions of a trigger class should return an instance of
   <classname>qm.track.issue_class.TriggerResult</classname>, specifying
   the result of the trigger operation.  The initialzer for
   <classname>TriggerResult</classname> takes three arguments:</para>

   <itemizedlist>
    <listitem>
     <para><varname>trigger</varname> is the trigger which produced the
     result.  This will normally be <literal>self</literal> in a
     trigger's <function>Get</function> or
     <function>Preupdate</function> function.</para>
    </listitem>

    <listitem>
     <para><varname>outcome</varname> is the trigger outcome, and should
     be one of
     <varname>qm.track.issue_class.TriggerResult.ACCEPT</varname> or
     <varname>qm.track.issue_class.TriggerResult.REJECT</varname>.  The
     former indicates that the operation should be allowed to continue
     (pending acceptance by other triggers); the latter stops processing
     of the operation immediately.</para>
    </listitem>

    <listitem>
     <para><varname>message</varname> is an option argument containing a
     string message describing the trigger's operation.  The message is
     used only if the outcome is <literal>REJECT</literal>.  A
     <function>Get</function> or <function>Preupdate</function> function
     that returns a <literal>REJECT</literal> outcome should specify a
     message, to indicate to the user the reason that the operation was
     rejected.</para>
    </listitem>

   </itemizedlist>

  </section> <!-- sec-trigger-results -->

  <section id="sec-trigger-example">
   <title>Example</title>

   <para>The following is a simple trigger class which validates a text
   field.  The trigger rejects modifications to an issue (or insertion
   of a new issue) which leave the value of specific text field empty.
   The name of the field to validate is specified by the
   <literal>field_name</literal> attribute.</para>

   <programlisting>
<![CDATA[import string
from qm.fields import PropertyDeclaration
from qm.track.issue_class import Trigger, TriggerResult

class TextFieldValidateTrigger(Trigger):
    class_name = "custom_triggers.TextFieldValidateTrigger"

    property_declarations = Trigger.property_declarations + (
        PropertyDeclaration(
            name="field_name",
            description="The name of the field to validate.",
            default_value="")
    )

    def __init__(self, name, field_name, **properties):
        # Initialize the base class.
        apply(Trigger.__init__, (name, ), properties)
        # The field name is part of the trigger's configuration.  Store
        # it as a property.
        self.SetProperty("field_name", field_name)

    def PreUpdate(self, issue, previous_issue):
        # Extract the field name from the "field_name" property.
        field_name = self.GetProperty("field_name")
        # Get this issue's value of that field.
        field_value = issue.GetField(field_name)
        # Is it empty?
        if string.strip(field_value) == "":
            # Yes.  Reject the change.
            return TriggerResult(self, TriggerResult.REJECT,
                "The %s field is empty." % field_name)
        else:
            # Not empty.  Allow the modification to continue.
            return TriggerResult(self, TriggerResult.ACCEPT)
        
]]>
   </programlisting>   

   <para>This class should be placed in a package named
   <filename>custom_triggers</filename>, accessible from the
   <envar>PYTHONPATH</envar>.</para>

  </section> <!-- sec-trigger-example -->

 </section> <!-- sec-writing-triggers -->

</chapter> <!-- chap-track-manual -->
<!--
  Local Variables:
  mode: sgml
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("manual.xml" "book" "chapter")
  End:
-->
