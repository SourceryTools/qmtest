<?xml version="1.0"?>
<!--

  File:   test-tour.xml
  Author: Alex Samuel
  Date:   2000-11-01

  Contents:
    Grand tour/tutorial of QMTest.

  Copyright (C) 2001 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

-->
<chapter id="chap-test-tour">
 <title>Getting Started with &qmtest;</title>
 
  <para>QMTest is an ogeneral-purpose, cross-platform software testing
  tool.  QMTest can be used to test compilers, databases, graphical
  user interfaces, or embedded systems.  QMTest provides a convenient
  graphical user interface for creating, managing, and executing
  tests, provides support for parallel test execution, and can be
  extended in a variety of ways.</para>

  <para>This chapter will show you how to use &qmtest; by example.
  You will learn how to use &qmtest; to create tests, run tests, and
  examine the results.</para>

  <section id="sec-testtut-setting-up">
   <title>Setting Up</title>

   <para>A test database is a directory that &qmtest; uses to store
   tests.  If you wanted to create a new, empty test database from
   scratch, you would use the <command>&qmtest-cmd; create-tdb</command>
   command, but for this tutorial, you should use the sample test
   database provided with &qmtest;.  Since you'll modify the test
   database later in the tutorial, start by making a copy of it.  Copy
   the entire test database directory tree to another location.  If
   you've installed &qmtest; in the default location
   (<filename>/usr/local</filename>), you can make a copy of the sample
   database in your home directory by running this command:</para>

   <screen>
    &prompt;<userinput>cp -r /usr/local/share/qm/tutorial/test/tdb $HOME/tdb</userinput>
   </screen>

   <para>If you installed &qmtest; in another directory, substitute
   that directory for <filename>/usr/local</filename> in the command
   above.</para>

  </section> <!-- sec-testtut-setting-up -->

  <section id="sec-testtut-running-tests">
   <title>Running Tests</title>

   <para>All of &qmtest;'s functionality is available via the
   &qmtest-cmd; program.  When you invoke &qmtest-cmd;, you specify a
   command argument, which tells the program which action to perform.
   Some commands require additional options and arguments, which you
   place after the command.  There are a few options that apply to all
   commands; to use these options place them before the command name.
   For example, in the command:

   <screen>
    &prompt;<userinput>qmtest -D $HOME/tdb run -f full exec1</userinput>
   </screen>

   the <option>-D $HOME/tdb</option> option is a general &qmtest-cmd;
   option, <command>run</command> is the &qmtest; command, the
   <option>-f full</option> applies to the <command>run</command>
   command, and <filename>exec1</filename> is an argument to the run
   command.  This command tests &qmtest; to run the
   <filename>exec1</filename> test from the test database in
   <filename>$HOME/tdb</filename>, and to use the
   <option>full</option> format when displaying the results.</para>
                        
   <para>To see a list of available commands, and general options to
   &qmtest-cmd;, invoke it with the <option>&dashdash;help</option> (or
   <option>-h</option>) option.  To see a description of each command,
   and additional options specific to that command, invoke
   <command>qmtest <replaceable>command</replaceable>
   &dashdash;help</command>.</para>

   <para>You must always tell &qmtest; which test database to use
   either by specifying the <option>-D</option> option and providing
   the path to the test database, or by setting the environment
   variable <envar>QMTEST_DB_PATH</envar> to the test database
   path.</para>

   <para>From this point on in the tutorial, the examples will assume
   that you have set the <envar>QMTEST_DB_PATH</envar> environment
   variable.  If you're using the Bourne shell, execute these
   commands:</para>

   <screen>
&prompt<userinput>QMTEST_DB_PATH=$HOME/tdb</userinput>
&prompt<userinput>export QMTEST_DB_PATH</userinput>
   </screen>

   <para>If you are using another shell, consult your shell's manual
   for instructions about how to set an environment variable.</para>

   <para>The command for running tests is <command>&qmtest-cmd;
   run</command>.  Assuming you made a copy of the example test
   database as described in the previous section, execute the
   following command to run all the tests in the database:</para>

   <screen>
&prompt;<userinput>qmtest run</userinput>
   </screen>

   <para>&qmtest; runs the tests, and prints a summary of the test
   run:</para>

   <screen><computeroutput><![CDATA[
--- TEST RUN STATISTICS ------------------------------------------------------

       3        tests total
       2 ( 67%) tests PASS
       1 ( 33%) tests FAIL


--- TESTS THAT DID NOT PASS --------------------------------------------------

  exec1                                                          : FAIL    
    Exception evaluating expression. 


]]></computeroutput></screen>

   <para>&qmtest;'s report begins with a summary section containing
   statistics. In this case, three tests were run; two of them passed
   and one failed.  Following the summary, &qmtest; lists the tests
   that did not pass, along with the cause of the failure.</para>
   
  </section> <!-- sec-testtut-running-tests -->

  <section id="sec-testtut-expected-outcomes">
   <title>Expected Test Outcomes</title>

   <para>If the application you are testing has defects, you may have
   tests that are expected to fail.  If you are testing a change to
   the application, you may want to know whether the change makes
   things better or worse.  If you just run the tests as above and
   there are tests that always fail, you will have to keep track of
   which tests are expected to fail.  Otherwise, when you see failures
   you will not know whether your change caused them or not.</para>

   <para>You can use &qmtest; to keep track of expected failures for
   you.  Then &qmtest; can tell you automatically whether or not your
   change caused new failures.</para>

   <para>To take advantage of this feature, you must run &qmtest;
   before making your change and save the results to a file.  Enter
   the command:

   <screen>
&prompt;<userinput>qmtest run -o expected.qmr</userinput>
   </screen>

   to save the results to a file named
   <filename>expected.qmr</filename> instead of the default
   <filename>results.qmr</filename>.</para>

   <para>Now, when you rerun the tests you can tell &qmtest; to use 
   <filename>expected.qmr</filename> as the <firstterm>expected
   results file</firstterm>, like this:

   <screen>
&prompt;<userinput>qmtest run -O expected.qmr</userinput>
   </screen>

   &qmtest; will rerun the tests, but this time it will not mention
   the failure of <filename>exec1</filename>.  The output will look 
   like:

   <screen>
<computeroutput><![CDATA[
--- STATISTICS ---------------------------------------------------------------

       3        tests total
       3 (100%) tests as expected

--- TESTS WITH UNEXPECTED OUTCOMES -------------------------------------------

  None.
]]></computeroutput></screen>

   Note that &qmtest; indicates that there were no tests with
   unexpected outcomes, even though <filename>exec1</filename> still
   fails.</para>

  </section> <!-- sec-testtut-expected-outcomes -->

  <section id="sec-testtut-results">
   <title>Reviewing Results</title>

   <para>When you run tests, &qmtest; creates a <firstterm>results
   file</firstterm> that contains information about the outcomes of
   each test.  You can use the results file to get additional
   information about the tests that failed.  The results file is
   called <filename>results.qmr</filename> and is placed in the
   directory where you ran &qmtest;.</para>
  
   <para>To exaine the results file, use the
   <command>summarize</command> command, like this:
 
   <screen>
&prompt;<userinput>qmtest summarize -f full</userinput>
   </screen>

   The <option>-f full</option> option indicates that the output
   should be displayed in more detail.  The output will look like:

   <screen><computeroutput><![CDATA[
--- STATISTICS ---------------------------------------------------------------

       3        tests total
       2 ( 67%) tests PASS
       1 ( 33%) tests FAIL

--- NON-PASSING TESTS --------------------------------------------------------

  exec1                                                          : FAIL    
    Exception evaluating expression. 

    'qmtest.exception' -- exceptions.ZeroDivisionError: integer division
      or modulo 

    'qmtest.traceback' -- File 
      "/usr/local/lib/qm/qm/test/classes/python.py", line 124, in Run 
      global_namespace, local_namespace) File "<string>", line 0, in ? 

    'qmtest.target' -- local 
]]></computeroutput></screen>

   </para>

   <para>The detailed information indicates what went wrong.  The test
   tried to divide by zero, which resulted in an exception.  The
   information displayed by the <quote>full</quote> format is
   domain-dependent; it depends on the kind of application you are
   testing.  The tests in the sample database test basic functionality
   of the Python interpreter, so the full report contains information
   about Python concepts called exceptions and tracebacks.  If you
   were testing a different application, the full report would contain
   different information.  For example, if you were testing a
   database, the detailed results might refer to queries and
   records.</para>

  </section> <!-- sec-testtut-results -->

  <section id="sec-testtut-examining">
   <title>Using the Graphical Interface</title>

   <para>To examine the tests in the test database, you can use
   &qmtest;'s graphical user interface.  To start the graphical user
   interface, use the <command>qmtest gui</command> command, like
   this: 

   <screen>
&prompt;<userinput>qmtest gui</userinput>
   </screen>

   You will see:

   <screen><computeroutput><![CDATA[
QMTest running at http://127.0.0.1:1158/test/dir
]]></computeroutput></screen>

   </para>

   <para>After a moment, a new web browser window will open, and you
   will see the &qmtest; graphical user interface (GUI).  If a web browser
   window does not open, you will have to manually enter the URL that
   &qmtest; printed out
   (<literal>http://127.0.0.1:1158/test/dir</literal> in the example
   above) into your brwoser.</para>

   <para>The page you see in your browser shows the contents of the
   test database.  You can see that there are three tests in the
   database, named <filename>exec0</filename>, <filename>exec1</filename>,
   and <filename>exec2</filename>.  You can always click on the
   <guilabel>Main Page</guilabel> link in the upper-right corner to
   return to this page.</para>

   <para>Each test name is a hyperlink.  The <filename>exec1</filename>
   hyperlink is the one that is failing.  Click on the corresponding
   hyperlink to see more information about this test.  The first thing
   &qmtest; tells you about a test is the associated <firstterm>test
   class</firstterm>.  In this case, the test is an instance of the
   <classname>python.ExecTest</classname> class.  The test class tells
   you what kind of test <filename>exec1</filename> is. There is a brief
   description of the test class on the line in the GUI.  For more
   detailed information about the test class, you can click on the
   <guilabel>help</guilabel> link to the right of the
   desription.</para>

   <para>Tests that are instances of
   <classname>python.ExecTest</classname>  are composed of two parts:
   a sequence of Python statements, and a Python expression.  When the
   test is run, &qmtest; executes the Python statements, and then
   evaluates the Python expression.  If the expression evaluates to a
   value that Python treates as true, the test passes.</para>

   <para>The sequence of statements and the expression are the
   <firstterm>arguments</firstterm> to the test class.  Every test
   class takes arguments; the arguments are what differentiate one
   instance of a test class from another.  &qmtest; displays the
   argumenst for the <filename>exec1</filename> test in the GUI.  In
   this case, the sequence of statements is simply the single
   statement <literal>pass</literal>, which in Python does nothing.
   The expression is "<literal>3/0</literal>".  This is the division
   by zero that causes the test to fail!</para>

  </section> <!-- sec-testtut-examining -->

  <section id="sec-testtut-modifying">
   <title>Modifying and Creating Tests</title>

   <para>To fix the test, you need to change the arguments to the
   test.  Click on the <guibutton>Edit</guibutton> button in the
   upper-right corner of the page.  &qmtest; will display a form that
   allows you to change the arguments to the test.</para>

   <para>Change the second argument, labelled "Python Expression," to
   an expression that evaluates to true such as <literal>2 + 2 ==
   4</literal>.  Then click on the <guibutton>OK</guibutton> button at
   the bottom of the page to save your changes.  Click on the
   <guibutton>Run</guibutton> button in the upper-right corner of the
   page and observer that the test now passes.</para>

   <para>Creating in a new test works in a similar way.  Click on the
   <guilabel>Main Page</guilabel> link to return to the main &qmtest;
   page.  Then, click on the <guibutton>New Test</guibutton> button to
   create a new test.  &qmtest; displays a form that contains two
   fields: the test name, and the test class.  The test name
   identifies the test; the test class indicates what kind of test
   will be created.</para>

   <para>Test names must be composed entirely of lowercase letters,
   numbers, the <quote>_</quote> character, and the <quote>.</quote>
   character.  You can think of test names like file names.  The
   <quote>.</quote> character takes the place of <quote>/</quote>; it
   allows you to place a test in a particular
   <firstterm>directory</firstterm>.  For example, the test name
   <filename>a.b.c</filename> names a test named
   <filename>c</filename> in the directory <filename>a.b</filename>.
   The directory <filename>a.b</filename> is a subdirectory of the
   directory <filename>a</filename>.  By organizing your tests in
   directories, you will make it easier to keep track of your tests.
   In addition, &qmtest; can automatically run all the tests in a
   particular directory, so by using directories you will make it easy
   to run a group of related tests at once.</para>

   <para>Enter <filename>command.test1</filename> for the test name.
   This will create a new test named <filename>test1</filename> in the
   <filename>command</filename> directory.  Choose
   <classname>command.ExecTest</classname> as the test class.  This
   kind of test runs a command and compares its actual output against
   the expected output.  If they match, the test passes.  This test
   class is useful for testing many programs.  Click on the
   <guibutton>Next</guibutton> button to continue.</para>
   
   <para>Now, &qmtest; will present you with a form that looks just
   like the form you used to edit <filename>exec1</filename>, except
   that the arguments are different.  The arguments are different
   because you're creating a different kind of test.  Enter
   <literal>echo</literal> in the <guilabel>Program</guilabel> field.
   Click on the <guibutton>Add</guibutton> button to add a program
   argument and enter <literal>test</literal> in the popup dialog box.
   At this point, you've told qmtest that you want to run the command
   <command>echo test</command>.  This command will produce an output
   (the word <literal>test</literal>) as output, so find the
   <guilabel>Standard Output</guilabel> box and enter
   <literal>test</literal> in this box.  Make sure to hit the
   <keycap>Return</keycap> key after you type <literal>test</literal>;
   the <command>echo</command> command will output a carriage return
   after it prints the word <literal>test</literal>, so you must
   indicate that you expect a carriage return.  When you are done,
   click the <guibutton>OK</guibutton> button at the bottom of the
   form.</para>

   <para>Now you can click on the <guibutton>Run</guibutton> button to
   run the test.</para>

   <para>When you're done experimenting with &qmtest, you can shut it
   down by clicking the <guibutton>Shut Down</guibutton> button on the
   main page.</para>

  </section> <!-- sec-testtut-modifying -->

<!--

   <section>
    <title>Provided Test Classes</title>

    <para>&qmtest; comes with a module <classname>command</classname>,
    which contains three test classes for testing command-line programs.</para>

    <itemizedlist>
     <listitem>
      <para>The <classname>command.ExecTest</classname> test class
      runs a program and compares its exit code, standard output, and
      standard error to expected values.  The program is invoked
      directly, without a command shell, and is passed command-line
      arguments specified in the test.  The test may also specify text
      or data to pass to the program as standard input.</para>
     </listitem>

     <listitem>
      <para>The <classname>command.CommandTest</classname> is similar
      to <classname>command.ExecText</classname>, but runs the program
      via a command shell.  The command shell's escaping and
      substitution rules apply to the executed command.</para>

      <para>Since command shell syntaxes vary across platforms, tests
      written using this test class are not in general portable.</para>
     </listitem>

     <listitem>
      <para>The <classname>command.ScriptTest</classname> extends this
      by running an entire shell script, rather than a single shell
      command.  All the features of the command shell are available in
      the script.</para>

      <para>As with <classname>command.CommandTest</classname>, tests
      written with this class are not in general portable.</para>
     </listitem>

     <listitem>
      <para>The <classname>python.ExecTest</classname> test class runs
      a test by executing Python code.  A test can include either or
      both of a sequence of Python statements, as in an ordinary
      Python script, and a Python expression.  If the expression is
      provided, the test passes if and only if the expression
      evaluates to a true value.</para>
     </listitem>

     <listitem>
      <para>The <classname>python.ExeceptionTest</classname> test
      class runs a test by executing a sequence of Python statements.
      The test passes if the statements raises an exception.
      Optionally, the exception type and arguments may be specified in
      the test; if so, the exception raised by the Python code must
      match these for the test to pass.</para>
     </listitem>
    </itemizedlist>

    <para>Here's an example of a test using the second of these.</para>

    <programlisting><![CDATA[
<?xml version="1.0"?>
<!DOCTYPE test PUBLIC "-//Software Carpentry//&qmtest; Test V0.1//EN" "">
<test>
 <class>command.CommandTest</class>
 <argument name="command">
  <text>uname</text>
 </argument>
 <argument name="exit_code">
  <integer>0</integer>
 </argument>
 <argument name="stdout">
  <attachment>
   <data>Linux
</data>
  </attachment>
 </argument>
 <argument name="stderr">
  <attachment>
   <data></data>
  </attachment>
 </argument>
</test>
]]></programlisting>

    <para>The command argment specifies the command to run, in this case
    <command>uname</command>.  The <property>exit_code</property>
    argument specifies the expected exit code, in this case zero.  The
    <property>stdout</property> and <property>stderr</property>
    arguments specify the expected output to the respective streams.  In
    this case, the expected standard output is
    "<literal>Linux</literal>" followed by a newline, while no text is
    expected on standard error.</para>

   </section>
-->

</chapter>
<!--
  Local Variables:
  mode: sgml
  indent-tabs-mode: nil
  sgml-indent-step: 1 
  sgml-always-quote-attributes: t
  sgml-general-insert-case: lower
  sgml-minimize-attributes: nil
  sgml-parent-document: ("manual.xml" "book" "chapter")
  End:
-->
