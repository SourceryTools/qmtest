
		     Software Carpentry QM Tools

     Copyright (C) 2001 by CodeSourcery LLC.  All rights reserved.

------------------------------------------------------------------------

1.  REQUIREMENTS

    Besides Python, various tools are necessary for building QM
    software and documentation.  See

      http://www.software-carpentry.com/dev

    for more information on obtaining the tools.


    To run QM, you will need a Python 1.5.2 distribution.  

    Additionally, if you are building QM yourself, you will need the
    Distutils package.  You can get Distutils from

      http://www.python.org/sigs/distutils-sig/download.html

    This requirement will be obviated when QM updates to a newer version
    of Python.


------------------------------------------------------------------------

2.  BUILDING QM

    From the top of the source tree, first configure the sources:

      ./configure

    The configuration script looks for a Python interpreter executable
    in your PATH.  To specify a different interpreter, specify the
    option 

      --with-python=INTERPRETER_PATH

    Then build things:

      make


  - INSTALLING QM

    You may run QMTest and QMTrack directly out of the build area, or
    you may install them to a permanent location.  To install all the
    necessary files, invoke

      make install

    By default, this installs files under /usr/local; to use a different
    prefix, specify the --prefix option to configure.

    By default the QMTest and QMTrack executables are installed to
    /usr/local/bin/qmtest and /usr/local/bin/qmtrack, respectively.


------------------------------------------------------------------------

3.  GETTING STARTED WITH QMTRACK

    The QMTrack executable is qmtrack.  This single executable provides
    all QMTrack functionality.  There is no need to set up your
    PYTHONPATH; this is set automatically by the script.

    Before using QMTrack, you'll have to create an issue database (IDB).
    The IDB containes QMTrack's configuration plus the state and
    revision history of issues tracked by the system.


  - CREATING AN ISSUE DATABASE

    To create a new IDB, use the initialize command.  Specify the path
    to the new database.  Specify the --test-values option so that
    QMTrack adds to the IDB a sample test issue class (the schema that
    defines what information is stored for each issue) and a few sample
    issues to start you off.

      qmtrack initialize --test-values /path/to/idb

    Subsequently, you have to tell qmtrack where the IDB is.  Either use
    the --idb option, or

      export QMTRACK_DB_PATH=/path/to/idb


  - USING QMTRACK FROM THE COMMAND LINE

    You should then be able to poke around at the IDB.  For instance, to
    list the issue IDs of all issues in the IDB,

      qmtrack query --format iid 1

    The query expression "1" always evaluates to true, so all issues
    match.  Without the --format iid option, QMTrack displays more
    information about each issue.  Use the --help option to learn more
    about using the qmtrack command.

    To show more information about one issue, for instance the issue
    with ID "iss03",

      qmtrack show --format full iss03


  - USING THE QMTRACK WEB INTERFACE

    To start the web server, use the qmtrack server command.  For
    instance, to start the server on port 9000 and write log messages to
    stdout,

      qmtrack server --port 9000 --log-file -

    Point your web browser at

      http://my.host:9000/track/

    and click around.

    Note that at present, QMTrack binds binds the port number you
    specify on all network interfaces.  As a result, anyone with network
    access to your computer will be able to access the QMTrack server.


  - USER ACCOUNTS

    Note that this sets up a file called users.xml in the IDB directory
    that contains user accounts.  By default, there is only one user,
    "guest", which has no password and is used automatically for all web
    interaction.  Edit this file to add additional user accounts, or to
    disable the guest account.

    Here's an example of what a user account would look like:

      <user id="samuel" disabled="no">
       <info>
	<property name="name">John Doe</property>
	<property name="email">jdoe@mydomain.net</property>
       </info>
       <authentication>
	<property name="password">mypassword</property>
       </authentication>
      </user>

    The name and email properties are currently not used, but will be
    soon.  Note that right now user accounts apply to web interaction
    only; they are not used in the command line system.

    After you edit users.xml, restart the QMTrack server for the chnages
    to take effect.


  - IMPORTING AND EXPORTING XML

    To export tests in XML format, specify the --format xml option on
    the command line.  Use this option with any command which would
    result in one or more issues, such as the query command.  Redirect
    the output to a file using the --output option.

    For example, to export all issues in the IDB to the file issues.xml,
    use this command:

      qmtrack query --format xml --output issues.xml 1

    The "1" is a query string that always evaluates to true, and
    therefore matches every issue.

    To import issues in XML format into the database, use the import
    command.  For example

      qmtrack import issues.xml


  - CLEANING UP THE ISSUE DATABASE

    When you're done, you can erase the IDB with

      qmtrack destroy /path/to/idb


------------------------------------------------------------------------

4.  GETTING STARTED WITH QMTEST

    Until better tools for managing the test database are in place, some
    manual work is required to set things up.


  - TEST DATABASE ORGANIZATION

    Before you run QMTest, you'll have to set up a test database.  The
    database is a directory or directory tree containing tests and test
    suites.  Tests are represented by files with the .qmt extension.
    Test suites are represented by files with the .qms extension.  Each
    directory in the test suite also corresponds to an implicit test
    suite.

    Tests are referred to by test IDs.  These are simply the path in the
    test database tree, using `.' as the path separator.  The file
    extension is not part of the test ID.

    For example, suppose your test database, rooted at tdb, looks like
    this.

      tdb/core1.qmt
      tdb/core2.qmt
      tdb/gui/window.qmt
      tdb/gui/menu.qmt
      tdb/cmdline/help.qmt
      tdb/cmdline/verbose.qmt

    The test IDs of the "core" tests are simply "core1" and "core2".
    The test IDs of the GUI tests are "gui.window" and "gui.menu".  You
    may refer to these latter two tests together by specifying the
    (implicit) test suite "gui".

    All tests in the database are part of the implicit test suite ".".


  - TEST FILE CONTENTS

    A test file contains XML, using the <test> document element.

    The most important elements are <class>, which specifies the test
    class, and <argument>, which specifies one of the arguments to the
    (parameterized) test class.

    Suppose, for example, test class Count takes two arguments: an input
    string and an expected value.  The test computes the string length
    of the argument, and compares it to the expected value.

    A test of class Foo might look like this:

     <?xml version="1.0"?>
     <!DOCTYPE test PUBLIC "-//Software Carpentry//QMTest Test V0.1//EN" "">
     <test>
      <class>count.Count</class>
      <argument name="input">
       <text>This is the input.</text>
      </argument>
      <argument name="expected_value">
       <integer>18</integer>
      </argument>
     </test>

    Note that there are two <argument> elements, one for each argument.
    
    A sample test database is included in the QM distribution, in
    /usr/local/share/qm/tutorial/test/tdb.  This example is included in
    that database, as "test1" (stored in the file test1.qmt).


  - TEST CLASSES

    A test class is represented by a Python class.  The Python class
    needs three attributes:

      * An attribute named fields.  This attribute is a declaration of
        the parameters to the test class.  

	The parameters are represented by a sequence of objects, each an
	instance of qm.fields.Field.  For example, a text-valued field
	is an instance of qm.fields.TextField, an integer-valued field
	is an instance of qm.fields.IntegerField, etc.  See qm/fields.py
	and the corresponding documentation for details about these.

	The field names correspond to the argument names as specified in
	the test XML file.  In the Count example above, the field names
	are input and expected_value.


      * An __init__ function.  The arguments to this function must have
        the same names as the names of the fields.


      * A Run function.  This function is called with a single argument,
        an instance of qm.test.base.Context.  It should return an
        instance of qm.test.base.Result, indicating the test result.


   For example, the Count class described above might look like this.

    import qm.fields
    from   qm.test.base import Result

    class Count:
	fields = [
	    qm.fields.TextField(
		name="input",
		description="The input string."),
	    qm.fields.IntegerField(
		name="expected_value",
		description="The expected length of the input string."),
	    ]

	def __init__(self, input, expected_value):
	    # Store the arguments for later.
	    self.__input = input
	    self.__expected_value = expected_value

	def Run(self, context):
	    # Compute the length.
	    length = len(self.__input)
	    # Compare it to the expected value.
	    if length == self.__expected_value:
		return Result(Result.PASS)
	    else:
		return Result(Result.FAIL)


    The module containing this sample test class is included in the QM
    distribution, in /usr/local/share/qm/tutorial/test/count.py.  The
    module name is "count" and the class name is "Count", so you must
    specify the class name as "count.Count" in the <class> element of
    your test files, as illustrated above.

    Also, you must tell QMTest where to find the count module.  Set the
    environment variable QMTEST_CLASSPATH to the directory containing
    count.py, in this case /usr/local/share/qm/tutorial/test.


  - RUNNING TESTS

    Now that you have a test and a test class, you can run tests.  Make
    sure your QMTEST_CLASSPATH environment variable is set to the
    directory containing count.py.  Also set the QMTEST_DB_PATH
    environment variable to your test database directory ("tdb", above).

    For example, 

      $ ls /usr/local/share/qm/tutorial/test/
      count.py  tdb

      $ ls /usr/local/share/qm/tutorial/test/tdb
      test1.qmt  test2.qmt 

      $ export QMTEST_CLASSPATH=/usr/local/share/qm/tutorial/test/

      $ export QMTEST_DB_PATH=/usr/local/share/qm/tutorial/test/tdb/

    Now you can run tests using the qmtest run command.  Specify the
    test IDs to run on the command line.

      $ qmtest run test1

      --- STATISTICS -------------------------------------------

	     1        tests total

	     1 (100%) tests PASS

      --- TESTS THAT DID NOT PASS ------------------------------

        (None)

    QMTest runs test1, which passes.  To see what happens if a test
    fails, try running test2, which is the same as test1 except that a
    different value is specified for the expected_value parameter.


  - FULL TEST RESULTS

    Specify the --output option to generate a full test result listing
    in XML format.  For example,

      qmtest run --output results.xml .

    The period at the end of the file indicates the (implicit) test
    suite corresponding to the top of the test database tree, which
    includes all tests in the test database.


  - EXPECTED TEST RESULTS

    The full test result listing contains the outcome (PASS, FAIL, etc.)
    for each test that was run.  It may also contain additional
    information, as specified by the test class.  

    You can use the results from a previous test run as expected
    outcomes for a subsequent run.  QMTest will report, in addition to
    which tests passed or failed, which tests had outcomes different
    from expected values.  

    To use an XML result file as the expected outcomes for a subsequent
    test run, use the --outcomes option.  For example,

      qmtest run --outcomes results.xml test1


  - PROVIDED TEST CLASSES

    QMTest comes with a module named "command" that contains three test
    classes for testing command-line programs.

      * The command.ExecTest test class runs a program and compares its
        exit code, standard output, and standard error to expected
        values.

      * The command.CommandTest test class runs a program via a shell
        command and performs similar comparisons.

      * The command.ScriptTest test class runs a shell script and
        performs similar comparisons.

    Here's an example of a test using the second of these.

      <?xml version="1.0"?>
      <!DOCTYPE test PUBLIC "-//Software Carpentry//QMTest Test V0.1//EN" "">
      <test>
       <class>command.CommandTest</class>
       <argument name="command">
	<text>uname</text>
       </argument>
       <argument name="exit_code">
	<integer>0</integer>
       </argument>
       <argument name="stdout">
	<attachment>
	 <data>Linux
      </data>
	</attachment>
       </argument>
       <argument name="stderr">
	<attachment>
	 <data></data>
	</attachment>
       </argument>
      </test>

    The command argment specifies the command to run, in this case
    uname.  The exit_code argument specifies the expected exit code, in
    this case zero.  The stdout and stderr arguments specify the
    expected output to the respective streams.  In this case, the
    expected standard output is "Linux" followed by a newline, while no
    text is expected on standard error.

    To help you create new tests using more complicated test classes
    such as these, QMTest can create a blank XML test file for you.  Use
    the template command, specifying a test class name and the ID of the
    new test.  QMTest will create a blank test file in the correct
    place, and launch your editor so that you can modify it.

    For example,

      qmtest template command.ScriptTest mynewtest


------------------------------------------------------------------------

5. THIRD-PARTY SOFTWARE

   The QM Tools incorporate code written by third parties. 

     - The zope-dtml module contains code for generating HTML from DTML
       (Document Template Markup Language) from the Zope package, by
       Digital Creations.

     - The gadfly module containsthe Gadfly SQL Relational Database
       (http://www.chordate.com/kwParsing/gadfly.html), written by
       Chordate Systems.

     - The sgmlop module contains an optimized SGML/XML parser by
       Fredrik Lundh and Secret Labs AB.

     - The xmlrpc module contains a Python implementation of XML/RPC by
       Fredrik Lundh and Secret Labs AB.

     - The PyXML package contains XML-related software written by and/or
       copyright by Fourthought, Inc., BeOpen, CNRI, CWI, Greg Stein,
       Secret Labs AB, and Lars Marius Carshol.
       
   Please consult the corresponding READMEs, license files, etc. for
   applicable copyright notices.


------------------------------------------------------------------------
Local Variables:
mode: text
fill-column: 72
End:
