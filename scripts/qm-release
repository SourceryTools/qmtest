#! /bin/sh

########################################################################
#
# File:   qm-release
# Author: Mark Mitchell
# Date:   11/16/2001
#
# Contents:
#   Script to build QM releases.
#
# Copyright (C) 2001, 2002 CodeSourcery LLC
#
# For license terms see the file COPYING.
#
########################################################################

########################################################################
# Functions
########################################################################

# Issue the error message given by $1 and exit with a non-zero
# exit code.

error() {
    echo "qm-release: error: $1"
    exit 1
}

# Issue a usage message explaining how to use this script.

usage() {
cat <<EOF
qm-release version [-u] [source] [rpm] [binary] [exec] [tag]
EOF
    exit 1
}

# Change to the directory given by $1.

changedir() {
    cd $1 || \
	error "Could not change directory to $1"
}

# Tag the sources.

tag_qm() {
    echo "Tagging QM..."

    # Remove any old source distribution.
    rm -rf qm-${QM_VERSION}
    # Check out the source distribution.
    ${CVS} co -d qm-${QM_VERSION} \
      -r release-${QM_MAJOR_VER}-${QM_MINOR_VER}-branch qm || \
      error "Could not check out QM"
    changedir qm-${QM_VERSION}
    # Create the version file.
cat > version <<EOF
# This file is automatically generated.  Do not edit.

QM_VERSION=${QM_VERSION}
QM_MAJOR_VER=${QM_MAJOR_VER}
QM_MINOR_VER=${QM_MINOR_VER}
QM_RELEASE_VER=${QM_RELEASE_VER}
EOF
    # Commit the version file.
    ${CVS} commit -m 'Update version numbers.' version
    # Tag the sources.  Using the "-F" option to CVS makes sure that any
    # existing tag is moved, in case it takes several tries to get a 
    # release that we are happy with.
    ${CVS} tag -F ${QM_RELEASE_TAG} || \
      error "Could not tag QM"
}

# Build QM itself from the source distribution.

build_qm() {
    echo "Building QM..."

    # Remove any old source distribution.
    rm -rf qm-${QM_VERSION}
    # Untar the source distribution.  Under Windows there seem
    # to be cases where "tar xzf" will crash, but separating the
    # decompression and untarring steps works reliably.
    (gunzip -c ${QM_SOURCE_TAR_GZ} | tar xf -) || \
      error "Could not unpack source distribution"
    changedir qm-${QM_VERSION}
    # Create an installation directory.
    rm -rf ${QM_INSTALL_DIR}
    mkdir -p ${QM_INSTALL_DIR} || \
      error "Could not create installation directory"
    # Configure QM.
    ./configure --prefix=${QM_INSTALL_DIR} "$@" || \
      error "Could not configure QM"
    # Build it.
    make || error "Could not build QM"
    # Install it.
    make install || error "Could not install QM"
    # Go back to the directory we started in.
    changedir ..
}

# Build the source distribution.

build_source() {
    echo "Building source distribution..."
    # Remove the old version of the source distribution.
    rm -rf ${QM_SOURCE_TAR_GZ} qm-${QM_VERSION}
    ${CVS} export -d qm-${QM_VERSION} -r ${QM_RELEASE_TAG} qm || \
      error "Could not check out QM"
    # Remove the qm/track directory and packages that only it uses.
    rm -rf qm-${QM_VERSION}/qm/track qm-${QM_VERSION}/gadfly
    # The "-P" option is documented, but does not work, with "cvs export"
    # in CVS 1.10.7.  Therefore, just try to remove all the directories
    # exported; this will succeed only with empty directories.
    find qm-${QM_VERSION} -type d -exec rmdir {} \; > /dev/null 2>&1 
    # Create the tar file.
    tar czf ${QM_SOURCE_TAR_GZ} ${TAR_OPTS} qm-${QM_VERSION} || \
      error "Could not create tar file"
    # Build QM to obtain documentation files.
    build_qm --enable-maintainer_mode
    # Recreate the source directory.
    echo "Copying documentation..."
    rm -rf qm-${QM_VERSION}
    tar xzf ${QM_SOURCE_TAR_GZ} || \
      error "Could not unpack source distribution"
    cp -r ${QM_INSTALL_DIR}/share/doc/qm/test/html \
          qm-${QM_VERSION}/qm/test/doc/html || \
      error "Could not copy HTML manual"
    (mkdir qm-${QM_VERSION}/qm/test/doc/print && \
     cp -r ${QM_INSTALL_DIR}/share/doc/qm/test/pdf/manual.pdf \
          qm-${QM_VERSION}/qm/test/doc/print) || \
      error "Could not copy PDF manual"
    tar czf ${QM_SOURCE_TAR_GZ} ${TAR_OPTS} qm-${QM_VERSION} || \
      error "Could not create tar file"
}

# Build the RPM distribution.

build_rpm() {
    echo "Building RPM distribution..."
    cp ${QM_SOURCE_TAR_GZ} ${RPM_BASE}/SOURCES || \
      error "Could not install source distribution"
    (tar xzf ${QM_SOURCE_TAR_GZ} -O qm-${QM_VERSION}/qm.spec.in | \
      sed -e "s|@QM_VERSION@|${QM_VERSION}|g" > qm.spec) || \
      error "Could not extract spec file"
    rpm --quiet -ba --rmsource qm.spec || \
      error "Could not create RPM"
    cp ${RPM_BASE}/RPMS/i386/qm-${QM_VERSION}-0.i386.rpm ${QM_RPM}
}

# Build a binary distribution.

build_binary() {
    build_qm
    echo "Building binary distribution..."
    changedir ${QM_INSTALL_DIR}/..
    rm -f ../${QM_BINARY_TAR_GZ}
    tar czf ../${QM_BINARY_TAR_GZ} ${TAR_OPTS} qm-${QM_VERSION} || \
      error "Could not create tar file"
    changedir ..
}

# Build a self-extracting executable.

build_exec() {
    build_qm --with-python=/cygdrive/c/Python22/Python.exe
    echo "Building ZIP file..."
    changedir ${QM_INSTALL_DIR}
    rm -f ${QM_BINARY_ZIP}
    zip -q ${QM_BINARY_ZIP} -r . || \
      error "Could not create zip file"
    changedir ${QM_RELEASE_DIR}
    rm -f ${QM_BINARY_EXE}
    # The makesfx.exe exit code is apparently non-zero even on 
    # success, so we do not check the result.
    "c:/Program Files/FreeExtractor/makesfx.exe" \
      /zip="`cygpath -w ${QM_BINARY_ZIP}`" \
      /sfx="`cygpath -w ${QM_BINARY_EXE}`" \
      /title="QM ${QM_VERSION}" \
      /website="http://www.codesourcery.com" \
      /intro="Thank you for installing QMTest!" \
      /defaultpath="\$programfiles\$\\QM"
}

# Upload files to the FTP server.

upload() {
  # Figure out what platform we are on.
  tar xzf ${QM_SOURCE_TAR_GZ} qm-${QM_VERSION}/config.guess || \
    error "Could not obtain config.guess from source distribution."
  PLATFORM=`qm-${QM_VERSION}/config.guess`
  if [ $? -ne 0 ]; then
    error "Could not obtain platform name."
  fi
  PLATFORM_FTP_DIRECTORY="${FTP_DIRECTORY}/${PLATFORM}"

  # Make sure the FTP directory exists.
  ssh ${FTP_SERVER} mkdir -p ${FTP_DIRECTORY} ${PLATFORM_FTP_DIRECTORY} || \
    error "Could not create FTP directory."

  # Upload the source distribution.
  if [ ${SOURCE} -ne 0 ]; then
    scp ${QM_SOURCE_TAR_GZ} "${FTP_SERVER}:${FTP_DIRECTORY}" || \
      error "Could not upload source distribution."
    # Upload the manual as well.
    tar xzf ${QM_SOURCE_TAR_GZ} \
      qm-${QM_VERSION}/qm/test/doc/print/manual.pdf \
      qm-${QM_VERSION}/qm/test/doc/html || \
      error "Could not extract manuals."
    scp qm-${QM_VERSION}/qm/test/doc/print/manual.pdf \
      "${FTP_SERVER}:${FTP_DIRECTORY}" ||
      error "Could not upload PDF manual."
    scp -r qm-${QM_VERSION}/qm/test/doc/html \
      "${FTP_SERVER}:${FTP_DIRECTORY}/manual.html" ||
      error "Could not upload HTML manual."
  fi
  
  # Upload the RPM distribution.
  if [ ${RPM} -ne 0 ]; then
    scp ${QM_RPM} "${FTP_SERVER}:${PLATFORM_FTP_DIRECTORY}" || \
      error "Could not upload RPM distribution."
  fi

  # Upload the binary distribution.
  if [ ${BINARY} -ne 0 ]; then
    scp ${QM_BINARY_TAR_GZ} "${FTP_SERVER}:${PLATFORM_FTP_DIRECTORY}" || \
      error "Could not upload binary distribution."
  fi

  # Upload the self-extracting executable.
  if [ ${EXEC} -ne 0 ]; then
    scp ${QM_BINARY_EXE} "${FTP_SERVER}:${FTP_DIRECTORY}/windows" || \
      error "Could not upload Windows distribution."
  fi
}

########################################################################
# Initialization
########################################################################

# The CVS server containing the GCC repository.
CVS_SERVER="cvs.codesourcery.com"
# The path to the repository on that server.
CVS_REPOSITORY="/home/sc/Repository"
# The CVS protocol to use.
CVS_PROTOCOL="pserver"
# The username to use when connecting to the server.
CVS_USERNAME="anoncvs"

# The major version of QM.
QM_MAJOR_VER=
# The minor version of QM.
QM_MINOR_VER=
# The version of QM.
QM_VERSION=

# The base RPM directory.
RPM_BASE=/usr/src/redhat

# The source distribution.
QM_SOURCE_TAR_GZ=
# The binary distribution.
QM_BINARY_TAR_GZ=
# The ZIP file.
QM_BINARY_ZIP=
# The executable file.
QM_BINARY_EXE=
# The RPM distribution.
QM_RPM=

# Options to use with tar when creating an archive.
TAR_OPTS="--owner=root --group=root --mode=u+w,go-w,a+rX,a-st"

# The CVS binary.
CVS="cvs -f -z9 -Q"

# The FTP server.
FTP_SERVER="ftp.codesourcery.com"
# The FTP directory.
FTP_DIRECTORY="~ftp/pub/qmtest"

# Modes of operation.
SOURCE=0
RPM=0
BINARY=0
EXEC=0
TAG=0
UPLOAD=0

########################################################################
# Main Program
########################################################################

# Set our umask so that everyone can read the files created.
umask 002

# Parse options.
while getopts "u" ARG; do
    case $ARG in
    u)  UPLOAD=1;;
    \?) usage;;
    esac
done
shift `expr ${OPTIND} - 1`

# Parse the version number.
if [ $# -eq 0 ]; then
  usage
fi

QM_VERSION=$1
shift

# Compute the components of the version number.
QM_MAJOR_VER=`echo $QM_VERSION | awk --assign FS=. '{ print $1; }'`
QM_MINOR_VER=`echo $QM_VERSION | awk --assign FS=. '{ print $2; }'`
QM_RELEASE_VER=`echo $QM_VERSION | awk --assign FS=. '{ print $3; }'`
if test -z "$QM_RELEASE_VER"; then
    QM_RELEASE_VER=0
fi

QM_RELEASE_DIR=`pwd`
QM_SOURCE_TAR_GZ=qm-${QM_VERSION}.tar.gz
QM_BINARY_TAR_GZ=qm-${QM_VERSION}-binary.tar.gz
QM_BINARY_ZIP=${QM_RELEASE_DIR}/qm-${QM_VERSION}.zip
QM_BINARY_EXE=${QM_RELEASE_DIR}/qm-${QM_VERSION}.exe
QM_RPM=${QM_RELEASE_DIR}/qm-${QM_VERSION}-0.i386.rpm
QM_INSTALL_DIR=${QM_RELEASE_DIR}/install/qm-${QM_VERSION}
FTP_DIRECTORY=${FTP_DIRECTORY}/qm-${QM_VERSION}
QM_RELEASE_TAG="release-`echo $QM_VERSION | sed -e 's|\.|-|g'`"

# Handle the major modes.
while [ $# -ne 0 ]; do
    case $1 in
    source) SOURCE=1;;
    rpm)    RPM=1;;
    binary) BINARY=1;;
    exec)   EXEC=1;;
    tag)    TAG=1;;
    *)      usage;;
    esac
    shift
done

# Set up CVS.
CVSROOT=":${CVS_PROTOCOL}:${CVS_USERNAME}@"
CVSROOT="${CVSROOT}${CVS_SERVER}:${CVS_REPOSITORY}"
export CVSROOT

if [ ${UPLOAD} -eq 0 ]; then
    if [ ${TAG} -ne 0 ]; then
      tag_qm
    fi

    if [ ${SOURCE} -ne 0 ]; then
      build_source
    fi

    if [ ${RPM} -ne 0 ]; then
      build_rpm
    fi

    if [ ${BINARY} -ne 0 ]; then
      build_binary
    fi

    if [ ${EXEC} -ne 0 ]; then
      build_exec
    fi
else
    upload
fi
