<dtml-comment><!--

  File:   state-model.dtml
  Author: Alex Samuel
  Date:   2001-07-11

  Contents:
    Page for editing a state model.

  Copyright (C) 2001 CodeSourcery LLC.  This material may
  be distributed only subject to the terms and conditions set forth in
  the Software Carpentry Open Publication License, which is available at:

    http://www.software-carpentry.com/openpub-license.html

--></dtml-comment>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xhtmlns="http://www.w3.org/1999/xhtml">
 <dtml-var expr="GenerateHtmlHeader('Edit State Model')">
 <dtml-var expr="GenerateStartBody()">

  <table border="0" cellpadding="0" cellspacing="0" width="100%">
   <tr>
    <td>
     <h3>State Model</h3>
    </td>
   </tr>
  </table>

  <form name="form">

  <table border="0" 
         cellpadding="4"
         cellspacing="4"
         width="100%">

  <tr class="field" valign="top">
   <td>
    <b>States</b>
   </td>
   <td>
    <table border="0" cellpadding="0" cellspacing="0">
     <tr valign="top">
      <td colspan="2">
       <select name="states"
	           onchange="on_states_selchange();"
               size="8"
               width="280">
        <option value="placeholder">(placeholder)</option>
       </select>
      </td>
      <td>
       <input type="button"
              size="12"
              value=" Remove "
              onclick="on_states_remove();" />
      </td>
     </tr>
     <tr>
      <td>
       Name:
      </td>
      <td>
       <input type="text"
              name="state_name"
              onkeydown="document.form.states_add_button.value = ' Add ';
                         document.form.states.selectedIndex = -1;"
              size="32" />
      </td>
      <td>
       <input type="button"
	          name="states_add_button"
              size="12"
              value=" Add "
              onclick="on_states_add()" />
      </td>
     </tr>
     <tr valign="top">
      <td>
       <br>Description:
      </td>
      <td>
       <textarea name="description"
	             cols="40"
	             rows="6">
       </textarea>
      </td>
      <td>&nbsp;</td>
     </tr>
     <tr>
      <td>
       Open:
      </td>
      <td>
       <input type="checkbox"
              name="is_open"
		      checked />
       This is an open state.
      </td>
      <td>&nbsp;</td>
     </tr>
    </table>
   </td>
  </tr>

  <tr class="field" valign="top">
   <td>
    <b>Initial State</b>
   </td>
   <td>
    <select name="initial_state"
            width="12">
        <option value="placeholder">(placeholder)</option>
    </select>
   </td>
  </tr>

  <tr class="field" valign="top">
   <td>
    <b>Transitions</b>
   </td>
   <td>
    <table border="0" cellpadding="0" cellspacing="0">
     <tr valign="top">
      <td colspan="2">
       <select name="transitions"
               size="8"
               width="280">
        <option value="placeholder">(placeholder)</option>
       </select>
      </td>
      <td>
       <input type="button"
              size="12"
              value=" Remove "
              onclick="on_transitions_remove();" />
      </td>
     </tr>
     <tr>
      <td>
       Starting State:
      </td>
      <td>
       <select name="start_state">
        <option value="placeholder">(placeholder)</option>
       </select>
      </td>
      <td>
       <input type="button"
              size="12"
              value=" Add "
              onclick="on_transitions_add();" />
      </td>
     </tr>
     <tr>
      <td>
       Ending State:
      </td>
      <td>
       <select name="end_state">
        <option value="placeholder">(placeholder)</option>
       </select>
      </td>
      <td>&nbsp;</td>
     </tr>
     <tr>
      <td>
       Condition:
      </td>
      <td>
       <input type="text"
              name="condition"
              size="32" />
      </td>
      <td>&nbsp;</td>
     </tr>
    </table>
   </td>
  </tr>
 </table>  

 <input type="button"
        value=" OK "
		onclick="window.opener.document.form.
                     <dtml-var expr="request['input']">.value
                     = encode_state_model();
                 window.close();"
 />
 <input type="button"
        value=" Close "
        onclick="window.close();"
 />

 </form>

 <dtml-var expr="GenerateEndBody()">

<script language="JavaScript1.2">

// Decode a string-encoded state model and initialize inputs.
//
// 'encoding' -- A string-encoded state model.  
//
// postconditions -- Form input show the state model.
//
// See the Python function 'qm.track.issue_class.encode_state_model' for
// a description of the encoding scheme.

function decode_state_model(encoding)
{
  var i;
  var parts, subparts;
  var select;
  
  // Split into major parts.
  parts = encoding.split("|");

  // The first part is a list of states.
  var states = new Array();
  subparts = parts[0].split(";");
  for(i = 0; i < subparts.length; ++i)
    // Decode and accumulate each state.
    states = states.concat(decode_state(subparts[i]));

  // The second part is the name of the initial state.
  var initial_state = parts[1];

  // The third part is a list of transitions.
  var transitions = new Array();
  subparts = parts[2].split(";");
  for(i = 0; i < subparts.length; ++i) 
    // Decode and accumulate each transition.
    transitions = transitions.concat(decode_transition(subparts[i]));

  // Construct options for states.
  select = document.form.states;
  // Clear out the old contents.
  select.options.length = 0;
  for(i = 0; i < states.length; ++i)
    // The option value is the encoded state.
    select.options[i] = new Option(format_state(states[i]),
                                   states[i].encoding);
  // Propagate the change in the list of states to other inputs.
  on_states_change();

  // Initialize the initial state input.
  select_item(document.form.initial_state, initial_state);

  // Construct the transitions select.
  select = document.form.transitions;  
  // Clear out the old contents.
  select.options.length = 0;
  for(i = 0; i < transitions.length; ++i)
    // The option value is the encoded transition.
    select.options[i] = new Option(format_transition(transitions[i]),
                                   transitions[i].encoding);
}


// Decode a string-encoded state.
//
// 'encoding' -- A string-encoded state.
//
// returns -- A state object.
//
// See the Python function 'qm.track.issue_class.encode_state_model' for
// a description of the encoding scheme.

function decode_state(encoding)
{
  var state = new Object();
  var parts = encoding.split(",");
  state.name = parts[0];
  state.description = unescape(parts[1]);
  state.is_open = parts[2];
  state.encoding = encoding;
  return state;
}


// Decode a string-encoded transition.
//
// 'encoding' -- A string-encoded transition.
//
// returns -- A transition object.
//
// See the Python function 'qm.track.issue_class.encode_state_model' for
// a description of the encoding scheme.

function decode_transition(encoding)
{
  var transition = new Object();
  var parts = encoding.split(",");
  transition.start = parts[0];
  transition.end = parts[1];
  if(parts.length < 3 || parts[2] == "")
    // JavaScript's 'String.split' is dumb.
    transition.condition = "";
  else
    transition.condition = unescape(parts[2]);
  transition.encoding = encoding;
  return transition
}


// Construct a user-visible representation of a state.
//
// 'state' -- A state object.
//
// returns -- A string representing the state.

function format_state(state)
{
  return state.name;
}


// Construct a user-visible representation of a transition.
//
// 'transition' -- A transition object.
//
// returns -- A string representing the transition.

function format_transition(transition)
{
  var result = transition.start + " -> " + transition.end;
  if(transition.condition != "")
    result += " [only if " + transition.condition + "]";
  return result;
}


// Construct a state object.
//
// 'name' -- The state name.
//
// 'description' -- A description of the state.
//
// 'is_open' -- Whether this is an open state; either "1" or "0".
//
// returns -- A state object.

function make_state(name, description, is_open)
{
  var state = new Object();
  state.name = name;
  state.description = description;
  state.is_open = is_open;
  state.encoding = name + "," + escape(description) + "," + is_open;
  return state;
}


// Construct a transition object.
//
// 'start' -- The name of the starting state.
//
// 'end' -- The name of the ending state.
//
// 'condition' -- The transition condition; may be an empty string.
//
// returns -- A transition object.

function make_transition(start, end, condition)
{
  var transition = new Object();
  transition.start = start;
  transition.end = end;
  transition.condition = condition;
  transition.encoding = start + "," + end + "," + escape(condition);
  return transition;
}


// Encode the state model in the form inputs as a string.
//
// returns -- A string encoding the state model in the form inputs.
//
// See the Python function 'qm.track.issue_class.encode_state_model' for
// a description of the encoding scheme.

function encode_state_model()
{
  var result = "";
  var i;
  var select;

  // Construct a semicolon-separated list of encoded states.
  select = document.form.states;
  for(i = 0; i < select.options.length; ++i) {
    if(i > 0)
      result += ";"
    result += select.options[i].value;
  }

  // Next the initial state name, separated by pipe characters.
  result += "|" + get_selected_value(document.form.initial_state) + "|"

  // Finally, a semicolon-separated list of encoded transitions.
  select = document.form.transitions;
  for(i = 0; i < select.options.length; ++i) {
    if(i > 0)
      result += ";";
    result += select.options[i].value;
  }

  return result;
}


// Update inputs when a new state is selected.

function on_states_selchange()
{
  var select = document.form.states;
  var index = select.selectedIndex;
  if(index == -1)
    // Nothing is selected.
    return;
  // Fill the value of the selected states into the other inputs, so the
  // user can modify the state.
  var state = decode_state(select.options[index].value);
  document.form.state_name.value = state.name;
  document.form.description.value = state.description;
  document.form.is_open.checked = state.is_open == "1";
  // Indicate that the state will be changed.
  document.form.states_add_button.value = " Change ";    
}


// Update inputs when the set of states changes.
//
// postconditions -- Combo box select inputs are updated to reflect the
// current list of states from the main state select input.

function on_states_change()
{
  var i;
  var state_names = new Array();

  // Construct an array of states.
  var options = document.form.states.options;
  for(i = 0; i < options.length; ++i) {
    state = decode_state(options[i].value);
    state_names = state_names.concat(state.name);
  }

  // Rebuild the initial state select.
  rebuild_state_select(document.form.initial_state, state_names);
  // Rebuild the transition start and end state selects.
  rebuild_state_select(document.form.start_state, state_names);
  rebuild_state_select(document.form.end_state, state_names);
}


// Rebuild a state combo box select for a new set of states.
//
// 'select' -- The select input to update.
//
// 'state_names' -- An array of names of states.

function rebuild_state_select(select, state_names)
{
  var i;
  var old_value;
  var options = select.options;

  // Remeber the selected value, if any, so we can restore it.
  if(select.selectedIndex == -1)
    old_value = null;
  else
    old_value = select.options[select.selectedIndex].value;

  // Clear out the select.
  options.length = 0;
  // Rebuild the options.
  for(i = 0; i < state_names.length; ++i) {
    options[i] = new Option(state_names[i], state_names[i]);
    // If this option matches the old selected value, select it.
    if(old_value == state_names[i])
      select.selectedIndex = i;
  }
}


// Remove the selected state.

function on_states_remove()
{
  var i;
  var select;
  var index;

  select = document.form.states;
  index = select.selectedIndex;
  if(index == -1)
    // Nothing selected.
    return;
  // Decode the state we're about to remove.
  var state = decode_state(select.options[index].value);
  // Remove it from the select.
  select.options[index] = null;
  // Update controls that list states.
  on_states_change();

  if(index < select.options.length) {
	// Select the previous element in the state select input.
    select.selectedIndex = index;
    on_states_selchange();
  }
  else {
	// Don't select anything, and clear out the other state inputs.
	document.form.state_name.value = "";
	document.form.description.value = "";
	document.form.is_open.checked = true;
	document.form.states_add_button.value = " Add ";    
  }

  // Discard all transitions involving this state.
  select = document.form.transitions;
  for(i = select.options.length - 1; i >= 0; --i) {
    transition = decode_transition(select.options[i].value);
	// Does the transition start or end at this state?
    if(transition.start == state.name || transition.end == state.name)
	  // Yes; drop it.
      select.options[i] = null;
  }
}


// Add a new state, or commit changes to an existing state.
//
// Uses contents of state inputs to construct the new state.
//
// If the state name matches an existing state, that state is modified.
// Otherwse, creates a new state.

function on_states_add()
{
  var i;
  var select = document.form.states;
  var index;

  // Extract attributes of the new state.
  var state_name = document.form.state_name.value;
  var description = document.form.description.value;
  var is_open = document.form.is_open.checked ? "1" : "0";
  var state = make_state(state_name, description, is_open);

  // If the state name isn't valid, complain and bail.
  if(!label_is_valid(state_name)) {
    popup_box("Error",
              "A state name can consist only of lower-case letters, " +
              "digits, and underscores, and cannot be empty.");
    return;
  }

  // Compare the state name to existing states.  If we don't find a
  // match, we'll append a new state.
  index = select.options.length;
  for(i = 0; i < select.options.length; ++i) {
    if(decode_state(select.options[i].value).name == state_name) {
	  // A match.  Modify this state instead of appending.
      index = i;
	  break;
	}
  }

  // Construc the new select option.
  select.options[index] = new Option(format_state(state), state.encoding);
  // Select the added or changed item.
  select.selectedIndex = index;
  on_states_change();
  document.form.states_add_button.value = " Change ";
}


// Remove the selected transition.

function on_transitions_remove()
{
  var select = document.form.transitions;
  var index = select.selectedIndex;
  if(index == -1)
    // Nothing selected.
    return;
  // Remove the transition from the list.
  select.options[index] = null;
  // Select the previous transition, if there is one.
  if(index < select.options.length)
    select.selectedIndex = index;
  else
    select.selectedIndex = - 1;
}


// Add a new transition.
//
// Uses contents of transition inputs to construct the new transition.

function on_transitions_add()
{
  var select = document.form.transitions;
  var index = select.options.length;
  var transition;

  // Construct the transition object.
  transition = make_transition(
      get_selected_value(document.form.start_state),
      get_selected_value(document.form.end_state),
      document.form.condition.value);
  // Append it to the select.
  select.options[index] = new Option(format_transition(transition), 
									 transition.encoding);
  // Select the newly-added item.
  select.selectedIndex = index;
}


// Decode the state model and initialize inputs on load.
decode_state_model(window.opener.document.form.
                   <dtml-var expr="request['input']">.value);

</script>

</html>

<dtml-comment><!-- 
  Local Variables:
  mode: xml
  indent-tabs-mode: nil
  fill-column:72
  End:
--></dtml-comment>
